/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const ProfileResIdl = $root.ProfileResIdl = (() => {

    /**
     * Properties of a ProfileResIdl.
     * @exports IProfileResIdl
     * @interface IProfileResIdl
     * @property {IError|null} [error] ProfileResIdl error
     * @property {IDataRes|null} [data] ProfileResIdl data
     */

    /**
     * Constructs a new ProfileResIdl.
     * @exports ProfileResIdl
     * @classdesc Represents a ProfileResIdl.
     * @implements IProfileResIdl
     * @constructor
     * @param {IProfileResIdl=} [properties] Properties to set
     */
    function ProfileResIdl(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ProfileResIdl error.
     * @member {IError|null|undefined} error
     * @memberof ProfileResIdl
     * @instance
     */
    ProfileResIdl.prototype.error = null;

    /**
     * ProfileResIdl data.
     * @member {IDataRes|null|undefined} data
     * @memberof ProfileResIdl
     * @instance
     */
    ProfileResIdl.prototype.data = null;

    /**
     * Creates a new ProfileResIdl instance using the specified properties.
     * @function create
     * @memberof ProfileResIdl
     * @static
     * @param {IProfileResIdl=} [properties] Properties to set
     * @returns {ProfileResIdl} ProfileResIdl instance
     */
    ProfileResIdl.create = function create(properties) {
        return new ProfileResIdl(properties);
    };

    /**
     * Encodes the specified ProfileResIdl message. Does not implicitly {@link ProfileResIdl.verify|verify} messages.
     * @function encode
     * @memberof ProfileResIdl
     * @static
     * @param {IProfileResIdl} message ProfileResIdl message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ProfileResIdl.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
            $root.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.DataRes.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ProfileResIdl message, length delimited. Does not implicitly {@link ProfileResIdl.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ProfileResIdl
     * @static
     * @param {IProfileResIdl} message ProfileResIdl message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ProfileResIdl.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ProfileResIdl message from the specified reader or buffer.
     * @function decode
     * @memberof ProfileResIdl
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ProfileResIdl} ProfileResIdl
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ProfileResIdl.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProfileResIdl();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.error = $root.Error.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.data = $root.DataRes.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ProfileResIdl message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ProfileResIdl
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ProfileResIdl} ProfileResIdl
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ProfileResIdl.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ProfileResIdl message.
     * @function verify
     * @memberof ProfileResIdl
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ProfileResIdl.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.error != null && message.hasOwnProperty("error")) {
            let error = $root.Error.verify(message.error);
            if (error)
                return "error." + error;
        }
        if (message.data != null && message.hasOwnProperty("data")) {
            let error = $root.DataRes.verify(message.data);
            if (error)
                return "data." + error;
        }
        return null;
    };

    /**
     * Creates a ProfileResIdl message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ProfileResIdl
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ProfileResIdl} ProfileResIdl
     */
    ProfileResIdl.fromObject = function fromObject(object) {
        if (object instanceof $root.ProfileResIdl)
            return object;
        let message = new $root.ProfileResIdl();
        if (object.error != null) {
            if (typeof object.error !== "object")
                throw TypeError(".ProfileResIdl.error: object expected");
            message.error = $root.Error.fromObject(object.error);
        }
        if (object.data != null) {
            if (typeof object.data !== "object")
                throw TypeError(".ProfileResIdl.data: object expected");
            message.data = $root.DataRes.fromObject(object.data);
        }
        return message;
    };

    /**
     * Creates a plain object from a ProfileResIdl message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ProfileResIdl
     * @static
     * @param {ProfileResIdl} message ProfileResIdl
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ProfileResIdl.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.error = null;
            object.data = null;
        }
        if (message.error != null && message.hasOwnProperty("error"))
            object.error = $root.Error.toObject(message.error, options);
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = $root.DataRes.toObject(message.data, options);
        return object;
    };

    /**
     * Converts this ProfileResIdl to JSON.
     * @function toJSON
     * @memberof ProfileResIdl
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ProfileResIdl.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ProfileResIdl
     * @function getTypeUrl
     * @memberof ProfileResIdl
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ProfileResIdl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ProfileResIdl";
    };

    return ProfileResIdl;
})();

export const Error = $root.Error = (() => {

    /**
     * Properties of an Error.
     * @exports IError
     * @interface IError
     * @property {number|null} [errorno] Error errorno
     * @property {string|null} [errmsg] Error errmsg
     * @property {string|null} [usermsg] Error usermsg
     */

    /**
     * Constructs a new Error.
     * @exports Error
     * @classdesc Represents an Error.
     * @implements IError
     * @constructor
     * @param {IError=} [properties] Properties to set
     */
    function Error(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Error errorno.
     * @member {number} errorno
     * @memberof Error
     * @instance
     */
    Error.prototype.errorno = 0;

    /**
     * Error errmsg.
     * @member {string} errmsg
     * @memberof Error
     * @instance
     */
    Error.prototype.errmsg = "";

    /**
     * Error usermsg.
     * @member {string} usermsg
     * @memberof Error
     * @instance
     */
    Error.prototype.usermsg = "";

    /**
     * Creates a new Error instance using the specified properties.
     * @function create
     * @memberof Error
     * @static
     * @param {IError=} [properties] Properties to set
     * @returns {Error} Error instance
     */
    Error.create = function create(properties) {
        return new Error(properties);
    };

    /**
     * Encodes the specified Error message. Does not implicitly {@link Error.verify|verify} messages.
     * @function encode
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.errorno != null && Object.hasOwnProperty.call(message, "errorno"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorno);
        if (message.errmsg != null && Object.hasOwnProperty.call(message, "errmsg"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.errmsg);
        if (message.usermsg != null && Object.hasOwnProperty.call(message, "usermsg"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.usermsg);
        return writer;
    };

    /**
     * Encodes the specified Error message, length delimited. Does not implicitly {@link Error.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Error message from the specified reader or buffer.
     * @function decode
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Error();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.errorno = reader.int32();
                    break;
                }
            case 2: {
                    message.errmsg = reader.string();
                    break;
                }
            case 3: {
                    message.usermsg = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Error message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Error message.
     * @function verify
     * @memberof Error
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Error.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.errorno != null && message.hasOwnProperty("errorno"))
            if (!$util.isInteger(message.errorno))
                return "errorno: integer expected";
        if (message.errmsg != null && message.hasOwnProperty("errmsg"))
            if (!$util.isString(message.errmsg))
                return "errmsg: string expected";
        if (message.usermsg != null && message.hasOwnProperty("usermsg"))
            if (!$util.isString(message.usermsg))
                return "usermsg: string expected";
        return null;
    };

    /**
     * Creates an Error message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Error
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Error} Error
     */
    Error.fromObject = function fromObject(object) {
        if (object instanceof $root.Error)
            return object;
        let message = new $root.Error();
        if (object.errorno != null)
            message.errorno = object.errorno | 0;
        if (object.errmsg != null)
            message.errmsg = String(object.errmsg);
        if (object.usermsg != null)
            message.usermsg = String(object.usermsg);
        return message;
    };

    /**
     * Creates a plain object from an Error message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Error
     * @static
     * @param {Error} message Error
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Error.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.errorno = 0;
            object.errmsg = "";
            object.usermsg = "";
        }
        if (message.errorno != null && message.hasOwnProperty("errorno"))
            object.errorno = message.errorno;
        if (message.errmsg != null && message.hasOwnProperty("errmsg"))
            object.errmsg = message.errmsg;
        if (message.usermsg != null && message.hasOwnProperty("usermsg"))
            object.usermsg = message.usermsg;
        return object;
    };

    /**
     * Converts this Error to JSON.
     * @function toJSON
     * @memberof Error
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Error.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Error
     * @function getTypeUrl
     * @memberof Error
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Error.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Error";
    };

    return Error;
})();

export const DataRes = $root.DataRes = (() => {

    /**
     * Properties of a DataRes.
     * @exports IDataRes
     * @interface IDataRes
     * @property {IUser|null} [user] DataRes user
     */

    /**
     * Constructs a new DataRes.
     * @exports DataRes
     * @classdesc Represents a DataRes.
     * @implements IDataRes
     * @constructor
     * @param {IDataRes=} [properties] Properties to set
     */
    function DataRes(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DataRes user.
     * @member {IUser|null|undefined} user
     * @memberof DataRes
     * @instance
     */
    DataRes.prototype.user = null;

    /**
     * Creates a new DataRes instance using the specified properties.
     * @function create
     * @memberof DataRes
     * @static
     * @param {IDataRes=} [properties] Properties to set
     * @returns {DataRes} DataRes instance
     */
    DataRes.create = function create(properties) {
        return new DataRes(properties);
    };

    /**
     * Encodes the specified DataRes message. Does not implicitly {@link DataRes.verify|verify} messages.
     * @function encode
     * @memberof DataRes
     * @static
     * @param {IDataRes} message DataRes message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DataRes.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.user != null && Object.hasOwnProperty.call(message, "user"))
            $root.User.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DataRes message, length delimited. Does not implicitly {@link DataRes.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DataRes
     * @static
     * @param {IDataRes} message DataRes message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DataRes.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DataRes message from the specified reader or buffer.
     * @function decode
     * @memberof DataRes
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DataRes} DataRes
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DataRes.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DataRes();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.user = $root.User.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DataRes message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DataRes
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DataRes} DataRes
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DataRes.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DataRes message.
     * @function verify
     * @memberof DataRes
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DataRes.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.user != null && message.hasOwnProperty("user")) {
            let error = $root.User.verify(message.user);
            if (error)
                return "user." + error;
        }
        return null;
    };

    /**
     * Creates a DataRes message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DataRes
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DataRes} DataRes
     */
    DataRes.fromObject = function fromObject(object) {
        if (object instanceof $root.DataRes)
            return object;
        let message = new $root.DataRes();
        if (object.user != null) {
            if (typeof object.user !== "object")
                throw TypeError(".DataRes.user: object expected");
            message.user = $root.User.fromObject(object.user);
        }
        return message;
    };

    /**
     * Creates a plain object from a DataRes message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DataRes
     * @static
     * @param {DataRes} message DataRes
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DataRes.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.user = null;
        if (message.user != null && message.hasOwnProperty("user"))
            object.user = $root.User.toObject(message.user, options);
        return object;
    };

    /**
     * Converts this DataRes to JSON.
     * @function toJSON
     * @memberof DataRes
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DataRes.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DataRes
     * @function getTypeUrl
     * @memberof DataRes
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DataRes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/DataRes";
    };

    return DataRes;
})();

export const User = $root.User = (() => {

    /**
     * Properties of a User.
     * @exports IUser
     * @interface IUser
     * @property {number|null} [isLogin] User isLogin
     * @property {number|Long|null} [id] User id
     * @property {string|null} [name] User name
     * @property {string|null} [nameShow] User nameShow
     * @property {string|null} [portrait] User portrait
     * @property {number|null} [noUn] User noUn
     * @property {number|null} [type] User type
     * @property {INewUser|null} [newUserInfo] User newUserInfo
     * @property {number|null} [userhide] User userhide
     * @property {IBalv|null} [balv] User balv
     * @property {number|null} [isManager] User isManager
     * @property {string|null} [rank] User rank
     * @property {string|null} [bimgUrl] User bimgUrl
     * @property {number|null} [meizhiLevel] User meizhiLevel
     * @property {number|null} [isVerify] User isVerify
     * @property {number|null} [isInterestman] User isInterestman
     * @property {Array.<IIcon>|null} [iconinfo] User iconinfo
     * @property {Array.<ITshowInfo>|null} [tshowIcon] User tshowIcon
     * @property {number|null} [userType] User userType
     * @property {number|null} [isCoreuser] User isCoreuser
     * @property {number|null} [isHuinibuke] User isHuinibuke
     * @property {string|null} [iosBimgFormat] User iosBimgFormat
     * @property {number|null} [levelId] User levelId
     * @property {number|null} [isLike] User isLike
     * @property {number|null} [isBawu] User isBawu
     * @property {string|null} [bawuType] User bawuType
     * @property {string|null} [portraith] User portraith
     * @property {string|null} [ip] User ip
     * @property {string|null} [BDUSS] User BDUSS
     * @property {number|null} [fansNum] User fansNum
     * @property {number|null} [concernNum] User concernNum
     * @property {number|null} [sex] User sex
     * @property {number|null} [myLikeNum] User myLikeNum
     * @property {string|null} [intro] User intro
     * @property {number|null} [hasConcerned] User hasConcerned
     * @property {string|null} [passwd] User passwd
     * @property {number|null} [postNum] User postNum
     * @property {string|null} [tbAge] User tbAge
     * @property {number|null} [isMem] User isMem
     * @property {number|null} [bimgEndTime] User bimgEndTime
     * @property {IPayMemberInfo|null} [payMemberInfo] User payMemberInfo
     * @property {number|null} [gender] User gender
     * @property {number|null} [isMask] User isMask
     * @property {Array.<IUserPics>|null} [userPics] User userPics
     * @property {IPrivSets|null} [privSets] User privSets
     * @property {number|null} [isFriend] User isFriend
     * @property {Array.<ILikeForumInfo>|null} [likeForum] User likeForum
     * @property {Array.<IMyGroupInfo>|null} [groupList] User groupList
     * @property {number|null} [giftNum] User giftNum
     * @property {Array.<IGiftInfo>|null} [giftList] User giftList
     * @property {number|null} [isSelectTail] User isSelectTail
     * @property {number|null} [isGuanfang] User isGuanfang
     * @property {number|null} [bookmarkCount] User bookmarkCount
     * @property {number|null} [bookmarkNewCount] User bookmarkNewCount
     * @property {Array.<ISimpleUser>|null} [muteUser] User muteUser
     * @property {number|Long|null} [friendNum] User friendNum
     * @property {string|null} [fansNickname] User fansNickname
     * @property {string|null} [bgPic] User bgPic
     * @property {INewParrScores|null} [parrScores] User parrScores
     * @property {INovelFansInfo|null} [novelFansInfo] User novelFansInfo
     * @property {IUserVipInfo|null} [vipInfo] User vipInfo
     * @property {IGodInfo|null} [godData] User godData
     * @property {number|null} [heavyUser] User heavyUser
     * @property {IVipShowInfo|null} [vipShowInfo] User vipShowInfo
     * @property {Array.<ITshowInfo>|null} [newTshowIcon] User newTshowIcon
     * @property {ITwZhiBoUser|null} [twAnchorInfo] User twAnchorInfo
     * @property {Array.<ITwAnchorProfitItem>|null} [profitList] User profitList
     * @property {IConsumeInfo|null} [consumeInfo] User consumeInfo
     * @property {IThemeCardInUser|null} [themeCard] User themeCard
     * @property {IVipCloseAd|null} [vipCloseAd] User vipCloseAd
     * @property {IActivitySponsor|null} [activitySponsor] User activitySponsor
     * @property {ITbVipInfo|null} [tbVip] User tbVip
     * @property {number|null} [noPostHigh] User noPostHigh
     * @property {IEcom|null} [ecom] User ecom
     * @property {number|null} [visitorNum] User visitorNum
     * @property {number|null} [totalVisitorNum] User totalVisitorNum
     * @property {IPendant|null} [pendant] User pendant
     * @property {IAlaUserInfo|null} [alaInfo] User alaInfo
     * @property {string|null} [sealPrefix] User sealPrefix
     * @property {number|null} [hasBottleEnter] User hasBottleEnter
     * @property {IUserVideoChannelInfo|null} [videoChannelInfo] User videoChannelInfo
     * @property {ISpringVirtualUser|null} [springVirtualUser] User springVirtualUser
     * @property {number|null} [eachOtherFriend] User eachOtherFriend
     * @property {IEsportInfo|null} [esportData] User esportData
     * @property {IAlaLiveInfo|null} [alaLiveInfo] User alaLiveInfo
     * @property {number|null} [nicknameUpdateTime] User nicknameUpdateTime
     * @property {number|null} [threadNum] User threadNum
     * @property {number|null} [agreeNum] User agreeNum
     * @property {number|null} [leftCallNum] User leftCallNum
     * @property {number|null} [isInvited] User isInvited
     * @property {number|null} [isFans] User isFans
     * @property {number|null} [privThread] User privThread
     * @property {number|null} [isVideobiggie] User isVideobiggie
     * @property {number|null} [isShowRedpacket] User isShowRedpacket
     * @property {IBaijiahaoInfo|null} [baijiahaoInfo] User baijiahaoInfo
     * @property {IBirthdayInfo|null} [birthdayInfo] User birthdayInfo
     * @property {number|null} [canModifyAvatar] User canModifyAvatar
     * @property {string|null} [modifyAvatarDesc] User modifyAvatarDesc
     * @property {number|null} [influence] User influence
     * @property {string|null} [levelInfluence] User levelInfluence
     * @property {INewGodInfo|null} [newGodData] User newGodData
     * @property {IBawuThrones|null} [bawuThrones] User bawuThrones
     * @property {ICallFansInfo|null} [callFansInfo] User callFansInfo
     * @property {IBazhuSign|null} [bazhuGrade] User bazhuGrade
     * @property {number|null} [isDefaultAvatar] User isDefaultAvatar
     * @property {string|null} [uk] User uk
     * @property {ICreationData|null} [creationData] User creationData
     * @property {number|null} [favoriteNum] User favoriteNum
     * @property {ILiveRoomInfo|null} [liveRoomInfo] User liveRoomInfo
     * @property {IBusinessAccountInfo|null} [businessAccountInfo] User businessAccountInfo
     * @property {string|null} [appealThreadPopover] User appealThreadPopover
     * @property {Array.<IForumToolPerm>|null} [forumToolAuth] User forumToolAuth
     * @property {number|null} [workNum] User workNum
     * @property {number|null} [showPbPrivateFlag] User showPbPrivateFlag
     * @property {number|null} [totalAgreeNum] User totalAgreeNum
     * @property {ICreationData|null} [workcreationData] User workcreationData
     * @property {string|null} [tiebaUid] User tiebaUid
     * @property {string|null} [followFrom] User followFrom
     * @property {Array.<IBazhuSign>|null} [managerForum] User managerForum
     * @property {number|null} [displayAuthType] User displayAuthType
     * @property {IWorkCreatorInfo|null} [workCreatorInfo] User workCreatorInfo
     * @property {string|null} [levelName] User levelName
     * @property {IEditConfig|null} [editConfig] User editConfig
     * @property {string|null} [ipAddress] User ipAddress
     * @property {number|null} [isNicknameEditing] User isNicknameEditing
     * @property {string|null} [editingNickname] User editingNickname
     * @property {IVirtualImageInfo|null} [virtualImageInfo] User virtualImageInfo
     * @property {string|null} [displayIntro] User displayIntro
     * @property {IThemeTailInUser|null} [themeTail] User themeTail
     * @property {IShakeAdSwitch|null} [shakeAdSwitch] User shakeAdSwitch
     * @property {string|null} [iosBUrl] User iosBUrl
     * @property {number|Long|null} [pa] User pa
     * @property {number|null} [enableNewHomepage] User enableNewHomepage
     * @property {string|null} [targetScheme] User targetScheme
     */

    /**
     * Constructs a new User.
     * @exports User
     * @classdesc Represents a User.
     * @implements IUser
     * @constructor
     * @param {IUser=} [properties] Properties to set
     */
    function User(properties) {
        this.iconinfo = [];
        this.tshowIcon = [];
        this.userPics = [];
        this.likeForum = [];
        this.groupList = [];
        this.giftList = [];
        this.muteUser = [];
        this.newTshowIcon = [];
        this.profitList = [];
        this.forumToolAuth = [];
        this.managerForum = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * User isLogin.
     * @member {number} isLogin
     * @memberof User
     * @instance
     */
    User.prototype.isLogin = 0;

    /**
     * User id.
     * @member {number|Long} id
     * @memberof User
     * @instance
     */
    User.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * User name.
     * @member {string} name
     * @memberof User
     * @instance
     */
    User.prototype.name = "";

    /**
     * User nameShow.
     * @member {string} nameShow
     * @memberof User
     * @instance
     */
    User.prototype.nameShow = "";

    /**
     * User portrait.
     * @member {string} portrait
     * @memberof User
     * @instance
     */
    User.prototype.portrait = "";

    /**
     * User noUn.
     * @member {number} noUn
     * @memberof User
     * @instance
     */
    User.prototype.noUn = 0;

    /**
     * User type.
     * @member {number} type
     * @memberof User
     * @instance
     */
    User.prototype.type = 0;

    /**
     * User newUserInfo.
     * @member {INewUser|null|undefined} newUserInfo
     * @memberof User
     * @instance
     */
    User.prototype.newUserInfo = null;

    /**
     * User userhide.
     * @member {number} userhide
     * @memberof User
     * @instance
     */
    User.prototype.userhide = 0;

    /**
     * User balv.
     * @member {IBalv|null|undefined} balv
     * @memberof User
     * @instance
     */
    User.prototype.balv = null;

    /**
     * User isManager.
     * @member {number} isManager
     * @memberof User
     * @instance
     */
    User.prototype.isManager = 0;

    /**
     * User rank.
     * @member {string} rank
     * @memberof User
     * @instance
     */
    User.prototype.rank = "";

    /**
     * User bimgUrl.
     * @member {string} bimgUrl
     * @memberof User
     * @instance
     */
    User.prototype.bimgUrl = "";

    /**
     * User meizhiLevel.
     * @member {number} meizhiLevel
     * @memberof User
     * @instance
     */
    User.prototype.meizhiLevel = 0;

    /**
     * User isVerify.
     * @member {number} isVerify
     * @memberof User
     * @instance
     */
    User.prototype.isVerify = 0;

    /**
     * User isInterestman.
     * @member {number} isInterestman
     * @memberof User
     * @instance
     */
    User.prototype.isInterestman = 0;

    /**
     * User iconinfo.
     * @member {Array.<IIcon>} iconinfo
     * @memberof User
     * @instance
     */
    User.prototype.iconinfo = $util.emptyArray;

    /**
     * User tshowIcon.
     * @member {Array.<ITshowInfo>} tshowIcon
     * @memberof User
     * @instance
     */
    User.prototype.tshowIcon = $util.emptyArray;

    /**
     * User userType.
     * @member {number} userType
     * @memberof User
     * @instance
     */
    User.prototype.userType = 0;

    /**
     * User isCoreuser.
     * @member {number} isCoreuser
     * @memberof User
     * @instance
     */
    User.prototype.isCoreuser = 0;

    /**
     * User isHuinibuke.
     * @member {number} isHuinibuke
     * @memberof User
     * @instance
     */
    User.prototype.isHuinibuke = 0;

    /**
     * User iosBimgFormat.
     * @member {string} iosBimgFormat
     * @memberof User
     * @instance
     */
    User.prototype.iosBimgFormat = "";

    /**
     * User levelId.
     * @member {number} levelId
     * @memberof User
     * @instance
     */
    User.prototype.levelId = 0;

    /**
     * User isLike.
     * @member {number} isLike
     * @memberof User
     * @instance
     */
    User.prototype.isLike = 0;

    /**
     * User isBawu.
     * @member {number} isBawu
     * @memberof User
     * @instance
     */
    User.prototype.isBawu = 0;

    /**
     * User bawuType.
     * @member {string} bawuType
     * @memberof User
     * @instance
     */
    User.prototype.bawuType = "";

    /**
     * User portraith.
     * @member {string} portraith
     * @memberof User
     * @instance
     */
    User.prototype.portraith = "";

    /**
     * User ip.
     * @member {string} ip
     * @memberof User
     * @instance
     */
    User.prototype.ip = "";

    /**
     * User BDUSS.
     * @member {string} BDUSS
     * @memberof User
     * @instance
     */
    User.prototype.BDUSS = "";

    /**
     * User fansNum.
     * @member {number} fansNum
     * @memberof User
     * @instance
     */
    User.prototype.fansNum = 0;

    /**
     * User concernNum.
     * @member {number} concernNum
     * @memberof User
     * @instance
     */
    User.prototype.concernNum = 0;

    /**
     * User sex.
     * @member {number} sex
     * @memberof User
     * @instance
     */
    User.prototype.sex = 0;

    /**
     * User myLikeNum.
     * @member {number} myLikeNum
     * @memberof User
     * @instance
     */
    User.prototype.myLikeNum = 0;

    /**
     * User intro.
     * @member {string} intro
     * @memberof User
     * @instance
     */
    User.prototype.intro = "";

    /**
     * User hasConcerned.
     * @member {number} hasConcerned
     * @memberof User
     * @instance
     */
    User.prototype.hasConcerned = 0;

    /**
     * User passwd.
     * @member {string} passwd
     * @memberof User
     * @instance
     */
    User.prototype.passwd = "";

    /**
     * User postNum.
     * @member {number} postNum
     * @memberof User
     * @instance
     */
    User.prototype.postNum = 0;

    /**
     * User tbAge.
     * @member {string} tbAge
     * @memberof User
     * @instance
     */
    User.prototype.tbAge = "";

    /**
     * User isMem.
     * @member {number} isMem
     * @memberof User
     * @instance
     */
    User.prototype.isMem = 0;

    /**
     * User bimgEndTime.
     * @member {number} bimgEndTime
     * @memberof User
     * @instance
     */
    User.prototype.bimgEndTime = 0;

    /**
     * User payMemberInfo.
     * @member {IPayMemberInfo|null|undefined} payMemberInfo
     * @memberof User
     * @instance
     */
    User.prototype.payMemberInfo = null;

    /**
     * User gender.
     * @member {number} gender
     * @memberof User
     * @instance
     */
    User.prototype.gender = 0;

    /**
     * User isMask.
     * @member {number} isMask
     * @memberof User
     * @instance
     */
    User.prototype.isMask = 0;

    /**
     * User userPics.
     * @member {Array.<IUserPics>} userPics
     * @memberof User
     * @instance
     */
    User.prototype.userPics = $util.emptyArray;

    /**
     * User privSets.
     * @member {IPrivSets|null|undefined} privSets
     * @memberof User
     * @instance
     */
    User.prototype.privSets = null;

    /**
     * User isFriend.
     * @member {number} isFriend
     * @memberof User
     * @instance
     */
    User.prototype.isFriend = 0;

    /**
     * User likeForum.
     * @member {Array.<ILikeForumInfo>} likeForum
     * @memberof User
     * @instance
     */
    User.prototype.likeForum = $util.emptyArray;

    /**
     * User groupList.
     * @member {Array.<IMyGroupInfo>} groupList
     * @memberof User
     * @instance
     */
    User.prototype.groupList = $util.emptyArray;

    /**
     * User giftNum.
     * @member {number} giftNum
     * @memberof User
     * @instance
     */
    User.prototype.giftNum = 0;

    /**
     * User giftList.
     * @member {Array.<IGiftInfo>} giftList
     * @memberof User
     * @instance
     */
    User.prototype.giftList = $util.emptyArray;

    /**
     * User isSelectTail.
     * @member {number} isSelectTail
     * @memberof User
     * @instance
     */
    User.prototype.isSelectTail = 0;

    /**
     * User isGuanfang.
     * @member {number} isGuanfang
     * @memberof User
     * @instance
     */
    User.prototype.isGuanfang = 0;

    /**
     * User bookmarkCount.
     * @member {number} bookmarkCount
     * @memberof User
     * @instance
     */
    User.prototype.bookmarkCount = 0;

    /**
     * User bookmarkNewCount.
     * @member {number} bookmarkNewCount
     * @memberof User
     * @instance
     */
    User.prototype.bookmarkNewCount = 0;

    /**
     * User muteUser.
     * @member {Array.<ISimpleUser>} muteUser
     * @memberof User
     * @instance
     */
    User.prototype.muteUser = $util.emptyArray;

    /**
     * User friendNum.
     * @member {number|Long} friendNum
     * @memberof User
     * @instance
     */
    User.prototype.friendNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * User fansNickname.
     * @member {string} fansNickname
     * @memberof User
     * @instance
     */
    User.prototype.fansNickname = "";

    /**
     * User bgPic.
     * @member {string} bgPic
     * @memberof User
     * @instance
     */
    User.prototype.bgPic = "";

    /**
     * User parrScores.
     * @member {INewParrScores|null|undefined} parrScores
     * @memberof User
     * @instance
     */
    User.prototype.parrScores = null;

    /**
     * User novelFansInfo.
     * @member {INovelFansInfo|null|undefined} novelFansInfo
     * @memberof User
     * @instance
     */
    User.prototype.novelFansInfo = null;

    /**
     * User vipInfo.
     * @member {IUserVipInfo|null|undefined} vipInfo
     * @memberof User
     * @instance
     */
    User.prototype.vipInfo = null;

    /**
     * User godData.
     * @member {IGodInfo|null|undefined} godData
     * @memberof User
     * @instance
     */
    User.prototype.godData = null;

    /**
     * User heavyUser.
     * @member {number} heavyUser
     * @memberof User
     * @instance
     */
    User.prototype.heavyUser = 0;

    /**
     * User vipShowInfo.
     * @member {IVipShowInfo|null|undefined} vipShowInfo
     * @memberof User
     * @instance
     */
    User.prototype.vipShowInfo = null;

    /**
     * User newTshowIcon.
     * @member {Array.<ITshowInfo>} newTshowIcon
     * @memberof User
     * @instance
     */
    User.prototype.newTshowIcon = $util.emptyArray;

    /**
     * User twAnchorInfo.
     * @member {ITwZhiBoUser|null|undefined} twAnchorInfo
     * @memberof User
     * @instance
     */
    User.prototype.twAnchorInfo = null;

    /**
     * User profitList.
     * @member {Array.<ITwAnchorProfitItem>} profitList
     * @memberof User
     * @instance
     */
    User.prototype.profitList = $util.emptyArray;

    /**
     * User consumeInfo.
     * @member {IConsumeInfo|null|undefined} consumeInfo
     * @memberof User
     * @instance
     */
    User.prototype.consumeInfo = null;

    /**
     * User themeCard.
     * @member {IThemeCardInUser|null|undefined} themeCard
     * @memberof User
     * @instance
     */
    User.prototype.themeCard = null;

    /**
     * User vipCloseAd.
     * @member {IVipCloseAd|null|undefined} vipCloseAd
     * @memberof User
     * @instance
     */
    User.prototype.vipCloseAd = null;

    /**
     * User activitySponsor.
     * @member {IActivitySponsor|null|undefined} activitySponsor
     * @memberof User
     * @instance
     */
    User.prototype.activitySponsor = null;

    /**
     * User tbVip.
     * @member {ITbVipInfo|null|undefined} tbVip
     * @memberof User
     * @instance
     */
    User.prototype.tbVip = null;

    /**
     * User noPostHigh.
     * @member {number} noPostHigh
     * @memberof User
     * @instance
     */
    User.prototype.noPostHigh = 0;

    /**
     * User ecom.
     * @member {IEcom|null|undefined} ecom
     * @memberof User
     * @instance
     */
    User.prototype.ecom = null;

    /**
     * User visitorNum.
     * @member {number} visitorNum
     * @memberof User
     * @instance
     */
    User.prototype.visitorNum = 0;

    /**
     * User totalVisitorNum.
     * @member {number} totalVisitorNum
     * @memberof User
     * @instance
     */
    User.prototype.totalVisitorNum = 0;

    /**
     * User pendant.
     * @member {IPendant|null|undefined} pendant
     * @memberof User
     * @instance
     */
    User.prototype.pendant = null;

    /**
     * User alaInfo.
     * @member {IAlaUserInfo|null|undefined} alaInfo
     * @memberof User
     * @instance
     */
    User.prototype.alaInfo = null;

    /**
     * User sealPrefix.
     * @member {string} sealPrefix
     * @memberof User
     * @instance
     */
    User.prototype.sealPrefix = "";

    /**
     * User hasBottleEnter.
     * @member {number} hasBottleEnter
     * @memberof User
     * @instance
     */
    User.prototype.hasBottleEnter = 0;

    /**
     * User videoChannelInfo.
     * @member {IUserVideoChannelInfo|null|undefined} videoChannelInfo
     * @memberof User
     * @instance
     */
    User.prototype.videoChannelInfo = null;

    /**
     * User springVirtualUser.
     * @member {ISpringVirtualUser|null|undefined} springVirtualUser
     * @memberof User
     * @instance
     */
    User.prototype.springVirtualUser = null;

    /**
     * User eachOtherFriend.
     * @member {number} eachOtherFriend
     * @memberof User
     * @instance
     */
    User.prototype.eachOtherFriend = 0;

    /**
     * User esportData.
     * @member {IEsportInfo|null|undefined} esportData
     * @memberof User
     * @instance
     */
    User.prototype.esportData = null;

    /**
     * User alaLiveInfo.
     * @member {IAlaLiveInfo|null|undefined} alaLiveInfo
     * @memberof User
     * @instance
     */
    User.prototype.alaLiveInfo = null;

    /**
     * User nicknameUpdateTime.
     * @member {number} nicknameUpdateTime
     * @memberof User
     * @instance
     */
    User.prototype.nicknameUpdateTime = 0;

    /**
     * User threadNum.
     * @member {number} threadNum
     * @memberof User
     * @instance
     */
    User.prototype.threadNum = 0;

    /**
     * User agreeNum.
     * @member {number} agreeNum
     * @memberof User
     * @instance
     */
    User.prototype.agreeNum = 0;

    /**
     * User leftCallNum.
     * @member {number} leftCallNum
     * @memberof User
     * @instance
     */
    User.prototype.leftCallNum = 0;

    /**
     * User isInvited.
     * @member {number} isInvited
     * @memberof User
     * @instance
     */
    User.prototype.isInvited = 0;

    /**
     * User isFans.
     * @member {number} isFans
     * @memberof User
     * @instance
     */
    User.prototype.isFans = 0;

    /**
     * User privThread.
     * @member {number} privThread
     * @memberof User
     * @instance
     */
    User.prototype.privThread = 0;

    /**
     * User isVideobiggie.
     * @member {number} isVideobiggie
     * @memberof User
     * @instance
     */
    User.prototype.isVideobiggie = 0;

    /**
     * User isShowRedpacket.
     * @member {number} isShowRedpacket
     * @memberof User
     * @instance
     */
    User.prototype.isShowRedpacket = 0;

    /**
     * User baijiahaoInfo.
     * @member {IBaijiahaoInfo|null|undefined} baijiahaoInfo
     * @memberof User
     * @instance
     */
    User.prototype.baijiahaoInfo = null;

    /**
     * User birthdayInfo.
     * @member {IBirthdayInfo|null|undefined} birthdayInfo
     * @memberof User
     * @instance
     */
    User.prototype.birthdayInfo = null;

    /**
     * User canModifyAvatar.
     * @member {number} canModifyAvatar
     * @memberof User
     * @instance
     */
    User.prototype.canModifyAvatar = 0;

    /**
     * User modifyAvatarDesc.
     * @member {string} modifyAvatarDesc
     * @memberof User
     * @instance
     */
    User.prototype.modifyAvatarDesc = "";

    /**
     * User influence.
     * @member {number} influence
     * @memberof User
     * @instance
     */
    User.prototype.influence = 0;

    /**
     * User levelInfluence.
     * @member {string} levelInfluence
     * @memberof User
     * @instance
     */
    User.prototype.levelInfluence = "";

    /**
     * User newGodData.
     * @member {INewGodInfo|null|undefined} newGodData
     * @memberof User
     * @instance
     */
    User.prototype.newGodData = null;

    /**
     * User bawuThrones.
     * @member {IBawuThrones|null|undefined} bawuThrones
     * @memberof User
     * @instance
     */
    User.prototype.bawuThrones = null;

    /**
     * User callFansInfo.
     * @member {ICallFansInfo|null|undefined} callFansInfo
     * @memberof User
     * @instance
     */
    User.prototype.callFansInfo = null;

    /**
     * User bazhuGrade.
     * @member {IBazhuSign|null|undefined} bazhuGrade
     * @memberof User
     * @instance
     */
    User.prototype.bazhuGrade = null;

    /**
     * User isDefaultAvatar.
     * @member {number} isDefaultAvatar
     * @memberof User
     * @instance
     */
    User.prototype.isDefaultAvatar = 0;

    /**
     * User uk.
     * @member {string} uk
     * @memberof User
     * @instance
     */
    User.prototype.uk = "";

    /**
     * User creationData.
     * @member {ICreationData|null|undefined} creationData
     * @memberof User
     * @instance
     */
    User.prototype.creationData = null;

    /**
     * User favoriteNum.
     * @member {number} favoriteNum
     * @memberof User
     * @instance
     */
    User.prototype.favoriteNum = 0;

    /**
     * User liveRoomInfo.
     * @member {ILiveRoomInfo|null|undefined} liveRoomInfo
     * @memberof User
     * @instance
     */
    User.prototype.liveRoomInfo = null;

    /**
     * User businessAccountInfo.
     * @member {IBusinessAccountInfo|null|undefined} businessAccountInfo
     * @memberof User
     * @instance
     */
    User.prototype.businessAccountInfo = null;

    /**
     * User appealThreadPopover.
     * @member {string} appealThreadPopover
     * @memberof User
     * @instance
     */
    User.prototype.appealThreadPopover = "";

    /**
     * User forumToolAuth.
     * @member {Array.<IForumToolPerm>} forumToolAuth
     * @memberof User
     * @instance
     */
    User.prototype.forumToolAuth = $util.emptyArray;

    /**
     * User workNum.
     * @member {number} workNum
     * @memberof User
     * @instance
     */
    User.prototype.workNum = 0;

    /**
     * User showPbPrivateFlag.
     * @member {number} showPbPrivateFlag
     * @memberof User
     * @instance
     */
    User.prototype.showPbPrivateFlag = 0;

    /**
     * User totalAgreeNum.
     * @member {number} totalAgreeNum
     * @memberof User
     * @instance
     */
    User.prototype.totalAgreeNum = 0;

    /**
     * User workcreationData.
     * @member {ICreationData|null|undefined} workcreationData
     * @memberof User
     * @instance
     */
    User.prototype.workcreationData = null;

    /**
     * User tiebaUid.
     * @member {string} tiebaUid
     * @memberof User
     * @instance
     */
    User.prototype.tiebaUid = "";

    /**
     * User followFrom.
     * @member {string} followFrom
     * @memberof User
     * @instance
     */
    User.prototype.followFrom = "";

    /**
     * User managerForum.
     * @member {Array.<IBazhuSign>} managerForum
     * @memberof User
     * @instance
     */
    User.prototype.managerForum = $util.emptyArray;

    /**
     * User displayAuthType.
     * @member {number} displayAuthType
     * @memberof User
     * @instance
     */
    User.prototype.displayAuthType = 0;

    /**
     * User workCreatorInfo.
     * @member {IWorkCreatorInfo|null|undefined} workCreatorInfo
     * @memberof User
     * @instance
     */
    User.prototype.workCreatorInfo = null;

    /**
     * User levelName.
     * @member {string} levelName
     * @memberof User
     * @instance
     */
    User.prototype.levelName = "";

    /**
     * User editConfig.
     * @member {IEditConfig|null|undefined} editConfig
     * @memberof User
     * @instance
     */
    User.prototype.editConfig = null;

    /**
     * User ipAddress.
     * @member {string} ipAddress
     * @memberof User
     * @instance
     */
    User.prototype.ipAddress = "";

    /**
     * User isNicknameEditing.
     * @member {number} isNicknameEditing
     * @memberof User
     * @instance
     */
    User.prototype.isNicknameEditing = 0;

    /**
     * User editingNickname.
     * @member {string} editingNickname
     * @memberof User
     * @instance
     */
    User.prototype.editingNickname = "";

    /**
     * User virtualImageInfo.
     * @member {IVirtualImageInfo|null|undefined} virtualImageInfo
     * @memberof User
     * @instance
     */
    User.prototype.virtualImageInfo = null;

    /**
     * User displayIntro.
     * @member {string} displayIntro
     * @memberof User
     * @instance
     */
    User.prototype.displayIntro = "";

    /**
     * User themeTail.
     * @member {IThemeTailInUser|null|undefined} themeTail
     * @memberof User
     * @instance
     */
    User.prototype.themeTail = null;

    /**
     * User shakeAdSwitch.
     * @member {IShakeAdSwitch|null|undefined} shakeAdSwitch
     * @memberof User
     * @instance
     */
    User.prototype.shakeAdSwitch = null;

    /**
     * User iosBUrl.
     * @member {string} iosBUrl
     * @memberof User
     * @instance
     */
    User.prototype.iosBUrl = "";

    /**
     * User pa.
     * @member {number|Long} pa
     * @memberof User
     * @instance
     */
    User.prototype.pa = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * User enableNewHomepage.
     * @member {number} enableNewHomepage
     * @memberof User
     * @instance
     */
    User.prototype.enableNewHomepage = 0;

    /**
     * User targetScheme.
     * @member {string} targetScheme
     * @memberof User
     * @instance
     */
    User.prototype.targetScheme = "";

    /**
     * Creates a new User instance using the specified properties.
     * @function create
     * @memberof User
     * @static
     * @param {IUser=} [properties] Properties to set
     * @returns {User} User instance
     */
    User.create = function create(properties) {
        return new User(properties);
    };

    /**
     * Encodes the specified User message. Does not implicitly {@link User.verify|verify} messages.
     * @function encode
     * @memberof User
     * @static
     * @param {IUser} message User message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    User.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isLogin != null && Object.hasOwnProperty.call(message, "isLogin"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isLogin);
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
        if (message.nameShow != null && Object.hasOwnProperty.call(message, "nameShow"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.nameShow);
        if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.portrait);
        if (message.noUn != null && Object.hasOwnProperty.call(message, "noUn"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.noUn);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
        if (message.newUserInfo != null && Object.hasOwnProperty.call(message, "newUserInfo"))
            $root.NewUser.encode(message.newUserInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.userhide != null && Object.hasOwnProperty.call(message, "userhide"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.userhide);
        if (message.balv != null && Object.hasOwnProperty.call(message, "balv"))
            $root.Balv.encode(message.balv, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.isManager != null && Object.hasOwnProperty.call(message, "isManager"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.isManager);
        if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.rank);
        if (message.bimgUrl != null && Object.hasOwnProperty.call(message, "bimgUrl"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.bimgUrl);
        if (message.meizhiLevel != null && Object.hasOwnProperty.call(message, "meizhiLevel"))
            writer.uint32(/* id 14, wireType 0 =*/112).int32(message.meizhiLevel);
        if (message.isVerify != null && Object.hasOwnProperty.call(message, "isVerify"))
            writer.uint32(/* id 15, wireType 0 =*/120).int32(message.isVerify);
        if (message.isInterestman != null && Object.hasOwnProperty.call(message, "isInterestman"))
            writer.uint32(/* id 16, wireType 0 =*/128).int32(message.isInterestman);
        if (message.iconinfo != null && message.iconinfo.length)
            for (let i = 0; i < message.iconinfo.length; ++i)
                $root.Icon.encode(message.iconinfo[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.tshowIcon != null && message.tshowIcon.length)
            for (let i = 0; i < message.tshowIcon.length; ++i)
                $root.TshowInfo.encode(message.tshowIcon[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.userType != null && Object.hasOwnProperty.call(message, "userType"))
            writer.uint32(/* id 19, wireType 0 =*/152).int32(message.userType);
        if (message.isCoreuser != null && Object.hasOwnProperty.call(message, "isCoreuser"))
            writer.uint32(/* id 20, wireType 0 =*/160).int32(message.isCoreuser);
        if (message.isHuinibuke != null && Object.hasOwnProperty.call(message, "isHuinibuke"))
            writer.uint32(/* id 21, wireType 0 =*/168).int32(message.isHuinibuke);
        if (message.iosBimgFormat != null && Object.hasOwnProperty.call(message, "iosBimgFormat"))
            writer.uint32(/* id 22, wireType 2 =*/178).string(message.iosBimgFormat);
        if (message.levelId != null && Object.hasOwnProperty.call(message, "levelId"))
            writer.uint32(/* id 23, wireType 0 =*/184).int32(message.levelId);
        if (message.isLike != null && Object.hasOwnProperty.call(message, "isLike"))
            writer.uint32(/* id 24, wireType 0 =*/192).int32(message.isLike);
        if (message.isBawu != null && Object.hasOwnProperty.call(message, "isBawu"))
            writer.uint32(/* id 25, wireType 0 =*/200).int32(message.isBawu);
        if (message.bawuType != null && Object.hasOwnProperty.call(message, "bawuType"))
            writer.uint32(/* id 26, wireType 2 =*/210).string(message.bawuType);
        if (message.portraith != null && Object.hasOwnProperty.call(message, "portraith"))
            writer.uint32(/* id 27, wireType 2 =*/218).string(message.portraith);
        if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
            writer.uint32(/* id 28, wireType 2 =*/226).string(message.ip);
        if (message.BDUSS != null && Object.hasOwnProperty.call(message, "BDUSS"))
            writer.uint32(/* id 29, wireType 2 =*/234).string(message.BDUSS);
        if (message.fansNum != null && Object.hasOwnProperty.call(message, "fansNum"))
            writer.uint32(/* id 30, wireType 0 =*/240).int32(message.fansNum);
        if (message.concernNum != null && Object.hasOwnProperty.call(message, "concernNum"))
            writer.uint32(/* id 31, wireType 0 =*/248).int32(message.concernNum);
        if (message.sex != null && Object.hasOwnProperty.call(message, "sex"))
            writer.uint32(/* id 32, wireType 0 =*/256).int32(message.sex);
        if (message.myLikeNum != null && Object.hasOwnProperty.call(message, "myLikeNum"))
            writer.uint32(/* id 33, wireType 0 =*/264).int32(message.myLikeNum);
        if (message.intro != null && Object.hasOwnProperty.call(message, "intro"))
            writer.uint32(/* id 34, wireType 2 =*/274).string(message.intro);
        if (message.hasConcerned != null && Object.hasOwnProperty.call(message, "hasConcerned"))
            writer.uint32(/* id 35, wireType 0 =*/280).int32(message.hasConcerned);
        if (message.passwd != null && Object.hasOwnProperty.call(message, "passwd"))
            writer.uint32(/* id 36, wireType 2 =*/290).string(message.passwd);
        if (message.postNum != null && Object.hasOwnProperty.call(message, "postNum"))
            writer.uint32(/* id 37, wireType 0 =*/296).int32(message.postNum);
        if (message.tbAge != null && Object.hasOwnProperty.call(message, "tbAge"))
            writer.uint32(/* id 38, wireType 2 =*/306).string(message.tbAge);
        if (message.isMem != null && Object.hasOwnProperty.call(message, "isMem"))
            writer.uint32(/* id 39, wireType 0 =*/312).int32(message.isMem);
        if (message.bimgEndTime != null && Object.hasOwnProperty.call(message, "bimgEndTime"))
            writer.uint32(/* id 40, wireType 0 =*/320).int32(message.bimgEndTime);
        if (message.payMemberInfo != null && Object.hasOwnProperty.call(message, "payMemberInfo"))
            $root.PayMemberInfo.encode(message.payMemberInfo, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
        if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
            writer.uint32(/* id 42, wireType 0 =*/336).int32(message.gender);
        if (message.isMask != null && Object.hasOwnProperty.call(message, "isMask"))
            writer.uint32(/* id 43, wireType 0 =*/344).int32(message.isMask);
        if (message.userPics != null && message.userPics.length)
            for (let i = 0; i < message.userPics.length; ++i)
                $root.UserPics.encode(message.userPics[i], writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
        if (message.privSets != null && Object.hasOwnProperty.call(message, "privSets"))
            $root.PrivSets.encode(message.privSets, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
        if (message.isFriend != null && Object.hasOwnProperty.call(message, "isFriend"))
            writer.uint32(/* id 46, wireType 0 =*/368).int32(message.isFriend);
        if (message.likeForum != null && message.likeForum.length)
            for (let i = 0; i < message.likeForum.length; ++i)
                $root.LikeForumInfo.encode(message.likeForum[i], writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
        if (message.groupList != null && message.groupList.length)
            for (let i = 0; i < message.groupList.length; ++i)
                $root.MyGroupInfo.encode(message.groupList[i], writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
        if (message.giftNum != null && Object.hasOwnProperty.call(message, "giftNum"))
            writer.uint32(/* id 49, wireType 0 =*/392).int32(message.giftNum);
        if (message.giftList != null && message.giftList.length)
            for (let i = 0; i < message.giftList.length; ++i)
                $root.GiftInfo.encode(message.giftList[i], writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
        if (message.isSelectTail != null && Object.hasOwnProperty.call(message, "isSelectTail"))
            writer.uint32(/* id 51, wireType 0 =*/408).int32(message.isSelectTail);
        if (message.isGuanfang != null && Object.hasOwnProperty.call(message, "isGuanfang"))
            writer.uint32(/* id 52, wireType 0 =*/416).int32(message.isGuanfang);
        if (message.bookmarkCount != null && Object.hasOwnProperty.call(message, "bookmarkCount"))
            writer.uint32(/* id 53, wireType 0 =*/424).int32(message.bookmarkCount);
        if (message.bookmarkNewCount != null && Object.hasOwnProperty.call(message, "bookmarkNewCount"))
            writer.uint32(/* id 54, wireType 0 =*/432).int32(message.bookmarkNewCount);
        if (message.muteUser != null && message.muteUser.length)
            for (let i = 0; i < message.muteUser.length; ++i)
                $root.SimpleUser.encode(message.muteUser[i], writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
        if (message.friendNum != null && Object.hasOwnProperty.call(message, "friendNum"))
            writer.uint32(/* id 56, wireType 0 =*/448).int64(message.friendNum);
        if (message.fansNickname != null && Object.hasOwnProperty.call(message, "fansNickname"))
            writer.uint32(/* id 57, wireType 2 =*/458).string(message.fansNickname);
        if (message.bgPic != null && Object.hasOwnProperty.call(message, "bgPic"))
            writer.uint32(/* id 58, wireType 2 =*/466).string(message.bgPic);
        if (message.parrScores != null && Object.hasOwnProperty.call(message, "parrScores"))
            $root.NewParrScores.encode(message.parrScores, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
        if (message.novelFansInfo != null && Object.hasOwnProperty.call(message, "novelFansInfo"))
            $root.NovelFansInfo.encode(message.novelFansInfo, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
        if (message.vipInfo != null && Object.hasOwnProperty.call(message, "vipInfo"))
            $root.UserVipInfo.encode(message.vipInfo, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
        if (message.godData != null && Object.hasOwnProperty.call(message, "godData"))
            $root.GodInfo.encode(message.godData, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
        if (message.heavyUser != null && Object.hasOwnProperty.call(message, "heavyUser"))
            writer.uint32(/* id 63, wireType 0 =*/504).int32(message.heavyUser);
        if (message.vipShowInfo != null && Object.hasOwnProperty.call(message, "vipShowInfo"))
            $root.VipShowInfo.encode(message.vipShowInfo, writer.uint32(/* id 64, wireType 2 =*/514).fork()).ldelim();
        if (message.newTshowIcon != null && message.newTshowIcon.length)
            for (let i = 0; i < message.newTshowIcon.length; ++i)
                $root.TshowInfo.encode(message.newTshowIcon[i], writer.uint32(/* id 65, wireType 2 =*/522).fork()).ldelim();
        if (message.twAnchorInfo != null && Object.hasOwnProperty.call(message, "twAnchorInfo"))
            $root.TwZhiBoUser.encode(message.twAnchorInfo, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
        if (message.profitList != null && message.profitList.length)
            for (let i = 0; i < message.profitList.length; ++i)
                $root.TwAnchorProfitItem.encode(message.profitList[i], writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
        if (message.consumeInfo != null && Object.hasOwnProperty.call(message, "consumeInfo"))
            $root.ConsumeInfo.encode(message.consumeInfo, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
        if (message.themeCard != null && Object.hasOwnProperty.call(message, "themeCard"))
            $root.ThemeCardInUser.encode(message.themeCard, writer.uint32(/* id 69, wireType 2 =*/554).fork()).ldelim();
        if (message.vipCloseAd != null && Object.hasOwnProperty.call(message, "vipCloseAd"))
            $root.VipCloseAd.encode(message.vipCloseAd, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
        if (message.activitySponsor != null && Object.hasOwnProperty.call(message, "activitySponsor"))
            $root.ActivitySponsor.encode(message.activitySponsor, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
        if (message.tbVip != null && Object.hasOwnProperty.call(message, "tbVip"))
            $root.TbVipInfo.encode(message.tbVip, writer.uint32(/* id 72, wireType 2 =*/578).fork()).ldelim();
        if (message.noPostHigh != null && Object.hasOwnProperty.call(message, "noPostHigh"))
            writer.uint32(/* id 73, wireType 0 =*/584).uint32(message.noPostHigh);
        if (message.ecom != null && Object.hasOwnProperty.call(message, "ecom"))
            $root.Ecom.encode(message.ecom, writer.uint32(/* id 74, wireType 2 =*/594).fork()).ldelim();
        if (message.visitorNum != null && Object.hasOwnProperty.call(message, "visitorNum"))
            writer.uint32(/* id 75, wireType 0 =*/600).int32(message.visitorNum);
        if (message.totalVisitorNum != null && Object.hasOwnProperty.call(message, "totalVisitorNum"))
            writer.uint32(/* id 76, wireType 0 =*/608).int32(message.totalVisitorNum);
        if (message.pendant != null && Object.hasOwnProperty.call(message, "pendant"))
            $root.Pendant.encode(message.pendant, writer.uint32(/* id 77, wireType 2 =*/618).fork()).ldelim();
        if (message.alaInfo != null && Object.hasOwnProperty.call(message, "alaInfo"))
            $root.AlaUserInfo.encode(message.alaInfo, writer.uint32(/* id 78, wireType 2 =*/626).fork()).ldelim();
        if (message.sealPrefix != null && Object.hasOwnProperty.call(message, "sealPrefix"))
            writer.uint32(/* id 79, wireType 2 =*/634).string(message.sealPrefix);
        if (message.hasBottleEnter != null && Object.hasOwnProperty.call(message, "hasBottleEnter"))
            writer.uint32(/* id 80, wireType 0 =*/640).int32(message.hasBottleEnter);
        if (message.videoChannelInfo != null && Object.hasOwnProperty.call(message, "videoChannelInfo"))
            $root.UserVideoChannelInfo.encode(message.videoChannelInfo, writer.uint32(/* id 81, wireType 2 =*/650).fork()).ldelim();
        if (message.springVirtualUser != null && Object.hasOwnProperty.call(message, "springVirtualUser"))
            $root.SpringVirtualUser.encode(message.springVirtualUser, writer.uint32(/* id 82, wireType 2 =*/658).fork()).ldelim();
        if (message.eachOtherFriend != null && Object.hasOwnProperty.call(message, "eachOtherFriend"))
            writer.uint32(/* id 83, wireType 0 =*/664).int32(message.eachOtherFriend);
        if (message.esportData != null && Object.hasOwnProperty.call(message, "esportData"))
            $root.EsportInfo.encode(message.esportData, writer.uint32(/* id 84, wireType 2 =*/674).fork()).ldelim();
        if (message.alaLiveInfo != null && Object.hasOwnProperty.call(message, "alaLiveInfo"))
            $root.AlaLiveInfo.encode(message.alaLiveInfo, writer.uint32(/* id 85, wireType 2 =*/682).fork()).ldelim();
        if (message.nicknameUpdateTime != null && Object.hasOwnProperty.call(message, "nicknameUpdateTime"))
            writer.uint32(/* id 86, wireType 0 =*/688).int32(message.nicknameUpdateTime);
        if (message.threadNum != null && Object.hasOwnProperty.call(message, "threadNum"))
            writer.uint32(/* id 87, wireType 0 =*/696).int32(message.threadNum);
        if (message.agreeNum != null && Object.hasOwnProperty.call(message, "agreeNum"))
            writer.uint32(/* id 88, wireType 0 =*/704).int32(message.agreeNum);
        if (message.leftCallNum != null && Object.hasOwnProperty.call(message, "leftCallNum"))
            writer.uint32(/* id 89, wireType 0 =*/712).int32(message.leftCallNum);
        if (message.isInvited != null && Object.hasOwnProperty.call(message, "isInvited"))
            writer.uint32(/* id 90, wireType 0 =*/720).int32(message.isInvited);
        if (message.isFans != null && Object.hasOwnProperty.call(message, "isFans"))
            writer.uint32(/* id 91, wireType 0 =*/728).int32(message.isFans);
        if (message.privThread != null && Object.hasOwnProperty.call(message, "privThread"))
            writer.uint32(/* id 92, wireType 0 =*/736).int32(message.privThread);
        if (message.isVideobiggie != null && Object.hasOwnProperty.call(message, "isVideobiggie"))
            writer.uint32(/* id 93, wireType 0 =*/744).int32(message.isVideobiggie);
        if (message.isShowRedpacket != null && Object.hasOwnProperty.call(message, "isShowRedpacket"))
            writer.uint32(/* id 94, wireType 0 =*/752).int32(message.isShowRedpacket);
        if (message.baijiahaoInfo != null && Object.hasOwnProperty.call(message, "baijiahaoInfo"))
            $root.BaijiahaoInfo.encode(message.baijiahaoInfo, writer.uint32(/* id 95, wireType 2 =*/762).fork()).ldelim();
        if (message.birthdayInfo != null && Object.hasOwnProperty.call(message, "birthdayInfo"))
            $root.BirthdayInfo.encode(message.birthdayInfo, writer.uint32(/* id 96, wireType 2 =*/770).fork()).ldelim();
        if (message.canModifyAvatar != null && Object.hasOwnProperty.call(message, "canModifyAvatar"))
            writer.uint32(/* id 97, wireType 0 =*/776).int32(message.canModifyAvatar);
        if (message.modifyAvatarDesc != null && Object.hasOwnProperty.call(message, "modifyAvatarDesc"))
            writer.uint32(/* id 98, wireType 2 =*/786).string(message.modifyAvatarDesc);
        if (message.influence != null && Object.hasOwnProperty.call(message, "influence"))
            writer.uint32(/* id 99, wireType 0 =*/792).int32(message.influence);
        if (message.levelInfluence != null && Object.hasOwnProperty.call(message, "levelInfluence"))
            writer.uint32(/* id 100, wireType 2 =*/802).string(message.levelInfluence);
        if (message.newGodData != null && Object.hasOwnProperty.call(message, "newGodData"))
            $root.NewGodInfo.encode(message.newGodData, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
        if (message.bawuThrones != null && Object.hasOwnProperty.call(message, "bawuThrones"))
            $root.BawuThrones.encode(message.bawuThrones, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
        if (message.callFansInfo != null && Object.hasOwnProperty.call(message, "callFansInfo"))
            $root.CallFansInfo.encode(message.callFansInfo, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
        if (message.bazhuGrade != null && Object.hasOwnProperty.call(message, "bazhuGrade"))
            $root.BazhuSign.encode(message.bazhuGrade, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
        if (message.isDefaultAvatar != null && Object.hasOwnProperty.call(message, "isDefaultAvatar"))
            writer.uint32(/* id 106, wireType 0 =*/848).int32(message.isDefaultAvatar);
        if (message.uk != null && Object.hasOwnProperty.call(message, "uk"))
            writer.uint32(/* id 107, wireType 2 =*/858).string(message.uk);
        if (message.creationData != null && Object.hasOwnProperty.call(message, "creationData"))
            $root.CreationData.encode(message.creationData, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
        if (message.favoriteNum != null && Object.hasOwnProperty.call(message, "favoriteNum"))
            writer.uint32(/* id 109, wireType 0 =*/872).int32(message.favoriteNum);
        if (message.liveRoomInfo != null && Object.hasOwnProperty.call(message, "liveRoomInfo"))
            $root.LiveRoomInfo.encode(message.liveRoomInfo, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
        if (message.businessAccountInfo != null && Object.hasOwnProperty.call(message, "businessAccountInfo"))
            $root.BusinessAccountInfo.encode(message.businessAccountInfo, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
        if (message.appealThreadPopover != null && Object.hasOwnProperty.call(message, "appealThreadPopover"))
            writer.uint32(/* id 112, wireType 2 =*/898).string(message.appealThreadPopover);
        if (message.forumToolAuth != null && message.forumToolAuth.length)
            for (let i = 0; i < message.forumToolAuth.length; ++i)
                $root.ForumToolPerm.encode(message.forumToolAuth[i], writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
        if (message.workNum != null && Object.hasOwnProperty.call(message, "workNum"))
            writer.uint32(/* id 116, wireType 0 =*/928).uint32(message.workNum);
        if (message.showPbPrivateFlag != null && Object.hasOwnProperty.call(message, "showPbPrivateFlag"))
            writer.uint32(/* id 117, wireType 0 =*/936).int32(message.showPbPrivateFlag);
        if (message.totalAgreeNum != null && Object.hasOwnProperty.call(message, "totalAgreeNum"))
            writer.uint32(/* id 118, wireType 0 =*/944).uint32(message.totalAgreeNum);
        if (message.workcreationData != null && Object.hasOwnProperty.call(message, "workcreationData"))
            $root.CreationData.encode(message.workcreationData, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
        if (message.tiebaUid != null && Object.hasOwnProperty.call(message, "tiebaUid"))
            writer.uint32(/* id 120, wireType 2 =*/962).string(message.tiebaUid);
        if (message.followFrom != null && Object.hasOwnProperty.call(message, "followFrom"))
            writer.uint32(/* id 121, wireType 2 =*/970).string(message.followFrom);
        if (message.managerForum != null && message.managerForum.length)
            for (let i = 0; i < message.managerForum.length; ++i)
                $root.BazhuSign.encode(message.managerForum[i], writer.uint32(/* id 122, wireType 2 =*/978).fork()).ldelim();
        if (message.displayAuthType != null && Object.hasOwnProperty.call(message, "displayAuthType"))
            writer.uint32(/* id 123, wireType 0 =*/984).int32(message.displayAuthType);
        if (message.workCreatorInfo != null && Object.hasOwnProperty.call(message, "workCreatorInfo"))
            $root.WorkCreatorInfo.encode(message.workCreatorInfo, writer.uint32(/* id 124, wireType 2 =*/994).fork()).ldelim();
        if (message.levelName != null && Object.hasOwnProperty.call(message, "levelName"))
            writer.uint32(/* id 125, wireType 2 =*/1002).string(message.levelName);
        if (message.editConfig != null && Object.hasOwnProperty.call(message, "editConfig"))
            $root.EditConfig.encode(message.editConfig, writer.uint32(/* id 126, wireType 2 =*/1010).fork()).ldelim();
        if (message.ipAddress != null && Object.hasOwnProperty.call(message, "ipAddress"))
            writer.uint32(/* id 127, wireType 2 =*/1018).string(message.ipAddress);
        if (message.isNicknameEditing != null && Object.hasOwnProperty.call(message, "isNicknameEditing"))
            writer.uint32(/* id 128, wireType 0 =*/1024).int32(message.isNicknameEditing);
        if (message.editingNickname != null && Object.hasOwnProperty.call(message, "editingNickname"))
            writer.uint32(/* id 129, wireType 2 =*/1034).string(message.editingNickname);
        if (message.virtualImageInfo != null && Object.hasOwnProperty.call(message, "virtualImageInfo"))
            $root.VirtualImageInfo.encode(message.virtualImageInfo, writer.uint32(/* id 136, wireType 2 =*/1090).fork()).ldelim();
        if (message.displayIntro != null && Object.hasOwnProperty.call(message, "displayIntro"))
            writer.uint32(/* id 138, wireType 2 =*/1106).string(message.displayIntro);
        if (message.themeTail != null && Object.hasOwnProperty.call(message, "themeTail"))
            $root.ThemeTailInUser.encode(message.themeTail, writer.uint32(/* id 141, wireType 2 =*/1130).fork()).ldelim();
        if (message.shakeAdSwitch != null && Object.hasOwnProperty.call(message, "shakeAdSwitch"))
            $root.ShakeAdSwitch.encode(message.shakeAdSwitch, writer.uint32(/* id 145, wireType 2 =*/1162).fork()).ldelim();
        if (message.iosBUrl != null && Object.hasOwnProperty.call(message, "iosBUrl"))
            writer.uint32(/* id 147, wireType 2 =*/1178).string(message.iosBUrl);
        if (message.pa != null && Object.hasOwnProperty.call(message, "pa"))
            writer.uint32(/* id 148, wireType 0 =*/1184).int64(message.pa);
        if (message.enableNewHomepage != null && Object.hasOwnProperty.call(message, "enableNewHomepage"))
            writer.uint32(/* id 149, wireType 0 =*/1192).int32(message.enableNewHomepage);
        if (message.targetScheme != null && Object.hasOwnProperty.call(message, "targetScheme"))
            writer.uint32(/* id 150, wireType 2 =*/1202).string(message.targetScheme);
        return writer;
    };

    /**
     * Encodes the specified User message, length delimited. Does not implicitly {@link User.verify|verify} messages.
     * @function encodeDelimited
     * @memberof User
     * @static
     * @param {IUser} message User message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    User.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a User message from the specified reader or buffer.
     * @function decode
     * @memberof User
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {User} User
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    User.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.User();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isLogin = reader.int32();
                    break;
                }
            case 2: {
                    message.id = reader.int64();
                    break;
                }
            case 3: {
                    message.name = reader.string();
                    break;
                }
            case 4: {
                    message.nameShow = reader.string();
                    break;
                }
            case 5: {
                    message.portrait = reader.string();
                    break;
                }
            case 6: {
                    message.noUn = reader.int32();
                    break;
                }
            case 7: {
                    message.type = reader.int32();
                    break;
                }
            case 8: {
                    message.newUserInfo = $root.NewUser.decode(reader, reader.uint32());
                    break;
                }
            case 9: {
                    message.userhide = reader.int32();
                    break;
                }
            case 10: {
                    message.balv = $root.Balv.decode(reader, reader.uint32());
                    break;
                }
            case 11: {
                    message.isManager = reader.int32();
                    break;
                }
            case 12: {
                    message.rank = reader.string();
                    break;
                }
            case 13: {
                    message.bimgUrl = reader.string();
                    break;
                }
            case 14: {
                    message.meizhiLevel = reader.int32();
                    break;
                }
            case 15: {
                    message.isVerify = reader.int32();
                    break;
                }
            case 16: {
                    message.isInterestman = reader.int32();
                    break;
                }
            case 17: {
                    if (!(message.iconinfo && message.iconinfo.length))
                        message.iconinfo = [];
                    message.iconinfo.push($root.Icon.decode(reader, reader.uint32()));
                    break;
                }
            case 18: {
                    if (!(message.tshowIcon && message.tshowIcon.length))
                        message.tshowIcon = [];
                    message.tshowIcon.push($root.TshowInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 19: {
                    message.userType = reader.int32();
                    break;
                }
            case 20: {
                    message.isCoreuser = reader.int32();
                    break;
                }
            case 21: {
                    message.isHuinibuke = reader.int32();
                    break;
                }
            case 22: {
                    message.iosBimgFormat = reader.string();
                    break;
                }
            case 23: {
                    message.levelId = reader.int32();
                    break;
                }
            case 24: {
                    message.isLike = reader.int32();
                    break;
                }
            case 25: {
                    message.isBawu = reader.int32();
                    break;
                }
            case 26: {
                    message.bawuType = reader.string();
                    break;
                }
            case 27: {
                    message.portraith = reader.string();
                    break;
                }
            case 28: {
                    message.ip = reader.string();
                    break;
                }
            case 29: {
                    message.BDUSS = reader.string();
                    break;
                }
            case 30: {
                    message.fansNum = reader.int32();
                    break;
                }
            case 31: {
                    message.concernNum = reader.int32();
                    break;
                }
            case 32: {
                    message.sex = reader.int32();
                    break;
                }
            case 33: {
                    message.myLikeNum = reader.int32();
                    break;
                }
            case 34: {
                    message.intro = reader.string();
                    break;
                }
            case 35: {
                    message.hasConcerned = reader.int32();
                    break;
                }
            case 36: {
                    message.passwd = reader.string();
                    break;
                }
            case 37: {
                    message.postNum = reader.int32();
                    break;
                }
            case 38: {
                    message.tbAge = reader.string();
                    break;
                }
            case 39: {
                    message.isMem = reader.int32();
                    break;
                }
            case 40: {
                    message.bimgEndTime = reader.int32();
                    break;
                }
            case 41: {
                    message.payMemberInfo = $root.PayMemberInfo.decode(reader, reader.uint32());
                    break;
                }
            case 42: {
                    message.gender = reader.int32();
                    break;
                }
            case 43: {
                    message.isMask = reader.int32();
                    break;
                }
            case 44: {
                    if (!(message.userPics && message.userPics.length))
                        message.userPics = [];
                    message.userPics.push($root.UserPics.decode(reader, reader.uint32()));
                    break;
                }
            case 45: {
                    message.privSets = $root.PrivSets.decode(reader, reader.uint32());
                    break;
                }
            case 46: {
                    message.isFriend = reader.int32();
                    break;
                }
            case 47: {
                    if (!(message.likeForum && message.likeForum.length))
                        message.likeForum = [];
                    message.likeForum.push($root.LikeForumInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 48: {
                    if (!(message.groupList && message.groupList.length))
                        message.groupList = [];
                    message.groupList.push($root.MyGroupInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 49: {
                    message.giftNum = reader.int32();
                    break;
                }
            case 50: {
                    if (!(message.giftList && message.giftList.length))
                        message.giftList = [];
                    message.giftList.push($root.GiftInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 51: {
                    message.isSelectTail = reader.int32();
                    break;
                }
            case 52: {
                    message.isGuanfang = reader.int32();
                    break;
                }
            case 53: {
                    message.bookmarkCount = reader.int32();
                    break;
                }
            case 54: {
                    message.bookmarkNewCount = reader.int32();
                    break;
                }
            case 55: {
                    if (!(message.muteUser && message.muteUser.length))
                        message.muteUser = [];
                    message.muteUser.push($root.SimpleUser.decode(reader, reader.uint32()));
                    break;
                }
            case 56: {
                    message.friendNum = reader.int64();
                    break;
                }
            case 57: {
                    message.fansNickname = reader.string();
                    break;
                }
            case 58: {
                    message.bgPic = reader.string();
                    break;
                }
            case 59: {
                    message.parrScores = $root.NewParrScores.decode(reader, reader.uint32());
                    break;
                }
            case 60: {
                    message.novelFansInfo = $root.NovelFansInfo.decode(reader, reader.uint32());
                    break;
                }
            case 61: {
                    message.vipInfo = $root.UserVipInfo.decode(reader, reader.uint32());
                    break;
                }
            case 62: {
                    message.godData = $root.GodInfo.decode(reader, reader.uint32());
                    break;
                }
            case 63: {
                    message.heavyUser = reader.int32();
                    break;
                }
            case 64: {
                    message.vipShowInfo = $root.VipShowInfo.decode(reader, reader.uint32());
                    break;
                }
            case 65: {
                    if (!(message.newTshowIcon && message.newTshowIcon.length))
                        message.newTshowIcon = [];
                    message.newTshowIcon.push($root.TshowInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 66: {
                    message.twAnchorInfo = $root.TwZhiBoUser.decode(reader, reader.uint32());
                    break;
                }
            case 67: {
                    if (!(message.profitList && message.profitList.length))
                        message.profitList = [];
                    message.profitList.push($root.TwAnchorProfitItem.decode(reader, reader.uint32()));
                    break;
                }
            case 68: {
                    message.consumeInfo = $root.ConsumeInfo.decode(reader, reader.uint32());
                    break;
                }
            case 69: {
                    message.themeCard = $root.ThemeCardInUser.decode(reader, reader.uint32());
                    break;
                }
            case 70: {
                    message.vipCloseAd = $root.VipCloseAd.decode(reader, reader.uint32());
                    break;
                }
            case 71: {
                    message.activitySponsor = $root.ActivitySponsor.decode(reader, reader.uint32());
                    break;
                }
            case 72: {
                    message.tbVip = $root.TbVipInfo.decode(reader, reader.uint32());
                    break;
                }
            case 73: {
                    message.noPostHigh = reader.uint32();
                    break;
                }
            case 74: {
                    message.ecom = $root.Ecom.decode(reader, reader.uint32());
                    break;
                }
            case 75: {
                    message.visitorNum = reader.int32();
                    break;
                }
            case 76: {
                    message.totalVisitorNum = reader.int32();
                    break;
                }
            case 77: {
                    message.pendant = $root.Pendant.decode(reader, reader.uint32());
                    break;
                }
            case 78: {
                    message.alaInfo = $root.AlaUserInfo.decode(reader, reader.uint32());
                    break;
                }
            case 79: {
                    message.sealPrefix = reader.string();
                    break;
                }
            case 80: {
                    message.hasBottleEnter = reader.int32();
                    break;
                }
            case 81: {
                    message.videoChannelInfo = $root.UserVideoChannelInfo.decode(reader, reader.uint32());
                    break;
                }
            case 82: {
                    message.springVirtualUser = $root.SpringVirtualUser.decode(reader, reader.uint32());
                    break;
                }
            case 83: {
                    message.eachOtherFriend = reader.int32();
                    break;
                }
            case 84: {
                    message.esportData = $root.EsportInfo.decode(reader, reader.uint32());
                    break;
                }
            case 85: {
                    message.alaLiveInfo = $root.AlaLiveInfo.decode(reader, reader.uint32());
                    break;
                }
            case 86: {
                    message.nicknameUpdateTime = reader.int32();
                    break;
                }
            case 87: {
                    message.threadNum = reader.int32();
                    break;
                }
            case 88: {
                    message.agreeNum = reader.int32();
                    break;
                }
            case 89: {
                    message.leftCallNum = reader.int32();
                    break;
                }
            case 90: {
                    message.isInvited = reader.int32();
                    break;
                }
            case 91: {
                    message.isFans = reader.int32();
                    break;
                }
            case 92: {
                    message.privThread = reader.int32();
                    break;
                }
            case 93: {
                    message.isVideobiggie = reader.int32();
                    break;
                }
            case 94: {
                    message.isShowRedpacket = reader.int32();
                    break;
                }
            case 95: {
                    message.baijiahaoInfo = $root.BaijiahaoInfo.decode(reader, reader.uint32());
                    break;
                }
            case 96: {
                    message.birthdayInfo = $root.BirthdayInfo.decode(reader, reader.uint32());
                    break;
                }
            case 97: {
                    message.canModifyAvatar = reader.int32();
                    break;
                }
            case 98: {
                    message.modifyAvatarDesc = reader.string();
                    break;
                }
            case 99: {
                    message.influence = reader.int32();
                    break;
                }
            case 100: {
                    message.levelInfluence = reader.string();
                    break;
                }
            case 101: {
                    message.newGodData = $root.NewGodInfo.decode(reader, reader.uint32());
                    break;
                }
            case 103: {
                    message.bawuThrones = $root.BawuThrones.decode(reader, reader.uint32());
                    break;
                }
            case 104: {
                    message.callFansInfo = $root.CallFansInfo.decode(reader, reader.uint32());
                    break;
                }
            case 105: {
                    message.bazhuGrade = $root.BazhuSign.decode(reader, reader.uint32());
                    break;
                }
            case 106: {
                    message.isDefaultAvatar = reader.int32();
                    break;
                }
            case 107: {
                    message.uk = reader.string();
                    break;
                }
            case 108: {
                    message.creationData = $root.CreationData.decode(reader, reader.uint32());
                    break;
                }
            case 109: {
                    message.favoriteNum = reader.int32();
                    break;
                }
            case 110: {
                    message.liveRoomInfo = $root.LiveRoomInfo.decode(reader, reader.uint32());
                    break;
                }
            case 111: {
                    message.businessAccountInfo = $root.BusinessAccountInfo.decode(reader, reader.uint32());
                    break;
                }
            case 112: {
                    message.appealThreadPopover = reader.string();
                    break;
                }
            case 113: {
                    if (!(message.forumToolAuth && message.forumToolAuth.length))
                        message.forumToolAuth = [];
                    message.forumToolAuth.push($root.ForumToolPerm.decode(reader, reader.uint32()));
                    break;
                }
            case 116: {
                    message.workNum = reader.uint32();
                    break;
                }
            case 117: {
                    message.showPbPrivateFlag = reader.int32();
                    break;
                }
            case 118: {
                    message.totalAgreeNum = reader.uint32();
                    break;
                }
            case 119: {
                    message.workcreationData = $root.CreationData.decode(reader, reader.uint32());
                    break;
                }
            case 120: {
                    message.tiebaUid = reader.string();
                    break;
                }
            case 121: {
                    message.followFrom = reader.string();
                    break;
                }
            case 122: {
                    if (!(message.managerForum && message.managerForum.length))
                        message.managerForum = [];
                    message.managerForum.push($root.BazhuSign.decode(reader, reader.uint32()));
                    break;
                }
            case 123: {
                    message.displayAuthType = reader.int32();
                    break;
                }
            case 124: {
                    message.workCreatorInfo = $root.WorkCreatorInfo.decode(reader, reader.uint32());
                    break;
                }
            case 125: {
                    message.levelName = reader.string();
                    break;
                }
            case 126: {
                    message.editConfig = $root.EditConfig.decode(reader, reader.uint32());
                    break;
                }
            case 127: {
                    message.ipAddress = reader.string();
                    break;
                }
            case 128: {
                    message.isNicknameEditing = reader.int32();
                    break;
                }
            case 129: {
                    message.editingNickname = reader.string();
                    break;
                }
            case 136: {
                    message.virtualImageInfo = $root.VirtualImageInfo.decode(reader, reader.uint32());
                    break;
                }
            case 138: {
                    message.displayIntro = reader.string();
                    break;
                }
            case 141: {
                    message.themeTail = $root.ThemeTailInUser.decode(reader, reader.uint32());
                    break;
                }
            case 145: {
                    message.shakeAdSwitch = $root.ShakeAdSwitch.decode(reader, reader.uint32());
                    break;
                }
            case 147: {
                    message.iosBUrl = reader.string();
                    break;
                }
            case 148: {
                    message.pa = reader.int64();
                    break;
                }
            case 149: {
                    message.enableNewHomepage = reader.int32();
                    break;
                }
            case 150: {
                    message.targetScheme = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a User message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof User
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {User} User
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    User.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a User message.
     * @function verify
     * @memberof User
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    User.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isLogin != null && message.hasOwnProperty("isLogin"))
            if (!$util.isInteger(message.isLogin))
                return "isLogin: integer expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.nameShow != null && message.hasOwnProperty("nameShow"))
            if (!$util.isString(message.nameShow))
                return "nameShow: string expected";
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            if (!$util.isString(message.portrait))
                return "portrait: string expected";
        if (message.noUn != null && message.hasOwnProperty("noUn"))
            if (!$util.isInteger(message.noUn))
                return "noUn: integer expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.newUserInfo != null && message.hasOwnProperty("newUserInfo")) {
            let error = $root.NewUser.verify(message.newUserInfo);
            if (error)
                return "newUserInfo." + error;
        }
        if (message.userhide != null && message.hasOwnProperty("userhide"))
            if (!$util.isInteger(message.userhide))
                return "userhide: integer expected";
        if (message.balv != null && message.hasOwnProperty("balv")) {
            let error = $root.Balv.verify(message.balv);
            if (error)
                return "balv." + error;
        }
        if (message.isManager != null && message.hasOwnProperty("isManager"))
            if (!$util.isInteger(message.isManager))
                return "isManager: integer expected";
        if (message.rank != null && message.hasOwnProperty("rank"))
            if (!$util.isString(message.rank))
                return "rank: string expected";
        if (message.bimgUrl != null && message.hasOwnProperty("bimgUrl"))
            if (!$util.isString(message.bimgUrl))
                return "bimgUrl: string expected";
        if (message.meizhiLevel != null && message.hasOwnProperty("meizhiLevel"))
            if (!$util.isInteger(message.meizhiLevel))
                return "meizhiLevel: integer expected";
        if (message.isVerify != null && message.hasOwnProperty("isVerify"))
            if (!$util.isInteger(message.isVerify))
                return "isVerify: integer expected";
        if (message.isInterestman != null && message.hasOwnProperty("isInterestman"))
            if (!$util.isInteger(message.isInterestman))
                return "isInterestman: integer expected";
        if (message.iconinfo != null && message.hasOwnProperty("iconinfo")) {
            if (!Array.isArray(message.iconinfo))
                return "iconinfo: array expected";
            for (let i = 0; i < message.iconinfo.length; ++i) {
                let error = $root.Icon.verify(message.iconinfo[i]);
                if (error)
                    return "iconinfo." + error;
            }
        }
        if (message.tshowIcon != null && message.hasOwnProperty("tshowIcon")) {
            if (!Array.isArray(message.tshowIcon))
                return "tshowIcon: array expected";
            for (let i = 0; i < message.tshowIcon.length; ++i) {
                let error = $root.TshowInfo.verify(message.tshowIcon[i]);
                if (error)
                    return "tshowIcon." + error;
            }
        }
        if (message.userType != null && message.hasOwnProperty("userType"))
            if (!$util.isInteger(message.userType))
                return "userType: integer expected";
        if (message.isCoreuser != null && message.hasOwnProperty("isCoreuser"))
            if (!$util.isInteger(message.isCoreuser))
                return "isCoreuser: integer expected";
        if (message.isHuinibuke != null && message.hasOwnProperty("isHuinibuke"))
            if (!$util.isInteger(message.isHuinibuke))
                return "isHuinibuke: integer expected";
        if (message.iosBimgFormat != null && message.hasOwnProperty("iosBimgFormat"))
            if (!$util.isString(message.iosBimgFormat))
                return "iosBimgFormat: string expected";
        if (message.levelId != null && message.hasOwnProperty("levelId"))
            if (!$util.isInteger(message.levelId))
                return "levelId: integer expected";
        if (message.isLike != null && message.hasOwnProperty("isLike"))
            if (!$util.isInteger(message.isLike))
                return "isLike: integer expected";
        if (message.isBawu != null && message.hasOwnProperty("isBawu"))
            if (!$util.isInteger(message.isBawu))
                return "isBawu: integer expected";
        if (message.bawuType != null && message.hasOwnProperty("bawuType"))
            if (!$util.isString(message.bawuType))
                return "bawuType: string expected";
        if (message.portraith != null && message.hasOwnProperty("portraith"))
            if (!$util.isString(message.portraith))
                return "portraith: string expected";
        if (message.ip != null && message.hasOwnProperty("ip"))
            if (!$util.isString(message.ip))
                return "ip: string expected";
        if (message.BDUSS != null && message.hasOwnProperty("BDUSS"))
            if (!$util.isString(message.BDUSS))
                return "BDUSS: string expected";
        if (message.fansNum != null && message.hasOwnProperty("fansNum"))
            if (!$util.isInteger(message.fansNum))
                return "fansNum: integer expected";
        if (message.concernNum != null && message.hasOwnProperty("concernNum"))
            if (!$util.isInteger(message.concernNum))
                return "concernNum: integer expected";
        if (message.sex != null && message.hasOwnProperty("sex"))
            if (!$util.isInteger(message.sex))
                return "sex: integer expected";
        if (message.myLikeNum != null && message.hasOwnProperty("myLikeNum"))
            if (!$util.isInteger(message.myLikeNum))
                return "myLikeNum: integer expected";
        if (message.intro != null && message.hasOwnProperty("intro"))
            if (!$util.isString(message.intro))
                return "intro: string expected";
        if (message.hasConcerned != null && message.hasOwnProperty("hasConcerned"))
            if (!$util.isInteger(message.hasConcerned))
                return "hasConcerned: integer expected";
        if (message.passwd != null && message.hasOwnProperty("passwd"))
            if (!$util.isString(message.passwd))
                return "passwd: string expected";
        if (message.postNum != null && message.hasOwnProperty("postNum"))
            if (!$util.isInteger(message.postNum))
                return "postNum: integer expected";
        if (message.tbAge != null && message.hasOwnProperty("tbAge"))
            if (!$util.isString(message.tbAge))
                return "tbAge: string expected";
        if (message.isMem != null && message.hasOwnProperty("isMem"))
            if (!$util.isInteger(message.isMem))
                return "isMem: integer expected";
        if (message.bimgEndTime != null && message.hasOwnProperty("bimgEndTime"))
            if (!$util.isInteger(message.bimgEndTime))
                return "bimgEndTime: integer expected";
        if (message.payMemberInfo != null && message.hasOwnProperty("payMemberInfo")) {
            let error = $root.PayMemberInfo.verify(message.payMemberInfo);
            if (error)
                return "payMemberInfo." + error;
        }
        if (message.gender != null && message.hasOwnProperty("gender"))
            if (!$util.isInteger(message.gender))
                return "gender: integer expected";
        if (message.isMask != null && message.hasOwnProperty("isMask"))
            if (!$util.isInteger(message.isMask))
                return "isMask: integer expected";
        if (message.userPics != null && message.hasOwnProperty("userPics")) {
            if (!Array.isArray(message.userPics))
                return "userPics: array expected";
            for (let i = 0; i < message.userPics.length; ++i) {
                let error = $root.UserPics.verify(message.userPics[i]);
                if (error)
                    return "userPics." + error;
            }
        }
        if (message.privSets != null && message.hasOwnProperty("privSets")) {
            let error = $root.PrivSets.verify(message.privSets);
            if (error)
                return "privSets." + error;
        }
        if (message.isFriend != null && message.hasOwnProperty("isFriend"))
            if (!$util.isInteger(message.isFriend))
                return "isFriend: integer expected";
        if (message.likeForum != null && message.hasOwnProperty("likeForum")) {
            if (!Array.isArray(message.likeForum))
                return "likeForum: array expected";
            for (let i = 0; i < message.likeForum.length; ++i) {
                let error = $root.LikeForumInfo.verify(message.likeForum[i]);
                if (error)
                    return "likeForum." + error;
            }
        }
        if (message.groupList != null && message.hasOwnProperty("groupList")) {
            if (!Array.isArray(message.groupList))
                return "groupList: array expected";
            for (let i = 0; i < message.groupList.length; ++i) {
                let error = $root.MyGroupInfo.verify(message.groupList[i]);
                if (error)
                    return "groupList." + error;
            }
        }
        if (message.giftNum != null && message.hasOwnProperty("giftNum"))
            if (!$util.isInteger(message.giftNum))
                return "giftNum: integer expected";
        if (message.giftList != null && message.hasOwnProperty("giftList")) {
            if (!Array.isArray(message.giftList))
                return "giftList: array expected";
            for (let i = 0; i < message.giftList.length; ++i) {
                let error = $root.GiftInfo.verify(message.giftList[i]);
                if (error)
                    return "giftList." + error;
            }
        }
        if (message.isSelectTail != null && message.hasOwnProperty("isSelectTail"))
            if (!$util.isInteger(message.isSelectTail))
                return "isSelectTail: integer expected";
        if (message.isGuanfang != null && message.hasOwnProperty("isGuanfang"))
            if (!$util.isInteger(message.isGuanfang))
                return "isGuanfang: integer expected";
        if (message.bookmarkCount != null && message.hasOwnProperty("bookmarkCount"))
            if (!$util.isInteger(message.bookmarkCount))
                return "bookmarkCount: integer expected";
        if (message.bookmarkNewCount != null && message.hasOwnProperty("bookmarkNewCount"))
            if (!$util.isInteger(message.bookmarkNewCount))
                return "bookmarkNewCount: integer expected";
        if (message.muteUser != null && message.hasOwnProperty("muteUser")) {
            if (!Array.isArray(message.muteUser))
                return "muteUser: array expected";
            for (let i = 0; i < message.muteUser.length; ++i) {
                let error = $root.SimpleUser.verify(message.muteUser[i]);
                if (error)
                    return "muteUser." + error;
            }
        }
        if (message.friendNum != null && message.hasOwnProperty("friendNum"))
            if (!$util.isInteger(message.friendNum) && !(message.friendNum && $util.isInteger(message.friendNum.low) && $util.isInteger(message.friendNum.high)))
                return "friendNum: integer|Long expected";
        if (message.fansNickname != null && message.hasOwnProperty("fansNickname"))
            if (!$util.isString(message.fansNickname))
                return "fansNickname: string expected";
        if (message.bgPic != null && message.hasOwnProperty("bgPic"))
            if (!$util.isString(message.bgPic))
                return "bgPic: string expected";
        if (message.parrScores != null && message.hasOwnProperty("parrScores")) {
            let error = $root.NewParrScores.verify(message.parrScores);
            if (error)
                return "parrScores." + error;
        }
        if (message.novelFansInfo != null && message.hasOwnProperty("novelFansInfo")) {
            let error = $root.NovelFansInfo.verify(message.novelFansInfo);
            if (error)
                return "novelFansInfo." + error;
        }
        if (message.vipInfo != null && message.hasOwnProperty("vipInfo")) {
            let error = $root.UserVipInfo.verify(message.vipInfo);
            if (error)
                return "vipInfo." + error;
        }
        if (message.godData != null && message.hasOwnProperty("godData")) {
            let error = $root.GodInfo.verify(message.godData);
            if (error)
                return "godData." + error;
        }
        if (message.heavyUser != null && message.hasOwnProperty("heavyUser"))
            if (!$util.isInteger(message.heavyUser))
                return "heavyUser: integer expected";
        if (message.vipShowInfo != null && message.hasOwnProperty("vipShowInfo")) {
            let error = $root.VipShowInfo.verify(message.vipShowInfo);
            if (error)
                return "vipShowInfo." + error;
        }
        if (message.newTshowIcon != null && message.hasOwnProperty("newTshowIcon")) {
            if (!Array.isArray(message.newTshowIcon))
                return "newTshowIcon: array expected";
            for (let i = 0; i < message.newTshowIcon.length; ++i) {
                let error = $root.TshowInfo.verify(message.newTshowIcon[i]);
                if (error)
                    return "newTshowIcon." + error;
            }
        }
        if (message.twAnchorInfo != null && message.hasOwnProperty("twAnchorInfo")) {
            let error = $root.TwZhiBoUser.verify(message.twAnchorInfo);
            if (error)
                return "twAnchorInfo." + error;
        }
        if (message.profitList != null && message.hasOwnProperty("profitList")) {
            if (!Array.isArray(message.profitList))
                return "profitList: array expected";
            for (let i = 0; i < message.profitList.length; ++i) {
                let error = $root.TwAnchorProfitItem.verify(message.profitList[i]);
                if (error)
                    return "profitList." + error;
            }
        }
        if (message.consumeInfo != null && message.hasOwnProperty("consumeInfo")) {
            let error = $root.ConsumeInfo.verify(message.consumeInfo);
            if (error)
                return "consumeInfo." + error;
        }
        if (message.themeCard != null && message.hasOwnProperty("themeCard")) {
            let error = $root.ThemeCardInUser.verify(message.themeCard);
            if (error)
                return "themeCard." + error;
        }
        if (message.vipCloseAd != null && message.hasOwnProperty("vipCloseAd")) {
            let error = $root.VipCloseAd.verify(message.vipCloseAd);
            if (error)
                return "vipCloseAd." + error;
        }
        if (message.activitySponsor != null && message.hasOwnProperty("activitySponsor")) {
            let error = $root.ActivitySponsor.verify(message.activitySponsor);
            if (error)
                return "activitySponsor." + error;
        }
        if (message.tbVip != null && message.hasOwnProperty("tbVip")) {
            let error = $root.TbVipInfo.verify(message.tbVip);
            if (error)
                return "tbVip." + error;
        }
        if (message.noPostHigh != null && message.hasOwnProperty("noPostHigh"))
            if (!$util.isInteger(message.noPostHigh))
                return "noPostHigh: integer expected";
        if (message.ecom != null && message.hasOwnProperty("ecom")) {
            let error = $root.Ecom.verify(message.ecom);
            if (error)
                return "ecom." + error;
        }
        if (message.visitorNum != null && message.hasOwnProperty("visitorNum"))
            if (!$util.isInteger(message.visitorNum))
                return "visitorNum: integer expected";
        if (message.totalVisitorNum != null && message.hasOwnProperty("totalVisitorNum"))
            if (!$util.isInteger(message.totalVisitorNum))
                return "totalVisitorNum: integer expected";
        if (message.pendant != null && message.hasOwnProperty("pendant")) {
            let error = $root.Pendant.verify(message.pendant);
            if (error)
                return "pendant." + error;
        }
        if (message.alaInfo != null && message.hasOwnProperty("alaInfo")) {
            let error = $root.AlaUserInfo.verify(message.alaInfo);
            if (error)
                return "alaInfo." + error;
        }
        if (message.sealPrefix != null && message.hasOwnProperty("sealPrefix"))
            if (!$util.isString(message.sealPrefix))
                return "sealPrefix: string expected";
        if (message.hasBottleEnter != null && message.hasOwnProperty("hasBottleEnter"))
            if (!$util.isInteger(message.hasBottleEnter))
                return "hasBottleEnter: integer expected";
        if (message.videoChannelInfo != null && message.hasOwnProperty("videoChannelInfo")) {
            let error = $root.UserVideoChannelInfo.verify(message.videoChannelInfo);
            if (error)
                return "videoChannelInfo." + error;
        }
        if (message.springVirtualUser != null && message.hasOwnProperty("springVirtualUser")) {
            let error = $root.SpringVirtualUser.verify(message.springVirtualUser);
            if (error)
                return "springVirtualUser." + error;
        }
        if (message.eachOtherFriend != null && message.hasOwnProperty("eachOtherFriend"))
            if (!$util.isInteger(message.eachOtherFriend))
                return "eachOtherFriend: integer expected";
        if (message.esportData != null && message.hasOwnProperty("esportData")) {
            let error = $root.EsportInfo.verify(message.esportData);
            if (error)
                return "esportData." + error;
        }
        if (message.alaLiveInfo != null && message.hasOwnProperty("alaLiveInfo")) {
            let error = $root.AlaLiveInfo.verify(message.alaLiveInfo);
            if (error)
                return "alaLiveInfo." + error;
        }
        if (message.nicknameUpdateTime != null && message.hasOwnProperty("nicknameUpdateTime"))
            if (!$util.isInteger(message.nicknameUpdateTime))
                return "nicknameUpdateTime: integer expected";
        if (message.threadNum != null && message.hasOwnProperty("threadNum"))
            if (!$util.isInteger(message.threadNum))
                return "threadNum: integer expected";
        if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
            if (!$util.isInteger(message.agreeNum))
                return "agreeNum: integer expected";
        if (message.leftCallNum != null && message.hasOwnProperty("leftCallNum"))
            if (!$util.isInteger(message.leftCallNum))
                return "leftCallNum: integer expected";
        if (message.isInvited != null && message.hasOwnProperty("isInvited"))
            if (!$util.isInteger(message.isInvited))
                return "isInvited: integer expected";
        if (message.isFans != null && message.hasOwnProperty("isFans"))
            if (!$util.isInteger(message.isFans))
                return "isFans: integer expected";
        if (message.privThread != null && message.hasOwnProperty("privThread"))
            if (!$util.isInteger(message.privThread))
                return "privThread: integer expected";
        if (message.isVideobiggie != null && message.hasOwnProperty("isVideobiggie"))
            if (!$util.isInteger(message.isVideobiggie))
                return "isVideobiggie: integer expected";
        if (message.isShowRedpacket != null && message.hasOwnProperty("isShowRedpacket"))
            if (!$util.isInteger(message.isShowRedpacket))
                return "isShowRedpacket: integer expected";
        if (message.baijiahaoInfo != null && message.hasOwnProperty("baijiahaoInfo")) {
            let error = $root.BaijiahaoInfo.verify(message.baijiahaoInfo);
            if (error)
                return "baijiahaoInfo." + error;
        }
        if (message.birthdayInfo != null && message.hasOwnProperty("birthdayInfo")) {
            let error = $root.BirthdayInfo.verify(message.birthdayInfo);
            if (error)
                return "birthdayInfo." + error;
        }
        if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
            if (!$util.isInteger(message.canModifyAvatar))
                return "canModifyAvatar: integer expected";
        if (message.modifyAvatarDesc != null && message.hasOwnProperty("modifyAvatarDesc"))
            if (!$util.isString(message.modifyAvatarDesc))
                return "modifyAvatarDesc: string expected";
        if (message.influence != null && message.hasOwnProperty("influence"))
            if (!$util.isInteger(message.influence))
                return "influence: integer expected";
        if (message.levelInfluence != null && message.hasOwnProperty("levelInfluence"))
            if (!$util.isString(message.levelInfluence))
                return "levelInfluence: string expected";
        if (message.newGodData != null && message.hasOwnProperty("newGodData")) {
            let error = $root.NewGodInfo.verify(message.newGodData);
            if (error)
                return "newGodData." + error;
        }
        if (message.bawuThrones != null && message.hasOwnProperty("bawuThrones")) {
            let error = $root.BawuThrones.verify(message.bawuThrones);
            if (error)
                return "bawuThrones." + error;
        }
        if (message.callFansInfo != null && message.hasOwnProperty("callFansInfo")) {
            let error = $root.CallFansInfo.verify(message.callFansInfo);
            if (error)
                return "callFansInfo." + error;
        }
        if (message.bazhuGrade != null && message.hasOwnProperty("bazhuGrade")) {
            let error = $root.BazhuSign.verify(message.bazhuGrade);
            if (error)
                return "bazhuGrade." + error;
        }
        if (message.isDefaultAvatar != null && message.hasOwnProperty("isDefaultAvatar"))
            if (!$util.isInteger(message.isDefaultAvatar))
                return "isDefaultAvatar: integer expected";
        if (message.uk != null && message.hasOwnProperty("uk"))
            if (!$util.isString(message.uk))
                return "uk: string expected";
        if (message.creationData != null && message.hasOwnProperty("creationData")) {
            let error = $root.CreationData.verify(message.creationData);
            if (error)
                return "creationData." + error;
        }
        if (message.favoriteNum != null && message.hasOwnProperty("favoriteNum"))
            if (!$util.isInteger(message.favoriteNum))
                return "favoriteNum: integer expected";
        if (message.liveRoomInfo != null && message.hasOwnProperty("liveRoomInfo")) {
            let error = $root.LiveRoomInfo.verify(message.liveRoomInfo);
            if (error)
                return "liveRoomInfo." + error;
        }
        if (message.businessAccountInfo != null && message.hasOwnProperty("businessAccountInfo")) {
            let error = $root.BusinessAccountInfo.verify(message.businessAccountInfo);
            if (error)
                return "businessAccountInfo." + error;
        }
        if (message.appealThreadPopover != null && message.hasOwnProperty("appealThreadPopover"))
            if (!$util.isString(message.appealThreadPopover))
                return "appealThreadPopover: string expected";
        if (message.forumToolAuth != null && message.hasOwnProperty("forumToolAuth")) {
            if (!Array.isArray(message.forumToolAuth))
                return "forumToolAuth: array expected";
            for (let i = 0; i < message.forumToolAuth.length; ++i) {
                let error = $root.ForumToolPerm.verify(message.forumToolAuth[i]);
                if (error)
                    return "forumToolAuth." + error;
            }
        }
        if (message.workNum != null && message.hasOwnProperty("workNum"))
            if (!$util.isInteger(message.workNum))
                return "workNum: integer expected";
        if (message.showPbPrivateFlag != null && message.hasOwnProperty("showPbPrivateFlag"))
            if (!$util.isInteger(message.showPbPrivateFlag))
                return "showPbPrivateFlag: integer expected";
        if (message.totalAgreeNum != null && message.hasOwnProperty("totalAgreeNum"))
            if (!$util.isInteger(message.totalAgreeNum))
                return "totalAgreeNum: integer expected";
        if (message.workcreationData != null && message.hasOwnProperty("workcreationData")) {
            let error = $root.CreationData.verify(message.workcreationData);
            if (error)
                return "workcreationData." + error;
        }
        if (message.tiebaUid != null && message.hasOwnProperty("tiebaUid"))
            if (!$util.isString(message.tiebaUid))
                return "tiebaUid: string expected";
        if (message.followFrom != null && message.hasOwnProperty("followFrom"))
            if (!$util.isString(message.followFrom))
                return "followFrom: string expected";
        if (message.managerForum != null && message.hasOwnProperty("managerForum")) {
            if (!Array.isArray(message.managerForum))
                return "managerForum: array expected";
            for (let i = 0; i < message.managerForum.length; ++i) {
                let error = $root.BazhuSign.verify(message.managerForum[i]);
                if (error)
                    return "managerForum." + error;
            }
        }
        if (message.displayAuthType != null && message.hasOwnProperty("displayAuthType"))
            if (!$util.isInteger(message.displayAuthType))
                return "displayAuthType: integer expected";
        if (message.workCreatorInfo != null && message.hasOwnProperty("workCreatorInfo")) {
            let error = $root.WorkCreatorInfo.verify(message.workCreatorInfo);
            if (error)
                return "workCreatorInfo." + error;
        }
        if (message.levelName != null && message.hasOwnProperty("levelName"))
            if (!$util.isString(message.levelName))
                return "levelName: string expected";
        if (message.editConfig != null && message.hasOwnProperty("editConfig")) {
            let error = $root.EditConfig.verify(message.editConfig);
            if (error)
                return "editConfig." + error;
        }
        if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
            if (!$util.isString(message.ipAddress))
                return "ipAddress: string expected";
        if (message.isNicknameEditing != null && message.hasOwnProperty("isNicknameEditing"))
            if (!$util.isInteger(message.isNicknameEditing))
                return "isNicknameEditing: integer expected";
        if (message.editingNickname != null && message.hasOwnProperty("editingNickname"))
            if (!$util.isString(message.editingNickname))
                return "editingNickname: string expected";
        if (message.virtualImageInfo != null && message.hasOwnProperty("virtualImageInfo")) {
            let error = $root.VirtualImageInfo.verify(message.virtualImageInfo);
            if (error)
                return "virtualImageInfo." + error;
        }
        if (message.displayIntro != null && message.hasOwnProperty("displayIntro"))
            if (!$util.isString(message.displayIntro))
                return "displayIntro: string expected";
        if (message.themeTail != null && message.hasOwnProperty("themeTail")) {
            let error = $root.ThemeTailInUser.verify(message.themeTail);
            if (error)
                return "themeTail." + error;
        }
        if (message.shakeAdSwitch != null && message.hasOwnProperty("shakeAdSwitch")) {
            let error = $root.ShakeAdSwitch.verify(message.shakeAdSwitch);
            if (error)
                return "shakeAdSwitch." + error;
        }
        if (message.iosBUrl != null && message.hasOwnProperty("iosBUrl"))
            if (!$util.isString(message.iosBUrl))
                return "iosBUrl: string expected";
        if (message.pa != null && message.hasOwnProperty("pa"))
            if (!$util.isInteger(message.pa) && !(message.pa && $util.isInteger(message.pa.low) && $util.isInteger(message.pa.high)))
                return "pa: integer|Long expected";
        if (message.enableNewHomepage != null && message.hasOwnProperty("enableNewHomepage"))
            if (!$util.isInteger(message.enableNewHomepage))
                return "enableNewHomepage: integer expected";
        if (message.targetScheme != null && message.hasOwnProperty("targetScheme"))
            if (!$util.isString(message.targetScheme))
                return "targetScheme: string expected";
        return null;
    };

    /**
     * Creates a User message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof User
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {User} User
     */
    User.fromObject = function fromObject(object) {
        if (object instanceof $root.User)
            return object;
        let message = new $root.User();
        if (object.isLogin != null)
            message.isLogin = object.isLogin | 0;
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.name != null)
            message.name = String(object.name);
        if (object.nameShow != null)
            message.nameShow = String(object.nameShow);
        if (object.portrait != null)
            message.portrait = String(object.portrait);
        if (object.noUn != null)
            message.noUn = object.noUn | 0;
        if (object.type != null)
            message.type = object.type | 0;
        if (object.newUserInfo != null) {
            if (typeof object.newUserInfo !== "object")
                throw TypeError(".User.newUserInfo: object expected");
            message.newUserInfo = $root.NewUser.fromObject(object.newUserInfo);
        }
        if (object.userhide != null)
            message.userhide = object.userhide | 0;
        if (object.balv != null) {
            if (typeof object.balv !== "object")
                throw TypeError(".User.balv: object expected");
            message.balv = $root.Balv.fromObject(object.balv);
        }
        if (object.isManager != null)
            message.isManager = object.isManager | 0;
        if (object.rank != null)
            message.rank = String(object.rank);
        if (object.bimgUrl != null)
            message.bimgUrl = String(object.bimgUrl);
        if (object.meizhiLevel != null)
            message.meizhiLevel = object.meizhiLevel | 0;
        if (object.isVerify != null)
            message.isVerify = object.isVerify | 0;
        if (object.isInterestman != null)
            message.isInterestman = object.isInterestman | 0;
        if (object.iconinfo) {
            if (!Array.isArray(object.iconinfo))
                throw TypeError(".User.iconinfo: array expected");
            message.iconinfo = [];
            for (let i = 0; i < object.iconinfo.length; ++i) {
                if (typeof object.iconinfo[i] !== "object")
                    throw TypeError(".User.iconinfo: object expected");
                message.iconinfo[i] = $root.Icon.fromObject(object.iconinfo[i]);
            }
        }
        if (object.tshowIcon) {
            if (!Array.isArray(object.tshowIcon))
                throw TypeError(".User.tshowIcon: array expected");
            message.tshowIcon = [];
            for (let i = 0; i < object.tshowIcon.length; ++i) {
                if (typeof object.tshowIcon[i] !== "object")
                    throw TypeError(".User.tshowIcon: object expected");
                message.tshowIcon[i] = $root.TshowInfo.fromObject(object.tshowIcon[i]);
            }
        }
        if (object.userType != null)
            message.userType = object.userType | 0;
        if (object.isCoreuser != null)
            message.isCoreuser = object.isCoreuser | 0;
        if (object.isHuinibuke != null)
            message.isHuinibuke = object.isHuinibuke | 0;
        if (object.iosBimgFormat != null)
            message.iosBimgFormat = String(object.iosBimgFormat);
        if (object.levelId != null)
            message.levelId = object.levelId | 0;
        if (object.isLike != null)
            message.isLike = object.isLike | 0;
        if (object.isBawu != null)
            message.isBawu = object.isBawu | 0;
        if (object.bawuType != null)
            message.bawuType = String(object.bawuType);
        if (object.portraith != null)
            message.portraith = String(object.portraith);
        if (object.ip != null)
            message.ip = String(object.ip);
        if (object.BDUSS != null)
            message.BDUSS = String(object.BDUSS);
        if (object.fansNum != null)
            message.fansNum = object.fansNum | 0;
        if (object.concernNum != null)
            message.concernNum = object.concernNum | 0;
        if (object.sex != null)
            message.sex = object.sex | 0;
        if (object.myLikeNum != null)
            message.myLikeNum = object.myLikeNum | 0;
        if (object.intro != null)
            message.intro = String(object.intro);
        if (object.hasConcerned != null)
            message.hasConcerned = object.hasConcerned | 0;
        if (object.passwd != null)
            message.passwd = String(object.passwd);
        if (object.postNum != null)
            message.postNum = object.postNum | 0;
        if (object.tbAge != null)
            message.tbAge = String(object.tbAge);
        if (object.isMem != null)
            message.isMem = object.isMem | 0;
        if (object.bimgEndTime != null)
            message.bimgEndTime = object.bimgEndTime | 0;
        if (object.payMemberInfo != null) {
            if (typeof object.payMemberInfo !== "object")
                throw TypeError(".User.payMemberInfo: object expected");
            message.payMemberInfo = $root.PayMemberInfo.fromObject(object.payMemberInfo);
        }
        if (object.gender != null)
            message.gender = object.gender | 0;
        if (object.isMask != null)
            message.isMask = object.isMask | 0;
        if (object.userPics) {
            if (!Array.isArray(object.userPics))
                throw TypeError(".User.userPics: array expected");
            message.userPics = [];
            for (let i = 0; i < object.userPics.length; ++i) {
                if (typeof object.userPics[i] !== "object")
                    throw TypeError(".User.userPics: object expected");
                message.userPics[i] = $root.UserPics.fromObject(object.userPics[i]);
            }
        }
        if (object.privSets != null) {
            if (typeof object.privSets !== "object")
                throw TypeError(".User.privSets: object expected");
            message.privSets = $root.PrivSets.fromObject(object.privSets);
        }
        if (object.isFriend != null)
            message.isFriend = object.isFriend | 0;
        if (object.likeForum) {
            if (!Array.isArray(object.likeForum))
                throw TypeError(".User.likeForum: array expected");
            message.likeForum = [];
            for (let i = 0; i < object.likeForum.length; ++i) {
                if (typeof object.likeForum[i] !== "object")
                    throw TypeError(".User.likeForum: object expected");
                message.likeForum[i] = $root.LikeForumInfo.fromObject(object.likeForum[i]);
            }
        }
        if (object.groupList) {
            if (!Array.isArray(object.groupList))
                throw TypeError(".User.groupList: array expected");
            message.groupList = [];
            for (let i = 0; i < object.groupList.length; ++i) {
                if (typeof object.groupList[i] !== "object")
                    throw TypeError(".User.groupList: object expected");
                message.groupList[i] = $root.MyGroupInfo.fromObject(object.groupList[i]);
            }
        }
        if (object.giftNum != null)
            message.giftNum = object.giftNum | 0;
        if (object.giftList) {
            if (!Array.isArray(object.giftList))
                throw TypeError(".User.giftList: array expected");
            message.giftList = [];
            for (let i = 0; i < object.giftList.length; ++i) {
                if (typeof object.giftList[i] !== "object")
                    throw TypeError(".User.giftList: object expected");
                message.giftList[i] = $root.GiftInfo.fromObject(object.giftList[i]);
            }
        }
        if (object.isSelectTail != null)
            message.isSelectTail = object.isSelectTail | 0;
        if (object.isGuanfang != null)
            message.isGuanfang = object.isGuanfang | 0;
        if (object.bookmarkCount != null)
            message.bookmarkCount = object.bookmarkCount | 0;
        if (object.bookmarkNewCount != null)
            message.bookmarkNewCount = object.bookmarkNewCount | 0;
        if (object.muteUser) {
            if (!Array.isArray(object.muteUser))
                throw TypeError(".User.muteUser: array expected");
            message.muteUser = [];
            for (let i = 0; i < object.muteUser.length; ++i) {
                if (typeof object.muteUser[i] !== "object")
                    throw TypeError(".User.muteUser: object expected");
                message.muteUser[i] = $root.SimpleUser.fromObject(object.muteUser[i]);
            }
        }
        if (object.friendNum != null)
            if ($util.Long)
                (message.friendNum = $util.Long.fromValue(object.friendNum)).unsigned = false;
            else if (typeof object.friendNum === "string")
                message.friendNum = parseInt(object.friendNum, 10);
            else if (typeof object.friendNum === "number")
                message.friendNum = object.friendNum;
            else if (typeof object.friendNum === "object")
                message.friendNum = new $util.LongBits(object.friendNum.low >>> 0, object.friendNum.high >>> 0).toNumber();
        if (object.fansNickname != null)
            message.fansNickname = String(object.fansNickname);
        if (object.bgPic != null)
            message.bgPic = String(object.bgPic);
        if (object.parrScores != null) {
            if (typeof object.parrScores !== "object")
                throw TypeError(".User.parrScores: object expected");
            message.parrScores = $root.NewParrScores.fromObject(object.parrScores);
        }
        if (object.novelFansInfo != null) {
            if (typeof object.novelFansInfo !== "object")
                throw TypeError(".User.novelFansInfo: object expected");
            message.novelFansInfo = $root.NovelFansInfo.fromObject(object.novelFansInfo);
        }
        if (object.vipInfo != null) {
            if (typeof object.vipInfo !== "object")
                throw TypeError(".User.vipInfo: object expected");
            message.vipInfo = $root.UserVipInfo.fromObject(object.vipInfo);
        }
        if (object.godData != null) {
            if (typeof object.godData !== "object")
                throw TypeError(".User.godData: object expected");
            message.godData = $root.GodInfo.fromObject(object.godData);
        }
        if (object.heavyUser != null)
            message.heavyUser = object.heavyUser | 0;
        if (object.vipShowInfo != null) {
            if (typeof object.vipShowInfo !== "object")
                throw TypeError(".User.vipShowInfo: object expected");
            message.vipShowInfo = $root.VipShowInfo.fromObject(object.vipShowInfo);
        }
        if (object.newTshowIcon) {
            if (!Array.isArray(object.newTshowIcon))
                throw TypeError(".User.newTshowIcon: array expected");
            message.newTshowIcon = [];
            for (let i = 0; i < object.newTshowIcon.length; ++i) {
                if (typeof object.newTshowIcon[i] !== "object")
                    throw TypeError(".User.newTshowIcon: object expected");
                message.newTshowIcon[i] = $root.TshowInfo.fromObject(object.newTshowIcon[i]);
            }
        }
        if (object.twAnchorInfo != null) {
            if (typeof object.twAnchorInfo !== "object")
                throw TypeError(".User.twAnchorInfo: object expected");
            message.twAnchorInfo = $root.TwZhiBoUser.fromObject(object.twAnchorInfo);
        }
        if (object.profitList) {
            if (!Array.isArray(object.profitList))
                throw TypeError(".User.profitList: array expected");
            message.profitList = [];
            for (let i = 0; i < object.profitList.length; ++i) {
                if (typeof object.profitList[i] !== "object")
                    throw TypeError(".User.profitList: object expected");
                message.profitList[i] = $root.TwAnchorProfitItem.fromObject(object.profitList[i]);
            }
        }
        if (object.consumeInfo != null) {
            if (typeof object.consumeInfo !== "object")
                throw TypeError(".User.consumeInfo: object expected");
            message.consumeInfo = $root.ConsumeInfo.fromObject(object.consumeInfo);
        }
        if (object.themeCard != null) {
            if (typeof object.themeCard !== "object")
                throw TypeError(".User.themeCard: object expected");
            message.themeCard = $root.ThemeCardInUser.fromObject(object.themeCard);
        }
        if (object.vipCloseAd != null) {
            if (typeof object.vipCloseAd !== "object")
                throw TypeError(".User.vipCloseAd: object expected");
            message.vipCloseAd = $root.VipCloseAd.fromObject(object.vipCloseAd);
        }
        if (object.activitySponsor != null) {
            if (typeof object.activitySponsor !== "object")
                throw TypeError(".User.activitySponsor: object expected");
            message.activitySponsor = $root.ActivitySponsor.fromObject(object.activitySponsor);
        }
        if (object.tbVip != null) {
            if (typeof object.tbVip !== "object")
                throw TypeError(".User.tbVip: object expected");
            message.tbVip = $root.TbVipInfo.fromObject(object.tbVip);
        }
        if (object.noPostHigh != null)
            message.noPostHigh = object.noPostHigh >>> 0;
        if (object.ecom != null) {
            if (typeof object.ecom !== "object")
                throw TypeError(".User.ecom: object expected");
            message.ecom = $root.Ecom.fromObject(object.ecom);
        }
        if (object.visitorNum != null)
            message.visitorNum = object.visitorNum | 0;
        if (object.totalVisitorNum != null)
            message.totalVisitorNum = object.totalVisitorNum | 0;
        if (object.pendant != null) {
            if (typeof object.pendant !== "object")
                throw TypeError(".User.pendant: object expected");
            message.pendant = $root.Pendant.fromObject(object.pendant);
        }
        if (object.alaInfo != null) {
            if (typeof object.alaInfo !== "object")
                throw TypeError(".User.alaInfo: object expected");
            message.alaInfo = $root.AlaUserInfo.fromObject(object.alaInfo);
        }
        if (object.sealPrefix != null)
            message.sealPrefix = String(object.sealPrefix);
        if (object.hasBottleEnter != null)
            message.hasBottleEnter = object.hasBottleEnter | 0;
        if (object.videoChannelInfo != null) {
            if (typeof object.videoChannelInfo !== "object")
                throw TypeError(".User.videoChannelInfo: object expected");
            message.videoChannelInfo = $root.UserVideoChannelInfo.fromObject(object.videoChannelInfo);
        }
        if (object.springVirtualUser != null) {
            if (typeof object.springVirtualUser !== "object")
                throw TypeError(".User.springVirtualUser: object expected");
            message.springVirtualUser = $root.SpringVirtualUser.fromObject(object.springVirtualUser);
        }
        if (object.eachOtherFriend != null)
            message.eachOtherFriend = object.eachOtherFriend | 0;
        if (object.esportData != null) {
            if (typeof object.esportData !== "object")
                throw TypeError(".User.esportData: object expected");
            message.esportData = $root.EsportInfo.fromObject(object.esportData);
        }
        if (object.alaLiveInfo != null) {
            if (typeof object.alaLiveInfo !== "object")
                throw TypeError(".User.alaLiveInfo: object expected");
            message.alaLiveInfo = $root.AlaLiveInfo.fromObject(object.alaLiveInfo);
        }
        if (object.nicknameUpdateTime != null)
            message.nicknameUpdateTime = object.nicknameUpdateTime | 0;
        if (object.threadNum != null)
            message.threadNum = object.threadNum | 0;
        if (object.agreeNum != null)
            message.agreeNum = object.agreeNum | 0;
        if (object.leftCallNum != null)
            message.leftCallNum = object.leftCallNum | 0;
        if (object.isInvited != null)
            message.isInvited = object.isInvited | 0;
        if (object.isFans != null)
            message.isFans = object.isFans | 0;
        if (object.privThread != null)
            message.privThread = object.privThread | 0;
        if (object.isVideobiggie != null)
            message.isVideobiggie = object.isVideobiggie | 0;
        if (object.isShowRedpacket != null)
            message.isShowRedpacket = object.isShowRedpacket | 0;
        if (object.baijiahaoInfo != null) {
            if (typeof object.baijiahaoInfo !== "object")
                throw TypeError(".User.baijiahaoInfo: object expected");
            message.baijiahaoInfo = $root.BaijiahaoInfo.fromObject(object.baijiahaoInfo);
        }
        if (object.birthdayInfo != null) {
            if (typeof object.birthdayInfo !== "object")
                throw TypeError(".User.birthdayInfo: object expected");
            message.birthdayInfo = $root.BirthdayInfo.fromObject(object.birthdayInfo);
        }
        if (object.canModifyAvatar != null)
            message.canModifyAvatar = object.canModifyAvatar | 0;
        if (object.modifyAvatarDesc != null)
            message.modifyAvatarDesc = String(object.modifyAvatarDesc);
        if (object.influence != null)
            message.influence = object.influence | 0;
        if (object.levelInfluence != null)
            message.levelInfluence = String(object.levelInfluence);
        if (object.newGodData != null) {
            if (typeof object.newGodData !== "object")
                throw TypeError(".User.newGodData: object expected");
            message.newGodData = $root.NewGodInfo.fromObject(object.newGodData);
        }
        if (object.bawuThrones != null) {
            if (typeof object.bawuThrones !== "object")
                throw TypeError(".User.bawuThrones: object expected");
            message.bawuThrones = $root.BawuThrones.fromObject(object.bawuThrones);
        }
        if (object.callFansInfo != null) {
            if (typeof object.callFansInfo !== "object")
                throw TypeError(".User.callFansInfo: object expected");
            message.callFansInfo = $root.CallFansInfo.fromObject(object.callFansInfo);
        }
        if (object.bazhuGrade != null) {
            if (typeof object.bazhuGrade !== "object")
                throw TypeError(".User.bazhuGrade: object expected");
            message.bazhuGrade = $root.BazhuSign.fromObject(object.bazhuGrade);
        }
        if (object.isDefaultAvatar != null)
            message.isDefaultAvatar = object.isDefaultAvatar | 0;
        if (object.uk != null)
            message.uk = String(object.uk);
        if (object.creationData != null) {
            if (typeof object.creationData !== "object")
                throw TypeError(".User.creationData: object expected");
            message.creationData = $root.CreationData.fromObject(object.creationData);
        }
        if (object.favoriteNum != null)
            message.favoriteNum = object.favoriteNum | 0;
        if (object.liveRoomInfo != null) {
            if (typeof object.liveRoomInfo !== "object")
                throw TypeError(".User.liveRoomInfo: object expected");
            message.liveRoomInfo = $root.LiveRoomInfo.fromObject(object.liveRoomInfo);
        }
        if (object.businessAccountInfo != null) {
            if (typeof object.businessAccountInfo !== "object")
                throw TypeError(".User.businessAccountInfo: object expected");
            message.businessAccountInfo = $root.BusinessAccountInfo.fromObject(object.businessAccountInfo);
        }
        if (object.appealThreadPopover != null)
            message.appealThreadPopover = String(object.appealThreadPopover);
        if (object.forumToolAuth) {
            if (!Array.isArray(object.forumToolAuth))
                throw TypeError(".User.forumToolAuth: array expected");
            message.forumToolAuth = [];
            for (let i = 0; i < object.forumToolAuth.length; ++i) {
                if (typeof object.forumToolAuth[i] !== "object")
                    throw TypeError(".User.forumToolAuth: object expected");
                message.forumToolAuth[i] = $root.ForumToolPerm.fromObject(object.forumToolAuth[i]);
            }
        }
        if (object.workNum != null)
            message.workNum = object.workNum >>> 0;
        if (object.showPbPrivateFlag != null)
            message.showPbPrivateFlag = object.showPbPrivateFlag | 0;
        if (object.totalAgreeNum != null)
            message.totalAgreeNum = object.totalAgreeNum >>> 0;
        if (object.workcreationData != null) {
            if (typeof object.workcreationData !== "object")
                throw TypeError(".User.workcreationData: object expected");
            message.workcreationData = $root.CreationData.fromObject(object.workcreationData);
        }
        if (object.tiebaUid != null)
            message.tiebaUid = String(object.tiebaUid);
        if (object.followFrom != null)
            message.followFrom = String(object.followFrom);
        if (object.managerForum) {
            if (!Array.isArray(object.managerForum))
                throw TypeError(".User.managerForum: array expected");
            message.managerForum = [];
            for (let i = 0; i < object.managerForum.length; ++i) {
                if (typeof object.managerForum[i] !== "object")
                    throw TypeError(".User.managerForum: object expected");
                message.managerForum[i] = $root.BazhuSign.fromObject(object.managerForum[i]);
            }
        }
        if (object.displayAuthType != null)
            message.displayAuthType = object.displayAuthType | 0;
        if (object.workCreatorInfo != null) {
            if (typeof object.workCreatorInfo !== "object")
                throw TypeError(".User.workCreatorInfo: object expected");
            message.workCreatorInfo = $root.WorkCreatorInfo.fromObject(object.workCreatorInfo);
        }
        if (object.levelName != null)
            message.levelName = String(object.levelName);
        if (object.editConfig != null) {
            if (typeof object.editConfig !== "object")
                throw TypeError(".User.editConfig: object expected");
            message.editConfig = $root.EditConfig.fromObject(object.editConfig);
        }
        if (object.ipAddress != null)
            message.ipAddress = String(object.ipAddress);
        if (object.isNicknameEditing != null)
            message.isNicknameEditing = object.isNicknameEditing | 0;
        if (object.editingNickname != null)
            message.editingNickname = String(object.editingNickname);
        if (object.virtualImageInfo != null) {
            if (typeof object.virtualImageInfo !== "object")
                throw TypeError(".User.virtualImageInfo: object expected");
            message.virtualImageInfo = $root.VirtualImageInfo.fromObject(object.virtualImageInfo);
        }
        if (object.displayIntro != null)
            message.displayIntro = String(object.displayIntro);
        if (object.themeTail != null) {
            if (typeof object.themeTail !== "object")
                throw TypeError(".User.themeTail: object expected");
            message.themeTail = $root.ThemeTailInUser.fromObject(object.themeTail);
        }
        if (object.shakeAdSwitch != null) {
            if (typeof object.shakeAdSwitch !== "object")
                throw TypeError(".User.shakeAdSwitch: object expected");
            message.shakeAdSwitch = $root.ShakeAdSwitch.fromObject(object.shakeAdSwitch);
        }
        if (object.iosBUrl != null)
            message.iosBUrl = String(object.iosBUrl);
        if (object.pa != null)
            if ($util.Long)
                (message.pa = $util.Long.fromValue(object.pa)).unsigned = false;
            else if (typeof object.pa === "string")
                message.pa = parseInt(object.pa, 10);
            else if (typeof object.pa === "number")
                message.pa = object.pa;
            else if (typeof object.pa === "object")
                message.pa = new $util.LongBits(object.pa.low >>> 0, object.pa.high >>> 0).toNumber();
        if (object.enableNewHomepage != null)
            message.enableNewHomepage = object.enableNewHomepage | 0;
        if (object.targetScheme != null)
            message.targetScheme = String(object.targetScheme);
        return message;
    };

    /**
     * Creates a plain object from a User message. Also converts values to other types if specified.
     * @function toObject
     * @memberof User
     * @static
     * @param {User} message User
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    User.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.iconinfo = [];
            object.tshowIcon = [];
            object.userPics = [];
            object.likeForum = [];
            object.groupList = [];
            object.giftList = [];
            object.muteUser = [];
            object.newTshowIcon = [];
            object.profitList = [];
            object.forumToolAuth = [];
            object.managerForum = [];
        }
        if (options.defaults) {
            object.isLogin = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
            object.nameShow = "";
            object.portrait = "";
            object.noUn = 0;
            object.type = 0;
            object.newUserInfo = null;
            object.userhide = 0;
            object.balv = null;
            object.isManager = 0;
            object.rank = "";
            object.bimgUrl = "";
            object.meizhiLevel = 0;
            object.isVerify = 0;
            object.isInterestman = 0;
            object.userType = 0;
            object.isCoreuser = 0;
            object.isHuinibuke = 0;
            object.iosBimgFormat = "";
            object.levelId = 0;
            object.isLike = 0;
            object.isBawu = 0;
            object.bawuType = "";
            object.portraith = "";
            object.ip = "";
            object.BDUSS = "";
            object.fansNum = 0;
            object.concernNum = 0;
            object.sex = 0;
            object.myLikeNum = 0;
            object.intro = "";
            object.hasConcerned = 0;
            object.passwd = "";
            object.postNum = 0;
            object.tbAge = "";
            object.isMem = 0;
            object.bimgEndTime = 0;
            object.payMemberInfo = null;
            object.gender = 0;
            object.isMask = 0;
            object.privSets = null;
            object.isFriend = 0;
            object.giftNum = 0;
            object.isSelectTail = 0;
            object.isGuanfang = 0;
            object.bookmarkCount = 0;
            object.bookmarkNewCount = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.friendNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.friendNum = options.longs === String ? "0" : 0;
            object.fansNickname = "";
            object.bgPic = "";
            object.parrScores = null;
            object.novelFansInfo = null;
            object.vipInfo = null;
            object.godData = null;
            object.heavyUser = 0;
            object.vipShowInfo = null;
            object.twAnchorInfo = null;
            object.consumeInfo = null;
            object.themeCard = null;
            object.vipCloseAd = null;
            object.activitySponsor = null;
            object.tbVip = null;
            object.noPostHigh = 0;
            object.ecom = null;
            object.visitorNum = 0;
            object.totalVisitorNum = 0;
            object.pendant = null;
            object.alaInfo = null;
            object.sealPrefix = "";
            object.hasBottleEnter = 0;
            object.videoChannelInfo = null;
            object.springVirtualUser = null;
            object.eachOtherFriend = 0;
            object.esportData = null;
            object.alaLiveInfo = null;
            object.nicknameUpdateTime = 0;
            object.threadNum = 0;
            object.agreeNum = 0;
            object.leftCallNum = 0;
            object.isInvited = 0;
            object.isFans = 0;
            object.privThread = 0;
            object.isVideobiggie = 0;
            object.isShowRedpacket = 0;
            object.baijiahaoInfo = null;
            object.birthdayInfo = null;
            object.canModifyAvatar = 0;
            object.modifyAvatarDesc = "";
            object.influence = 0;
            object.levelInfluence = "";
            object.newGodData = null;
            object.bawuThrones = null;
            object.callFansInfo = null;
            object.bazhuGrade = null;
            object.isDefaultAvatar = 0;
            object.uk = "";
            object.creationData = null;
            object.favoriteNum = 0;
            object.liveRoomInfo = null;
            object.businessAccountInfo = null;
            object.appealThreadPopover = "";
            object.workNum = 0;
            object.showPbPrivateFlag = 0;
            object.totalAgreeNum = 0;
            object.workcreationData = null;
            object.tiebaUid = "";
            object.followFrom = "";
            object.displayAuthType = 0;
            object.workCreatorInfo = null;
            object.levelName = "";
            object.editConfig = null;
            object.ipAddress = "";
            object.isNicknameEditing = 0;
            object.editingNickname = "";
            object.virtualImageInfo = null;
            object.displayIntro = "";
            object.themeTail = null;
            object.shakeAdSwitch = null;
            object.iosBUrl = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.pa = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.pa = options.longs === String ? "0" : 0;
            object.enableNewHomepage = 0;
            object.targetScheme = "";
        }
        if (message.isLogin != null && message.hasOwnProperty("isLogin"))
            object.isLogin = message.isLogin;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.nameShow != null && message.hasOwnProperty("nameShow"))
            object.nameShow = message.nameShow;
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            object.portrait = message.portrait;
        if (message.noUn != null && message.hasOwnProperty("noUn"))
            object.noUn = message.noUn;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.newUserInfo != null && message.hasOwnProperty("newUserInfo"))
            object.newUserInfo = $root.NewUser.toObject(message.newUserInfo, options);
        if (message.userhide != null && message.hasOwnProperty("userhide"))
            object.userhide = message.userhide;
        if (message.balv != null && message.hasOwnProperty("balv"))
            object.balv = $root.Balv.toObject(message.balv, options);
        if (message.isManager != null && message.hasOwnProperty("isManager"))
            object.isManager = message.isManager;
        if (message.rank != null && message.hasOwnProperty("rank"))
            object.rank = message.rank;
        if (message.bimgUrl != null && message.hasOwnProperty("bimgUrl"))
            object.bimgUrl = message.bimgUrl;
        if (message.meizhiLevel != null && message.hasOwnProperty("meizhiLevel"))
            object.meizhiLevel = message.meizhiLevel;
        if (message.isVerify != null && message.hasOwnProperty("isVerify"))
            object.isVerify = message.isVerify;
        if (message.isInterestman != null && message.hasOwnProperty("isInterestman"))
            object.isInterestman = message.isInterestman;
        if (message.iconinfo && message.iconinfo.length) {
            object.iconinfo = [];
            for (let j = 0; j < message.iconinfo.length; ++j)
                object.iconinfo[j] = $root.Icon.toObject(message.iconinfo[j], options);
        }
        if (message.tshowIcon && message.tshowIcon.length) {
            object.tshowIcon = [];
            for (let j = 0; j < message.tshowIcon.length; ++j)
                object.tshowIcon[j] = $root.TshowInfo.toObject(message.tshowIcon[j], options);
        }
        if (message.userType != null && message.hasOwnProperty("userType"))
            object.userType = message.userType;
        if (message.isCoreuser != null && message.hasOwnProperty("isCoreuser"))
            object.isCoreuser = message.isCoreuser;
        if (message.isHuinibuke != null && message.hasOwnProperty("isHuinibuke"))
            object.isHuinibuke = message.isHuinibuke;
        if (message.iosBimgFormat != null && message.hasOwnProperty("iosBimgFormat"))
            object.iosBimgFormat = message.iosBimgFormat;
        if (message.levelId != null && message.hasOwnProperty("levelId"))
            object.levelId = message.levelId;
        if (message.isLike != null && message.hasOwnProperty("isLike"))
            object.isLike = message.isLike;
        if (message.isBawu != null && message.hasOwnProperty("isBawu"))
            object.isBawu = message.isBawu;
        if (message.bawuType != null && message.hasOwnProperty("bawuType"))
            object.bawuType = message.bawuType;
        if (message.portraith != null && message.hasOwnProperty("portraith"))
            object.portraith = message.portraith;
        if (message.ip != null && message.hasOwnProperty("ip"))
            object.ip = message.ip;
        if (message.BDUSS != null && message.hasOwnProperty("BDUSS"))
            object.BDUSS = message.BDUSS;
        if (message.fansNum != null && message.hasOwnProperty("fansNum"))
            object.fansNum = message.fansNum;
        if (message.concernNum != null && message.hasOwnProperty("concernNum"))
            object.concernNum = message.concernNum;
        if (message.sex != null && message.hasOwnProperty("sex"))
            object.sex = message.sex;
        if (message.myLikeNum != null && message.hasOwnProperty("myLikeNum"))
            object.myLikeNum = message.myLikeNum;
        if (message.intro != null && message.hasOwnProperty("intro"))
            object.intro = message.intro;
        if (message.hasConcerned != null && message.hasOwnProperty("hasConcerned"))
            object.hasConcerned = message.hasConcerned;
        if (message.passwd != null && message.hasOwnProperty("passwd"))
            object.passwd = message.passwd;
        if (message.postNum != null && message.hasOwnProperty("postNum"))
            object.postNum = message.postNum;
        if (message.tbAge != null && message.hasOwnProperty("tbAge"))
            object.tbAge = message.tbAge;
        if (message.isMem != null && message.hasOwnProperty("isMem"))
            object.isMem = message.isMem;
        if (message.bimgEndTime != null && message.hasOwnProperty("bimgEndTime"))
            object.bimgEndTime = message.bimgEndTime;
        if (message.payMemberInfo != null && message.hasOwnProperty("payMemberInfo"))
            object.payMemberInfo = $root.PayMemberInfo.toObject(message.payMemberInfo, options);
        if (message.gender != null && message.hasOwnProperty("gender"))
            object.gender = message.gender;
        if (message.isMask != null && message.hasOwnProperty("isMask"))
            object.isMask = message.isMask;
        if (message.userPics && message.userPics.length) {
            object.userPics = [];
            for (let j = 0; j < message.userPics.length; ++j)
                object.userPics[j] = $root.UserPics.toObject(message.userPics[j], options);
        }
        if (message.privSets != null && message.hasOwnProperty("privSets"))
            object.privSets = $root.PrivSets.toObject(message.privSets, options);
        if (message.isFriend != null && message.hasOwnProperty("isFriend"))
            object.isFriend = message.isFriend;
        if (message.likeForum && message.likeForum.length) {
            object.likeForum = [];
            for (let j = 0; j < message.likeForum.length; ++j)
                object.likeForum[j] = $root.LikeForumInfo.toObject(message.likeForum[j], options);
        }
        if (message.groupList && message.groupList.length) {
            object.groupList = [];
            for (let j = 0; j < message.groupList.length; ++j)
                object.groupList[j] = $root.MyGroupInfo.toObject(message.groupList[j], options);
        }
        if (message.giftNum != null && message.hasOwnProperty("giftNum"))
            object.giftNum = message.giftNum;
        if (message.giftList && message.giftList.length) {
            object.giftList = [];
            for (let j = 0; j < message.giftList.length; ++j)
                object.giftList[j] = $root.GiftInfo.toObject(message.giftList[j], options);
        }
        if (message.isSelectTail != null && message.hasOwnProperty("isSelectTail"))
            object.isSelectTail = message.isSelectTail;
        if (message.isGuanfang != null && message.hasOwnProperty("isGuanfang"))
            object.isGuanfang = message.isGuanfang;
        if (message.bookmarkCount != null && message.hasOwnProperty("bookmarkCount"))
            object.bookmarkCount = message.bookmarkCount;
        if (message.bookmarkNewCount != null && message.hasOwnProperty("bookmarkNewCount"))
            object.bookmarkNewCount = message.bookmarkNewCount;
        if (message.muteUser && message.muteUser.length) {
            object.muteUser = [];
            for (let j = 0; j < message.muteUser.length; ++j)
                object.muteUser[j] = $root.SimpleUser.toObject(message.muteUser[j], options);
        }
        if (message.friendNum != null && message.hasOwnProperty("friendNum"))
            if (typeof message.friendNum === "number")
                object.friendNum = options.longs === String ? String(message.friendNum) : message.friendNum;
            else
                object.friendNum = options.longs === String ? $util.Long.prototype.toString.call(message.friendNum) : options.longs === Number ? new $util.LongBits(message.friendNum.low >>> 0, message.friendNum.high >>> 0).toNumber() : message.friendNum;
        if (message.fansNickname != null && message.hasOwnProperty("fansNickname"))
            object.fansNickname = message.fansNickname;
        if (message.bgPic != null && message.hasOwnProperty("bgPic"))
            object.bgPic = message.bgPic;
        if (message.parrScores != null && message.hasOwnProperty("parrScores"))
            object.parrScores = $root.NewParrScores.toObject(message.parrScores, options);
        if (message.novelFansInfo != null && message.hasOwnProperty("novelFansInfo"))
            object.novelFansInfo = $root.NovelFansInfo.toObject(message.novelFansInfo, options);
        if (message.vipInfo != null && message.hasOwnProperty("vipInfo"))
            object.vipInfo = $root.UserVipInfo.toObject(message.vipInfo, options);
        if (message.godData != null && message.hasOwnProperty("godData"))
            object.godData = $root.GodInfo.toObject(message.godData, options);
        if (message.heavyUser != null && message.hasOwnProperty("heavyUser"))
            object.heavyUser = message.heavyUser;
        if (message.vipShowInfo != null && message.hasOwnProperty("vipShowInfo"))
            object.vipShowInfo = $root.VipShowInfo.toObject(message.vipShowInfo, options);
        if (message.newTshowIcon && message.newTshowIcon.length) {
            object.newTshowIcon = [];
            for (let j = 0; j < message.newTshowIcon.length; ++j)
                object.newTshowIcon[j] = $root.TshowInfo.toObject(message.newTshowIcon[j], options);
        }
        if (message.twAnchorInfo != null && message.hasOwnProperty("twAnchorInfo"))
            object.twAnchorInfo = $root.TwZhiBoUser.toObject(message.twAnchorInfo, options);
        if (message.profitList && message.profitList.length) {
            object.profitList = [];
            for (let j = 0; j < message.profitList.length; ++j)
                object.profitList[j] = $root.TwAnchorProfitItem.toObject(message.profitList[j], options);
        }
        if (message.consumeInfo != null && message.hasOwnProperty("consumeInfo"))
            object.consumeInfo = $root.ConsumeInfo.toObject(message.consumeInfo, options);
        if (message.themeCard != null && message.hasOwnProperty("themeCard"))
            object.themeCard = $root.ThemeCardInUser.toObject(message.themeCard, options);
        if (message.vipCloseAd != null && message.hasOwnProperty("vipCloseAd"))
            object.vipCloseAd = $root.VipCloseAd.toObject(message.vipCloseAd, options);
        if (message.activitySponsor != null && message.hasOwnProperty("activitySponsor"))
            object.activitySponsor = $root.ActivitySponsor.toObject(message.activitySponsor, options);
        if (message.tbVip != null && message.hasOwnProperty("tbVip"))
            object.tbVip = $root.TbVipInfo.toObject(message.tbVip, options);
        if (message.noPostHigh != null && message.hasOwnProperty("noPostHigh"))
            object.noPostHigh = message.noPostHigh;
        if (message.ecom != null && message.hasOwnProperty("ecom"))
            object.ecom = $root.Ecom.toObject(message.ecom, options);
        if (message.visitorNum != null && message.hasOwnProperty("visitorNum"))
            object.visitorNum = message.visitorNum;
        if (message.totalVisitorNum != null && message.hasOwnProperty("totalVisitorNum"))
            object.totalVisitorNum = message.totalVisitorNum;
        if (message.pendant != null && message.hasOwnProperty("pendant"))
            object.pendant = $root.Pendant.toObject(message.pendant, options);
        if (message.alaInfo != null && message.hasOwnProperty("alaInfo"))
            object.alaInfo = $root.AlaUserInfo.toObject(message.alaInfo, options);
        if (message.sealPrefix != null && message.hasOwnProperty("sealPrefix"))
            object.sealPrefix = message.sealPrefix;
        if (message.hasBottleEnter != null && message.hasOwnProperty("hasBottleEnter"))
            object.hasBottleEnter = message.hasBottleEnter;
        if (message.videoChannelInfo != null && message.hasOwnProperty("videoChannelInfo"))
            object.videoChannelInfo = $root.UserVideoChannelInfo.toObject(message.videoChannelInfo, options);
        if (message.springVirtualUser != null && message.hasOwnProperty("springVirtualUser"))
            object.springVirtualUser = $root.SpringVirtualUser.toObject(message.springVirtualUser, options);
        if (message.eachOtherFriend != null && message.hasOwnProperty("eachOtherFriend"))
            object.eachOtherFriend = message.eachOtherFriend;
        if (message.esportData != null && message.hasOwnProperty("esportData"))
            object.esportData = $root.EsportInfo.toObject(message.esportData, options);
        if (message.alaLiveInfo != null && message.hasOwnProperty("alaLiveInfo"))
            object.alaLiveInfo = $root.AlaLiveInfo.toObject(message.alaLiveInfo, options);
        if (message.nicknameUpdateTime != null && message.hasOwnProperty("nicknameUpdateTime"))
            object.nicknameUpdateTime = message.nicknameUpdateTime;
        if (message.threadNum != null && message.hasOwnProperty("threadNum"))
            object.threadNum = message.threadNum;
        if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
            object.agreeNum = message.agreeNum;
        if (message.leftCallNum != null && message.hasOwnProperty("leftCallNum"))
            object.leftCallNum = message.leftCallNum;
        if (message.isInvited != null && message.hasOwnProperty("isInvited"))
            object.isInvited = message.isInvited;
        if (message.isFans != null && message.hasOwnProperty("isFans"))
            object.isFans = message.isFans;
        if (message.privThread != null && message.hasOwnProperty("privThread"))
            object.privThread = message.privThread;
        if (message.isVideobiggie != null && message.hasOwnProperty("isVideobiggie"))
            object.isVideobiggie = message.isVideobiggie;
        if (message.isShowRedpacket != null && message.hasOwnProperty("isShowRedpacket"))
            object.isShowRedpacket = message.isShowRedpacket;
        if (message.baijiahaoInfo != null && message.hasOwnProperty("baijiahaoInfo"))
            object.baijiahaoInfo = $root.BaijiahaoInfo.toObject(message.baijiahaoInfo, options);
        if (message.birthdayInfo != null && message.hasOwnProperty("birthdayInfo"))
            object.birthdayInfo = $root.BirthdayInfo.toObject(message.birthdayInfo, options);
        if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
            object.canModifyAvatar = message.canModifyAvatar;
        if (message.modifyAvatarDesc != null && message.hasOwnProperty("modifyAvatarDesc"))
            object.modifyAvatarDesc = message.modifyAvatarDesc;
        if (message.influence != null && message.hasOwnProperty("influence"))
            object.influence = message.influence;
        if (message.levelInfluence != null && message.hasOwnProperty("levelInfluence"))
            object.levelInfluence = message.levelInfluence;
        if (message.newGodData != null && message.hasOwnProperty("newGodData"))
            object.newGodData = $root.NewGodInfo.toObject(message.newGodData, options);
        if (message.bawuThrones != null && message.hasOwnProperty("bawuThrones"))
            object.bawuThrones = $root.BawuThrones.toObject(message.bawuThrones, options);
        if (message.callFansInfo != null && message.hasOwnProperty("callFansInfo"))
            object.callFansInfo = $root.CallFansInfo.toObject(message.callFansInfo, options);
        if (message.bazhuGrade != null && message.hasOwnProperty("bazhuGrade"))
            object.bazhuGrade = $root.BazhuSign.toObject(message.bazhuGrade, options);
        if (message.isDefaultAvatar != null && message.hasOwnProperty("isDefaultAvatar"))
            object.isDefaultAvatar = message.isDefaultAvatar;
        if (message.uk != null && message.hasOwnProperty("uk"))
            object.uk = message.uk;
        if (message.creationData != null && message.hasOwnProperty("creationData"))
            object.creationData = $root.CreationData.toObject(message.creationData, options);
        if (message.favoriteNum != null && message.hasOwnProperty("favoriteNum"))
            object.favoriteNum = message.favoriteNum;
        if (message.liveRoomInfo != null && message.hasOwnProperty("liveRoomInfo"))
            object.liveRoomInfo = $root.LiveRoomInfo.toObject(message.liveRoomInfo, options);
        if (message.businessAccountInfo != null && message.hasOwnProperty("businessAccountInfo"))
            object.businessAccountInfo = $root.BusinessAccountInfo.toObject(message.businessAccountInfo, options);
        if (message.appealThreadPopover != null && message.hasOwnProperty("appealThreadPopover"))
            object.appealThreadPopover = message.appealThreadPopover;
        if (message.forumToolAuth && message.forumToolAuth.length) {
            object.forumToolAuth = [];
            for (let j = 0; j < message.forumToolAuth.length; ++j)
                object.forumToolAuth[j] = $root.ForumToolPerm.toObject(message.forumToolAuth[j], options);
        }
        if (message.workNum != null && message.hasOwnProperty("workNum"))
            object.workNum = message.workNum;
        if (message.showPbPrivateFlag != null && message.hasOwnProperty("showPbPrivateFlag"))
            object.showPbPrivateFlag = message.showPbPrivateFlag;
        if (message.totalAgreeNum != null && message.hasOwnProperty("totalAgreeNum"))
            object.totalAgreeNum = message.totalAgreeNum;
        if (message.workcreationData != null && message.hasOwnProperty("workcreationData"))
            object.workcreationData = $root.CreationData.toObject(message.workcreationData, options);
        if (message.tiebaUid != null && message.hasOwnProperty("tiebaUid"))
            object.tiebaUid = message.tiebaUid;
        if (message.followFrom != null && message.hasOwnProperty("followFrom"))
            object.followFrom = message.followFrom;
        if (message.managerForum && message.managerForum.length) {
            object.managerForum = [];
            for (let j = 0; j < message.managerForum.length; ++j)
                object.managerForum[j] = $root.BazhuSign.toObject(message.managerForum[j], options);
        }
        if (message.displayAuthType != null && message.hasOwnProperty("displayAuthType"))
            object.displayAuthType = message.displayAuthType;
        if (message.workCreatorInfo != null && message.hasOwnProperty("workCreatorInfo"))
            object.workCreatorInfo = $root.WorkCreatorInfo.toObject(message.workCreatorInfo, options);
        if (message.levelName != null && message.hasOwnProperty("levelName"))
            object.levelName = message.levelName;
        if (message.editConfig != null && message.hasOwnProperty("editConfig"))
            object.editConfig = $root.EditConfig.toObject(message.editConfig, options);
        if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
            object.ipAddress = message.ipAddress;
        if (message.isNicknameEditing != null && message.hasOwnProperty("isNicknameEditing"))
            object.isNicknameEditing = message.isNicknameEditing;
        if (message.editingNickname != null && message.hasOwnProperty("editingNickname"))
            object.editingNickname = message.editingNickname;
        if (message.virtualImageInfo != null && message.hasOwnProperty("virtualImageInfo"))
            object.virtualImageInfo = $root.VirtualImageInfo.toObject(message.virtualImageInfo, options);
        if (message.displayIntro != null && message.hasOwnProperty("displayIntro"))
            object.displayIntro = message.displayIntro;
        if (message.themeTail != null && message.hasOwnProperty("themeTail"))
            object.themeTail = $root.ThemeTailInUser.toObject(message.themeTail, options);
        if (message.shakeAdSwitch != null && message.hasOwnProperty("shakeAdSwitch"))
            object.shakeAdSwitch = $root.ShakeAdSwitch.toObject(message.shakeAdSwitch, options);
        if (message.iosBUrl != null && message.hasOwnProperty("iosBUrl"))
            object.iosBUrl = message.iosBUrl;
        if (message.pa != null && message.hasOwnProperty("pa"))
            if (typeof message.pa === "number")
                object.pa = options.longs === String ? String(message.pa) : message.pa;
            else
                object.pa = options.longs === String ? $util.Long.prototype.toString.call(message.pa) : options.longs === Number ? new $util.LongBits(message.pa.low >>> 0, message.pa.high >>> 0).toNumber() : message.pa;
        if (message.enableNewHomepage != null && message.hasOwnProperty("enableNewHomepage"))
            object.enableNewHomepage = message.enableNewHomepage;
        if (message.targetScheme != null && message.hasOwnProperty("targetScheme"))
            object.targetScheme = message.targetScheme;
        return object;
    };

    /**
     * Converts this User to JSON.
     * @function toJSON
     * @memberof User
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    User.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for User
     * @function getTypeUrl
     * @memberof User
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/User";
    };

    return User;
})();

export const ActivitySponsor = $root.ActivitySponsor = (() => {

    /**
     * Properties of an ActivitySponsor.
     * @exports IActivitySponsor
     * @interface IActivitySponsor
     * @property {number|null} [isSponsor] ActivitySponsor isSponsor
     * @property {string|null} [sponsorUrl] ActivitySponsor sponsorUrl
     */

    /**
     * Constructs a new ActivitySponsor.
     * @exports ActivitySponsor
     * @classdesc Represents an ActivitySponsor.
     * @implements IActivitySponsor
     * @constructor
     * @param {IActivitySponsor=} [properties] Properties to set
     */
    function ActivitySponsor(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ActivitySponsor isSponsor.
     * @member {number} isSponsor
     * @memberof ActivitySponsor
     * @instance
     */
    ActivitySponsor.prototype.isSponsor = 0;

    /**
     * ActivitySponsor sponsorUrl.
     * @member {string} sponsorUrl
     * @memberof ActivitySponsor
     * @instance
     */
    ActivitySponsor.prototype.sponsorUrl = "";

    /**
     * Creates a new ActivitySponsor instance using the specified properties.
     * @function create
     * @memberof ActivitySponsor
     * @static
     * @param {IActivitySponsor=} [properties] Properties to set
     * @returns {ActivitySponsor} ActivitySponsor instance
     */
    ActivitySponsor.create = function create(properties) {
        return new ActivitySponsor(properties);
    };

    /**
     * Encodes the specified ActivitySponsor message. Does not implicitly {@link ActivitySponsor.verify|verify} messages.
     * @function encode
     * @memberof ActivitySponsor
     * @static
     * @param {IActivitySponsor} message ActivitySponsor message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ActivitySponsor.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isSponsor != null && Object.hasOwnProperty.call(message, "isSponsor"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isSponsor);
        if (message.sponsorUrl != null && Object.hasOwnProperty.call(message, "sponsorUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sponsorUrl);
        return writer;
    };

    /**
     * Encodes the specified ActivitySponsor message, length delimited. Does not implicitly {@link ActivitySponsor.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ActivitySponsor
     * @static
     * @param {IActivitySponsor} message ActivitySponsor message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ActivitySponsor.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ActivitySponsor message from the specified reader or buffer.
     * @function decode
     * @memberof ActivitySponsor
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ActivitySponsor} ActivitySponsor
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ActivitySponsor.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivitySponsor();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isSponsor = reader.int32();
                    break;
                }
            case 2: {
                    message.sponsorUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ActivitySponsor message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ActivitySponsor
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ActivitySponsor} ActivitySponsor
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ActivitySponsor.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ActivitySponsor message.
     * @function verify
     * @memberof ActivitySponsor
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ActivitySponsor.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isSponsor != null && message.hasOwnProperty("isSponsor"))
            if (!$util.isInteger(message.isSponsor))
                return "isSponsor: integer expected";
        if (message.sponsorUrl != null && message.hasOwnProperty("sponsorUrl"))
            if (!$util.isString(message.sponsorUrl))
                return "sponsorUrl: string expected";
        return null;
    };

    /**
     * Creates an ActivitySponsor message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ActivitySponsor
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ActivitySponsor} ActivitySponsor
     */
    ActivitySponsor.fromObject = function fromObject(object) {
        if (object instanceof $root.ActivitySponsor)
            return object;
        let message = new $root.ActivitySponsor();
        if (object.isSponsor != null)
            message.isSponsor = object.isSponsor | 0;
        if (object.sponsorUrl != null)
            message.sponsorUrl = String(object.sponsorUrl);
        return message;
    };

    /**
     * Creates a plain object from an ActivitySponsor message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ActivitySponsor
     * @static
     * @param {ActivitySponsor} message ActivitySponsor
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ActivitySponsor.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.isSponsor = 0;
            object.sponsorUrl = "";
        }
        if (message.isSponsor != null && message.hasOwnProperty("isSponsor"))
            object.isSponsor = message.isSponsor;
        if (message.sponsorUrl != null && message.hasOwnProperty("sponsorUrl"))
            object.sponsorUrl = message.sponsorUrl;
        return object;
    };

    /**
     * Converts this ActivitySponsor to JSON.
     * @function toJSON
     * @memberof ActivitySponsor
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ActivitySponsor.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ActivitySponsor
     * @function getTypeUrl
     * @memberof ActivitySponsor
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ActivitySponsor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ActivitySponsor";
    };

    return ActivitySponsor;
})();

export const AlaLiveInfo = $root.AlaLiveInfo = (() => {

    /**
     * Properties of an AlaLiveInfo.
     * @exports IAlaLiveInfo
     * @interface IAlaLiveInfo
     * @property {number|Long|null} [liveId] AlaLiveInfo liveId
     * @property {string|null} [cover] AlaLiveInfo cover
     * @property {string|null} [sessionId] AlaLiveInfo sessionId
     * @property {string|null} [rtmpUrl] AlaLiveInfo rtmpUrl
     * @property {string|null} [hlsUrl] AlaLiveInfo hlsUrl
     * @property {number|Long|null} [groupId] AlaLiveInfo groupId
     * @property {string|null} [mediaUrl] AlaLiveInfo mediaUrl
     * @property {string|null} [mediaPic] AlaLiveInfo mediaPic
     * @property {string|null} [mediaId] AlaLiveInfo mediaId
     * @property {string|null} [mediaSubtitle] AlaLiveInfo mediaSubtitle
     * @property {string|null} [description] AlaLiveInfo description
     * @property {IAlaUserInfo|null} [userInfo] AlaLiveInfo userInfo
     * @property {number|null} [duration] AlaLiveInfo duration
     * @property {number|null} [audienceCount] AlaLiveInfo audienceCount
     * @property {number|null} [liveType] AlaLiveInfo liveType
     * @property {number|null} [screenDirection] AlaLiveInfo screenDirection
     * @property {string|null} [labelName] AlaLiveInfo labelName
     * @property {number|null} [liveStatus] AlaLiveInfo liveStatus
     * @property {IAlaShareInfo|null} [shareInfo] AlaLiveInfo shareInfo
     * @property {number|Long|null} [distance] AlaLiveInfo distance
     * @property {string|null} [thirdAppId] AlaLiveInfo thirdAppId
     * @property {number|Long|null} [threadId] AlaLiveInfo threadId
     * @property {Array.<IAlaStageDislikeInfo>|null} [stageDislikeInfo] AlaLiveInfo stageDislikeInfo
     * @property {IAlaCoverLabel|null} [label] AlaLiveInfo label
     * @property {IAlaChallengeInfo|null} [challengeInfo] AlaLiveInfo challengeInfo
     * @property {number|null} [frsTopliveType] AlaLiveInfo frsTopliveType
     * @property {string|null} [frsToplivePic] AlaLiveInfo frsToplivePic
     * @property {number|null} [frsTopliveForce] AlaLiveInfo frsTopliveForce
     * @property {number|null} [liveFrom] AlaLiveInfo liveFrom
     * @property {string|null} [thirdRoomId] AlaLiveInfo thirdRoomId
     * @property {string|null} [routerType] AlaLiveInfo routerType
     * @property {string|null} [thirdLiveType] AlaLiveInfo thirdLiveType
     * @property {string|null} [firstHeadline] AlaLiveInfo firstHeadline
     * @property {string|null} [secondHeadline] AlaLiveInfo secondHeadline
     * @property {number|null} [pbDisplayType] AlaLiveInfo pbDisplayType
     * @property {string|null} [recomReason] AlaLiveInfo recomReason
     * @property {number|null} [openRecomReason] AlaLiveInfo openRecomReason
     * @property {number|null} [openRecomLocation] AlaLiveInfo openRecomLocation
     * @property {number|null} [openRecomFans] AlaLiveInfo openRecomFans
     * @property {number|null} [openRecomDuration] AlaLiveInfo openRecomDuration
     * @property {Array.<IDislikeInfo>|null} [dislikeInfo] AlaLiveInfo dislikeInfo
     * @property {number|Long|null} [roomId] AlaLiveInfo roomId
     * @property {number|null} [roomStatus] AlaLiveInfo roomStatus
     * @property {string|null} [roomName] AlaLiveInfo roomName
     * @property {string|null} [forumUserLiveMsg] AlaLiveInfo forumUserLiveMsg
     * @property {string|null} [coverWide] AlaLiveInfo coverWide
     * @property {IYyExt|null} [yyExt] AlaLiveInfo yyExt
     * @property {number|null} [showPage] AlaLiveInfo showPage
     * @property {IUniversalLabel|null} [userLabel] AlaLiveInfo userLabel
     * @property {string|null} [flv] AlaLiveInfo flv
     * @property {number|null} [pageFrom] AlaLiveInfo pageFrom
     * @property {string|null} [scheme] AlaLiveInfo scheme
     * @property {IWidthHeight|null} [playerSize] AlaLiveInfo playerSize
     * @property {IWidthHeight|null} [containerSize] AlaLiveInfo containerSize
     */

    /**
     * Constructs a new AlaLiveInfo.
     * @exports AlaLiveInfo
     * @classdesc Represents an AlaLiveInfo.
     * @implements IAlaLiveInfo
     * @constructor
     * @param {IAlaLiveInfo=} [properties] Properties to set
     */
    function AlaLiveInfo(properties) {
        this.stageDislikeInfo = [];
        this.dislikeInfo = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AlaLiveInfo liveId.
     * @member {number|Long} liveId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.liveId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaLiveInfo cover.
     * @member {string} cover
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.cover = "";

    /**
     * AlaLiveInfo sessionId.
     * @member {string} sessionId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.sessionId = "";

    /**
     * AlaLiveInfo rtmpUrl.
     * @member {string} rtmpUrl
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.rtmpUrl = "";

    /**
     * AlaLiveInfo hlsUrl.
     * @member {string} hlsUrl
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.hlsUrl = "";

    /**
     * AlaLiveInfo groupId.
     * @member {number|Long} groupId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaLiveInfo mediaUrl.
     * @member {string} mediaUrl
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.mediaUrl = "";

    /**
     * AlaLiveInfo mediaPic.
     * @member {string} mediaPic
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.mediaPic = "";

    /**
     * AlaLiveInfo mediaId.
     * @member {string} mediaId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.mediaId = "";

    /**
     * AlaLiveInfo mediaSubtitle.
     * @member {string} mediaSubtitle
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.mediaSubtitle = "";

    /**
     * AlaLiveInfo description.
     * @member {string} description
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.description = "";

    /**
     * AlaLiveInfo userInfo.
     * @member {IAlaUserInfo|null|undefined} userInfo
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.userInfo = null;

    /**
     * AlaLiveInfo duration.
     * @member {number} duration
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.duration = 0;

    /**
     * AlaLiveInfo audienceCount.
     * @member {number} audienceCount
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.audienceCount = 0;

    /**
     * AlaLiveInfo liveType.
     * @member {number} liveType
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.liveType = 0;

    /**
     * AlaLiveInfo screenDirection.
     * @member {number} screenDirection
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.screenDirection = 0;

    /**
     * AlaLiveInfo labelName.
     * @member {string} labelName
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.labelName = "";

    /**
     * AlaLiveInfo liveStatus.
     * @member {number} liveStatus
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.liveStatus = 0;

    /**
     * AlaLiveInfo shareInfo.
     * @member {IAlaShareInfo|null|undefined} shareInfo
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.shareInfo = null;

    /**
     * AlaLiveInfo distance.
     * @member {number|Long} distance
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.distance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaLiveInfo thirdAppId.
     * @member {string} thirdAppId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.thirdAppId = "";

    /**
     * AlaLiveInfo threadId.
     * @member {number|Long} threadId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.threadId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaLiveInfo stageDislikeInfo.
     * @member {Array.<IAlaStageDislikeInfo>} stageDislikeInfo
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.stageDislikeInfo = $util.emptyArray;

    /**
     * AlaLiveInfo label.
     * @member {IAlaCoverLabel|null|undefined} label
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.label = null;

    /**
     * AlaLiveInfo challengeInfo.
     * @member {IAlaChallengeInfo|null|undefined} challengeInfo
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.challengeInfo = null;

    /**
     * AlaLiveInfo frsTopliveType.
     * @member {number} frsTopliveType
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.frsTopliveType = 0;

    /**
     * AlaLiveInfo frsToplivePic.
     * @member {string} frsToplivePic
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.frsToplivePic = "";

    /**
     * AlaLiveInfo frsTopliveForce.
     * @member {number} frsTopliveForce
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.frsTopliveForce = 0;

    /**
     * AlaLiveInfo liveFrom.
     * @member {number} liveFrom
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.liveFrom = 0;

    /**
     * AlaLiveInfo thirdRoomId.
     * @member {string} thirdRoomId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.thirdRoomId = "";

    /**
     * AlaLiveInfo routerType.
     * @member {string} routerType
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.routerType = "";

    /**
     * AlaLiveInfo thirdLiveType.
     * @member {string} thirdLiveType
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.thirdLiveType = "";

    /**
     * AlaLiveInfo firstHeadline.
     * @member {string} firstHeadline
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.firstHeadline = "";

    /**
     * AlaLiveInfo secondHeadline.
     * @member {string} secondHeadline
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.secondHeadline = "";

    /**
     * AlaLiveInfo pbDisplayType.
     * @member {number} pbDisplayType
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.pbDisplayType = 0;

    /**
     * AlaLiveInfo recomReason.
     * @member {string} recomReason
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.recomReason = "";

    /**
     * AlaLiveInfo openRecomReason.
     * @member {number} openRecomReason
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.openRecomReason = 0;

    /**
     * AlaLiveInfo openRecomLocation.
     * @member {number} openRecomLocation
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.openRecomLocation = 0;

    /**
     * AlaLiveInfo openRecomFans.
     * @member {number} openRecomFans
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.openRecomFans = 0;

    /**
     * AlaLiveInfo openRecomDuration.
     * @member {number} openRecomDuration
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.openRecomDuration = 0;

    /**
     * AlaLiveInfo dislikeInfo.
     * @member {Array.<IDislikeInfo>} dislikeInfo
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.dislikeInfo = $util.emptyArray;

    /**
     * AlaLiveInfo roomId.
     * @member {number|Long} roomId
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.roomId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaLiveInfo roomStatus.
     * @member {number} roomStatus
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.roomStatus = 0;

    /**
     * AlaLiveInfo roomName.
     * @member {string} roomName
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.roomName = "";

    /**
     * AlaLiveInfo forumUserLiveMsg.
     * @member {string} forumUserLiveMsg
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.forumUserLiveMsg = "";

    /**
     * AlaLiveInfo coverWide.
     * @member {string} coverWide
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.coverWide = "";

    /**
     * AlaLiveInfo yyExt.
     * @member {IYyExt|null|undefined} yyExt
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.yyExt = null;

    /**
     * AlaLiveInfo showPage.
     * @member {number} showPage
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.showPage = 0;

    /**
     * AlaLiveInfo userLabel.
     * @member {IUniversalLabel|null|undefined} userLabel
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.userLabel = null;

    /**
     * AlaLiveInfo flv.
     * @member {string} flv
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.flv = "";

    /**
     * AlaLiveInfo pageFrom.
     * @member {number} pageFrom
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.pageFrom = 0;

    /**
     * AlaLiveInfo scheme.
     * @member {string} scheme
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.scheme = "";

    /**
     * AlaLiveInfo playerSize.
     * @member {IWidthHeight|null|undefined} playerSize
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.playerSize = null;

    /**
     * AlaLiveInfo containerSize.
     * @member {IWidthHeight|null|undefined} containerSize
     * @memberof AlaLiveInfo
     * @instance
     */
    AlaLiveInfo.prototype.containerSize = null;

    /**
     * Creates a new AlaLiveInfo instance using the specified properties.
     * @function create
     * @memberof AlaLiveInfo
     * @static
     * @param {IAlaLiveInfo=} [properties] Properties to set
     * @returns {AlaLiveInfo} AlaLiveInfo instance
     */
    AlaLiveInfo.create = function create(properties) {
        return new AlaLiveInfo(properties);
    };

    /**
     * Encodes the specified AlaLiveInfo message. Does not implicitly {@link AlaLiveInfo.verify|verify} messages.
     * @function encode
     * @memberof AlaLiveInfo
     * @static
     * @param {IAlaLiveInfo} message AlaLiveInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaLiveInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.liveId != null && Object.hasOwnProperty.call(message, "liveId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.liveId);
        if (message.cover != null && Object.hasOwnProperty.call(message, "cover"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.cover);
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.sessionId);
        if (message.rtmpUrl != null && Object.hasOwnProperty.call(message, "rtmpUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.rtmpUrl);
        if (message.hlsUrl != null && Object.hasOwnProperty.call(message, "hlsUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.hlsUrl);
        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.groupId);
        if (message.mediaUrl != null && Object.hasOwnProperty.call(message, "mediaUrl"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.mediaUrl);
        if (message.mediaPic != null && Object.hasOwnProperty.call(message, "mediaPic"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.mediaPic);
        if (message.mediaId != null && Object.hasOwnProperty.call(message, "mediaId"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.mediaId);
        if (message.mediaSubtitle != null && Object.hasOwnProperty.call(message, "mediaSubtitle"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.mediaSubtitle);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.description);
        if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
            $root.AlaUserInfo.encode(message.userInfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.duration);
        if (message.audienceCount != null && Object.hasOwnProperty.call(message, "audienceCount"))
            writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.audienceCount);
        if (message.liveType != null && Object.hasOwnProperty.call(message, "liveType"))
            writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.liveType);
        if (message.screenDirection != null && Object.hasOwnProperty.call(message, "screenDirection"))
            writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.screenDirection);
        if (message.labelName != null && Object.hasOwnProperty.call(message, "labelName"))
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.labelName);
        if (message.liveStatus != null && Object.hasOwnProperty.call(message, "liveStatus"))
            writer.uint32(/* id 18, wireType 0 =*/144).int32(message.liveStatus);
        if (message.shareInfo != null && Object.hasOwnProperty.call(message, "shareInfo"))
            $root.AlaShareInfo.encode(message.shareInfo, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
        if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
            writer.uint32(/* id 20, wireType 0 =*/160).uint64(message.distance);
        if (message.thirdAppId != null && Object.hasOwnProperty.call(message, "thirdAppId"))
            writer.uint32(/* id 21, wireType 2 =*/170).string(message.thirdAppId);
        if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
            writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.threadId);
        if (message.stageDislikeInfo != null && message.stageDislikeInfo.length)
            for (let i = 0; i < message.stageDislikeInfo.length; ++i)
                $root.AlaStageDislikeInfo.encode(message.stageDislikeInfo[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            $root.AlaCoverLabel.encode(message.label, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
        if (message.challengeInfo != null && Object.hasOwnProperty.call(message, "challengeInfo"))
            $root.AlaChallengeInfo.encode(message.challengeInfo, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
        if (message.frsTopliveType != null && Object.hasOwnProperty.call(message, "frsTopliveType"))
            writer.uint32(/* id 26, wireType 0 =*/208).int32(message.frsTopliveType);
        if (message.frsToplivePic != null && Object.hasOwnProperty.call(message, "frsToplivePic"))
            writer.uint32(/* id 27, wireType 2 =*/218).string(message.frsToplivePic);
        if (message.frsTopliveForce != null && Object.hasOwnProperty.call(message, "frsTopliveForce"))
            writer.uint32(/* id 28, wireType 0 =*/224).int32(message.frsTopliveForce);
        if (message.liveFrom != null && Object.hasOwnProperty.call(message, "liveFrom"))
            writer.uint32(/* id 29, wireType 0 =*/232).int32(message.liveFrom);
        if (message.thirdRoomId != null && Object.hasOwnProperty.call(message, "thirdRoomId"))
            writer.uint32(/* id 31, wireType 2 =*/250).string(message.thirdRoomId);
        if (message.routerType != null && Object.hasOwnProperty.call(message, "routerType"))
            writer.uint32(/* id 32, wireType 2 =*/258).string(message.routerType);
        if (message.thirdLiveType != null && Object.hasOwnProperty.call(message, "thirdLiveType"))
            writer.uint32(/* id 33, wireType 2 =*/266).string(message.thirdLiveType);
        if (message.firstHeadline != null && Object.hasOwnProperty.call(message, "firstHeadline"))
            writer.uint32(/* id 34, wireType 2 =*/274).string(message.firstHeadline);
        if (message.secondHeadline != null && Object.hasOwnProperty.call(message, "secondHeadline"))
            writer.uint32(/* id 35, wireType 2 =*/282).string(message.secondHeadline);
        if (message.pbDisplayType != null && Object.hasOwnProperty.call(message, "pbDisplayType"))
            writer.uint32(/* id 36, wireType 0 =*/288).uint32(message.pbDisplayType);
        if (message.recomReason != null && Object.hasOwnProperty.call(message, "recomReason"))
            writer.uint32(/* id 37, wireType 2 =*/298).string(message.recomReason);
        if (message.openRecomReason != null && Object.hasOwnProperty.call(message, "openRecomReason"))
            writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.openRecomReason);
        if (message.openRecomLocation != null && Object.hasOwnProperty.call(message, "openRecomLocation"))
            writer.uint32(/* id 39, wireType 0 =*/312).uint32(message.openRecomLocation);
        if (message.openRecomFans != null && Object.hasOwnProperty.call(message, "openRecomFans"))
            writer.uint32(/* id 40, wireType 0 =*/320).uint32(message.openRecomFans);
        if (message.openRecomDuration != null && Object.hasOwnProperty.call(message, "openRecomDuration"))
            writer.uint32(/* id 41, wireType 0 =*/328).uint32(message.openRecomDuration);
        if (message.dislikeInfo != null && message.dislikeInfo.length)
            for (let i = 0; i < message.dislikeInfo.length; ++i)
                $root.DislikeInfo.encode(message.dislikeInfo[i], writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
        if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
            writer.uint32(/* id 44, wireType 0 =*/352).uint64(message.roomId);
        if (message.roomStatus != null && Object.hasOwnProperty.call(message, "roomStatus"))
            writer.uint32(/* id 45, wireType 0 =*/360).int32(message.roomStatus);
        if (message.roomName != null && Object.hasOwnProperty.call(message, "roomName"))
            writer.uint32(/* id 46, wireType 2 =*/370).string(message.roomName);
        if (message.forumUserLiveMsg != null && Object.hasOwnProperty.call(message, "forumUserLiveMsg"))
            writer.uint32(/* id 47, wireType 2 =*/378).string(message.forumUserLiveMsg);
        if (message.coverWide != null && Object.hasOwnProperty.call(message, "coverWide"))
            writer.uint32(/* id 48, wireType 2 =*/386).string(message.coverWide);
        if (message.yyExt != null && Object.hasOwnProperty.call(message, "yyExt"))
            $root.YyExt.encode(message.yyExt, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
        if (message.showPage != null && Object.hasOwnProperty.call(message, "showPage"))
            writer.uint32(/* id 50, wireType 0 =*/400).int32(message.showPage);
        if (message.userLabel != null && Object.hasOwnProperty.call(message, "userLabel"))
            $root.UniversalLabel.encode(message.userLabel, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
        if (message.flv != null && Object.hasOwnProperty.call(message, "flv"))
            writer.uint32(/* id 52, wireType 2 =*/418).string(message.flv);
        if (message.pageFrom != null && Object.hasOwnProperty.call(message, "pageFrom"))
            writer.uint32(/* id 54, wireType 0 =*/432).int32(message.pageFrom);
        if (message.scheme != null && Object.hasOwnProperty.call(message, "scheme"))
            writer.uint32(/* id 55, wireType 2 =*/442).string(message.scheme);
        if (message.playerSize != null && Object.hasOwnProperty.call(message, "playerSize"))
            $root.WidthHeight.encode(message.playerSize, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
        if (message.containerSize != null && Object.hasOwnProperty.call(message, "containerSize"))
            $root.WidthHeight.encode(message.containerSize, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AlaLiveInfo message, length delimited. Does not implicitly {@link AlaLiveInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AlaLiveInfo
     * @static
     * @param {IAlaLiveInfo} message AlaLiveInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaLiveInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AlaLiveInfo message from the specified reader or buffer.
     * @function decode
     * @memberof AlaLiveInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AlaLiveInfo} AlaLiveInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaLiveInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlaLiveInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.liveId = reader.uint64();
                    break;
                }
            case 2: {
                    message.cover = reader.string();
                    break;
                }
            case 3: {
                    message.sessionId = reader.string();
                    break;
                }
            case 4: {
                    message.rtmpUrl = reader.string();
                    break;
                }
            case 5: {
                    message.hlsUrl = reader.string();
                    break;
                }
            case 6: {
                    message.groupId = reader.uint64();
                    break;
                }
            case 7: {
                    message.mediaUrl = reader.string();
                    break;
                }
            case 8: {
                    message.mediaPic = reader.string();
                    break;
                }
            case 9: {
                    message.mediaId = reader.string();
                    break;
                }
            case 10: {
                    message.mediaSubtitle = reader.string();
                    break;
                }
            case 11: {
                    message.description = reader.string();
                    break;
                }
            case 12: {
                    message.userInfo = $root.AlaUserInfo.decode(reader, reader.uint32());
                    break;
                }
            case 13: {
                    message.duration = reader.uint32();
                    break;
                }
            case 14: {
                    message.audienceCount = reader.uint32();
                    break;
                }
            case 15: {
                    message.liveType = reader.uint32();
                    break;
                }
            case 16: {
                    message.screenDirection = reader.uint32();
                    break;
                }
            case 17: {
                    message.labelName = reader.string();
                    break;
                }
            case 18: {
                    message.liveStatus = reader.int32();
                    break;
                }
            case 19: {
                    message.shareInfo = $root.AlaShareInfo.decode(reader, reader.uint32());
                    break;
                }
            case 20: {
                    message.distance = reader.uint64();
                    break;
                }
            case 21: {
                    message.thirdAppId = reader.string();
                    break;
                }
            case 22: {
                    message.threadId = reader.uint64();
                    break;
                }
            case 23: {
                    if (!(message.stageDislikeInfo && message.stageDislikeInfo.length))
                        message.stageDislikeInfo = [];
                    message.stageDislikeInfo.push($root.AlaStageDislikeInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 24: {
                    message.label = $root.AlaCoverLabel.decode(reader, reader.uint32());
                    break;
                }
            case 25: {
                    message.challengeInfo = $root.AlaChallengeInfo.decode(reader, reader.uint32());
                    break;
                }
            case 26: {
                    message.frsTopliveType = reader.int32();
                    break;
                }
            case 27: {
                    message.frsToplivePic = reader.string();
                    break;
                }
            case 28: {
                    message.frsTopliveForce = reader.int32();
                    break;
                }
            case 29: {
                    message.liveFrom = reader.int32();
                    break;
                }
            case 31: {
                    message.thirdRoomId = reader.string();
                    break;
                }
            case 32: {
                    message.routerType = reader.string();
                    break;
                }
            case 33: {
                    message.thirdLiveType = reader.string();
                    break;
                }
            case 34: {
                    message.firstHeadline = reader.string();
                    break;
                }
            case 35: {
                    message.secondHeadline = reader.string();
                    break;
                }
            case 36: {
                    message.pbDisplayType = reader.uint32();
                    break;
                }
            case 37: {
                    message.recomReason = reader.string();
                    break;
                }
            case 38: {
                    message.openRecomReason = reader.uint32();
                    break;
                }
            case 39: {
                    message.openRecomLocation = reader.uint32();
                    break;
                }
            case 40: {
                    message.openRecomFans = reader.uint32();
                    break;
                }
            case 41: {
                    message.openRecomDuration = reader.uint32();
                    break;
                }
            case 43: {
                    if (!(message.dislikeInfo && message.dislikeInfo.length))
                        message.dislikeInfo = [];
                    message.dislikeInfo.push($root.DislikeInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 44: {
                    message.roomId = reader.uint64();
                    break;
                }
            case 45: {
                    message.roomStatus = reader.int32();
                    break;
                }
            case 46: {
                    message.roomName = reader.string();
                    break;
                }
            case 47: {
                    message.forumUserLiveMsg = reader.string();
                    break;
                }
            case 48: {
                    message.coverWide = reader.string();
                    break;
                }
            case 49: {
                    message.yyExt = $root.YyExt.decode(reader, reader.uint32());
                    break;
                }
            case 50: {
                    message.showPage = reader.int32();
                    break;
                }
            case 51: {
                    message.userLabel = $root.UniversalLabel.decode(reader, reader.uint32());
                    break;
                }
            case 52: {
                    message.flv = reader.string();
                    break;
                }
            case 54: {
                    message.pageFrom = reader.int32();
                    break;
                }
            case 55: {
                    message.scheme = reader.string();
                    break;
                }
            case 56: {
                    message.playerSize = $root.WidthHeight.decode(reader, reader.uint32());
                    break;
                }
            case 57: {
                    message.containerSize = $root.WidthHeight.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AlaLiveInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AlaLiveInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AlaLiveInfo} AlaLiveInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaLiveInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AlaLiveInfo message.
     * @function verify
     * @memberof AlaLiveInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AlaLiveInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.liveId != null && message.hasOwnProperty("liveId"))
            if (!$util.isInteger(message.liveId) && !(message.liveId && $util.isInteger(message.liveId.low) && $util.isInteger(message.liveId.high)))
                return "liveId: integer|Long expected";
        if (message.cover != null && message.hasOwnProperty("cover"))
            if (!$util.isString(message.cover))
                return "cover: string expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        if (message.rtmpUrl != null && message.hasOwnProperty("rtmpUrl"))
            if (!$util.isString(message.rtmpUrl))
                return "rtmpUrl: string expected";
        if (message.hlsUrl != null && message.hasOwnProperty("hlsUrl"))
            if (!$util.isString(message.hlsUrl))
                return "hlsUrl: string expected";
        if (message.groupId != null && message.hasOwnProperty("groupId"))
            if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                return "groupId: integer|Long expected";
        if (message.mediaUrl != null && message.hasOwnProperty("mediaUrl"))
            if (!$util.isString(message.mediaUrl))
                return "mediaUrl: string expected";
        if (message.mediaPic != null && message.hasOwnProperty("mediaPic"))
            if (!$util.isString(message.mediaPic))
                return "mediaPic: string expected";
        if (message.mediaId != null && message.hasOwnProperty("mediaId"))
            if (!$util.isString(message.mediaId))
                return "mediaId: string expected";
        if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
            if (!$util.isString(message.mediaSubtitle))
                return "mediaSubtitle: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
            let error = $root.AlaUserInfo.verify(message.userInfo);
            if (error)
                return "userInfo." + error;
        }
        if (message.duration != null && message.hasOwnProperty("duration"))
            if (!$util.isInteger(message.duration))
                return "duration: integer expected";
        if (message.audienceCount != null && message.hasOwnProperty("audienceCount"))
            if (!$util.isInteger(message.audienceCount))
                return "audienceCount: integer expected";
        if (message.liveType != null && message.hasOwnProperty("liveType"))
            if (!$util.isInteger(message.liveType))
                return "liveType: integer expected";
        if (message.screenDirection != null && message.hasOwnProperty("screenDirection"))
            if (!$util.isInteger(message.screenDirection))
                return "screenDirection: integer expected";
        if (message.labelName != null && message.hasOwnProperty("labelName"))
            if (!$util.isString(message.labelName))
                return "labelName: string expected";
        if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
            if (!$util.isInteger(message.liveStatus))
                return "liveStatus: integer expected";
        if (message.shareInfo != null && message.hasOwnProperty("shareInfo")) {
            let error = $root.AlaShareInfo.verify(message.shareInfo);
            if (error)
                return "shareInfo." + error;
        }
        if (message.distance != null && message.hasOwnProperty("distance"))
            if (!$util.isInteger(message.distance) && !(message.distance && $util.isInteger(message.distance.low) && $util.isInteger(message.distance.high)))
                return "distance: integer|Long expected";
        if (message.thirdAppId != null && message.hasOwnProperty("thirdAppId"))
            if (!$util.isString(message.thirdAppId))
                return "thirdAppId: string expected";
        if (message.threadId != null && message.hasOwnProperty("threadId"))
            if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                return "threadId: integer|Long expected";
        if (message.stageDislikeInfo != null && message.hasOwnProperty("stageDislikeInfo")) {
            if (!Array.isArray(message.stageDislikeInfo))
                return "stageDislikeInfo: array expected";
            for (let i = 0; i < message.stageDislikeInfo.length; ++i) {
                let error = $root.AlaStageDislikeInfo.verify(message.stageDislikeInfo[i]);
                if (error)
                    return "stageDislikeInfo." + error;
            }
        }
        if (message.label != null && message.hasOwnProperty("label")) {
            let error = $root.AlaCoverLabel.verify(message.label);
            if (error)
                return "label." + error;
        }
        if (message.challengeInfo != null && message.hasOwnProperty("challengeInfo")) {
            let error = $root.AlaChallengeInfo.verify(message.challengeInfo);
            if (error)
                return "challengeInfo." + error;
        }
        if (message.frsTopliveType != null && message.hasOwnProperty("frsTopliveType"))
            if (!$util.isInteger(message.frsTopliveType))
                return "frsTopliveType: integer expected";
        if (message.frsToplivePic != null && message.hasOwnProperty("frsToplivePic"))
            if (!$util.isString(message.frsToplivePic))
                return "frsToplivePic: string expected";
        if (message.frsTopliveForce != null && message.hasOwnProperty("frsTopliveForce"))
            if (!$util.isInteger(message.frsTopliveForce))
                return "frsTopliveForce: integer expected";
        if (message.liveFrom != null && message.hasOwnProperty("liveFrom"))
            if (!$util.isInteger(message.liveFrom))
                return "liveFrom: integer expected";
        if (message.thirdRoomId != null && message.hasOwnProperty("thirdRoomId"))
            if (!$util.isString(message.thirdRoomId))
                return "thirdRoomId: string expected";
        if (message.routerType != null && message.hasOwnProperty("routerType"))
            if (!$util.isString(message.routerType))
                return "routerType: string expected";
        if (message.thirdLiveType != null && message.hasOwnProperty("thirdLiveType"))
            if (!$util.isString(message.thirdLiveType))
                return "thirdLiveType: string expected";
        if (message.firstHeadline != null && message.hasOwnProperty("firstHeadline"))
            if (!$util.isString(message.firstHeadline))
                return "firstHeadline: string expected";
        if (message.secondHeadline != null && message.hasOwnProperty("secondHeadline"))
            if (!$util.isString(message.secondHeadline))
                return "secondHeadline: string expected";
        if (message.pbDisplayType != null && message.hasOwnProperty("pbDisplayType"))
            if (!$util.isInteger(message.pbDisplayType))
                return "pbDisplayType: integer expected";
        if (message.recomReason != null && message.hasOwnProperty("recomReason"))
            if (!$util.isString(message.recomReason))
                return "recomReason: string expected";
        if (message.openRecomReason != null && message.hasOwnProperty("openRecomReason"))
            if (!$util.isInteger(message.openRecomReason))
                return "openRecomReason: integer expected";
        if (message.openRecomLocation != null && message.hasOwnProperty("openRecomLocation"))
            if (!$util.isInteger(message.openRecomLocation))
                return "openRecomLocation: integer expected";
        if (message.openRecomFans != null && message.hasOwnProperty("openRecomFans"))
            if (!$util.isInteger(message.openRecomFans))
                return "openRecomFans: integer expected";
        if (message.openRecomDuration != null && message.hasOwnProperty("openRecomDuration"))
            if (!$util.isInteger(message.openRecomDuration))
                return "openRecomDuration: integer expected";
        if (message.dislikeInfo != null && message.hasOwnProperty("dislikeInfo")) {
            if (!Array.isArray(message.dislikeInfo))
                return "dislikeInfo: array expected";
            for (let i = 0; i < message.dislikeInfo.length; ++i) {
                let error = $root.DislikeInfo.verify(message.dislikeInfo[i]);
                if (error)
                    return "dislikeInfo." + error;
            }
        }
        if (message.roomId != null && message.hasOwnProperty("roomId"))
            if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high)))
                return "roomId: integer|Long expected";
        if (message.roomStatus != null && message.hasOwnProperty("roomStatus"))
            if (!$util.isInteger(message.roomStatus))
                return "roomStatus: integer expected";
        if (message.roomName != null && message.hasOwnProperty("roomName"))
            if (!$util.isString(message.roomName))
                return "roomName: string expected";
        if (message.forumUserLiveMsg != null && message.hasOwnProperty("forumUserLiveMsg"))
            if (!$util.isString(message.forumUserLiveMsg))
                return "forumUserLiveMsg: string expected";
        if (message.coverWide != null && message.hasOwnProperty("coverWide"))
            if (!$util.isString(message.coverWide))
                return "coverWide: string expected";
        if (message.yyExt != null && message.hasOwnProperty("yyExt")) {
            let error = $root.YyExt.verify(message.yyExt);
            if (error)
                return "yyExt." + error;
        }
        if (message.showPage != null && message.hasOwnProperty("showPage"))
            if (!$util.isInteger(message.showPage))
                return "showPage: integer expected";
        if (message.userLabel != null && message.hasOwnProperty("userLabel")) {
            let error = $root.UniversalLabel.verify(message.userLabel);
            if (error)
                return "userLabel." + error;
        }
        if (message.flv != null && message.hasOwnProperty("flv"))
            if (!$util.isString(message.flv))
                return "flv: string expected";
        if (message.pageFrom != null && message.hasOwnProperty("pageFrom"))
            if (!$util.isInteger(message.pageFrom))
                return "pageFrom: integer expected";
        if (message.scheme != null && message.hasOwnProperty("scheme"))
            if (!$util.isString(message.scheme))
                return "scheme: string expected";
        if (message.playerSize != null && message.hasOwnProperty("playerSize")) {
            let error = $root.WidthHeight.verify(message.playerSize);
            if (error)
                return "playerSize." + error;
        }
        if (message.containerSize != null && message.hasOwnProperty("containerSize")) {
            let error = $root.WidthHeight.verify(message.containerSize);
            if (error)
                return "containerSize." + error;
        }
        return null;
    };

    /**
     * Creates an AlaLiveInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AlaLiveInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AlaLiveInfo} AlaLiveInfo
     */
    AlaLiveInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.AlaLiveInfo)
            return object;
        let message = new $root.AlaLiveInfo();
        if (object.liveId != null)
            if ($util.Long)
                (message.liveId = $util.Long.fromValue(object.liveId)).unsigned = true;
            else if (typeof object.liveId === "string")
                message.liveId = parseInt(object.liveId, 10);
            else if (typeof object.liveId === "number")
                message.liveId = object.liveId;
            else if (typeof object.liveId === "object")
                message.liveId = new $util.LongBits(object.liveId.low >>> 0, object.liveId.high >>> 0).toNumber(true);
        if (object.cover != null)
            message.cover = String(object.cover);
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        if (object.rtmpUrl != null)
            message.rtmpUrl = String(object.rtmpUrl);
        if (object.hlsUrl != null)
            message.hlsUrl = String(object.hlsUrl);
        if (object.groupId != null)
            if ($util.Long)
                (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
            else if (typeof object.groupId === "string")
                message.groupId = parseInt(object.groupId, 10);
            else if (typeof object.groupId === "number")
                message.groupId = object.groupId;
            else if (typeof object.groupId === "object")
                message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
        if (object.mediaUrl != null)
            message.mediaUrl = String(object.mediaUrl);
        if (object.mediaPic != null)
            message.mediaPic = String(object.mediaPic);
        if (object.mediaId != null)
            message.mediaId = String(object.mediaId);
        if (object.mediaSubtitle != null)
            message.mediaSubtitle = String(object.mediaSubtitle);
        if (object.description != null)
            message.description = String(object.description);
        if (object.userInfo != null) {
            if (typeof object.userInfo !== "object")
                throw TypeError(".AlaLiveInfo.userInfo: object expected");
            message.userInfo = $root.AlaUserInfo.fromObject(object.userInfo);
        }
        if (object.duration != null)
            message.duration = object.duration >>> 0;
        if (object.audienceCount != null)
            message.audienceCount = object.audienceCount >>> 0;
        if (object.liveType != null)
            message.liveType = object.liveType >>> 0;
        if (object.screenDirection != null)
            message.screenDirection = object.screenDirection >>> 0;
        if (object.labelName != null)
            message.labelName = String(object.labelName);
        if (object.liveStatus != null)
            message.liveStatus = object.liveStatus | 0;
        if (object.shareInfo != null) {
            if (typeof object.shareInfo !== "object")
                throw TypeError(".AlaLiveInfo.shareInfo: object expected");
            message.shareInfo = $root.AlaShareInfo.fromObject(object.shareInfo);
        }
        if (object.distance != null)
            if ($util.Long)
                (message.distance = $util.Long.fromValue(object.distance)).unsigned = true;
            else if (typeof object.distance === "string")
                message.distance = parseInt(object.distance, 10);
            else if (typeof object.distance === "number")
                message.distance = object.distance;
            else if (typeof object.distance === "object")
                message.distance = new $util.LongBits(object.distance.low >>> 0, object.distance.high >>> 0).toNumber(true);
        if (object.thirdAppId != null)
            message.thirdAppId = String(object.thirdAppId);
        if (object.threadId != null)
            if ($util.Long)
                (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = true;
            else if (typeof object.threadId === "string")
                message.threadId = parseInt(object.threadId, 10);
            else if (typeof object.threadId === "number")
                message.threadId = object.threadId;
            else if (typeof object.threadId === "object")
                message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber(true);
        if (object.stageDislikeInfo) {
            if (!Array.isArray(object.stageDislikeInfo))
                throw TypeError(".AlaLiveInfo.stageDislikeInfo: array expected");
            message.stageDislikeInfo = [];
            for (let i = 0; i < object.stageDislikeInfo.length; ++i) {
                if (typeof object.stageDislikeInfo[i] !== "object")
                    throw TypeError(".AlaLiveInfo.stageDislikeInfo: object expected");
                message.stageDislikeInfo[i] = $root.AlaStageDislikeInfo.fromObject(object.stageDislikeInfo[i]);
            }
        }
        if (object.label != null) {
            if (typeof object.label !== "object")
                throw TypeError(".AlaLiveInfo.label: object expected");
            message.label = $root.AlaCoverLabel.fromObject(object.label);
        }
        if (object.challengeInfo != null) {
            if (typeof object.challengeInfo !== "object")
                throw TypeError(".AlaLiveInfo.challengeInfo: object expected");
            message.challengeInfo = $root.AlaChallengeInfo.fromObject(object.challengeInfo);
        }
        if (object.frsTopliveType != null)
            message.frsTopliveType = object.frsTopliveType | 0;
        if (object.frsToplivePic != null)
            message.frsToplivePic = String(object.frsToplivePic);
        if (object.frsTopliveForce != null)
            message.frsTopliveForce = object.frsTopliveForce | 0;
        if (object.liveFrom != null)
            message.liveFrom = object.liveFrom | 0;
        if (object.thirdRoomId != null)
            message.thirdRoomId = String(object.thirdRoomId);
        if (object.routerType != null)
            message.routerType = String(object.routerType);
        if (object.thirdLiveType != null)
            message.thirdLiveType = String(object.thirdLiveType);
        if (object.firstHeadline != null)
            message.firstHeadline = String(object.firstHeadline);
        if (object.secondHeadline != null)
            message.secondHeadline = String(object.secondHeadline);
        if (object.pbDisplayType != null)
            message.pbDisplayType = object.pbDisplayType >>> 0;
        if (object.recomReason != null)
            message.recomReason = String(object.recomReason);
        if (object.openRecomReason != null)
            message.openRecomReason = object.openRecomReason >>> 0;
        if (object.openRecomLocation != null)
            message.openRecomLocation = object.openRecomLocation >>> 0;
        if (object.openRecomFans != null)
            message.openRecomFans = object.openRecomFans >>> 0;
        if (object.openRecomDuration != null)
            message.openRecomDuration = object.openRecomDuration >>> 0;
        if (object.dislikeInfo) {
            if (!Array.isArray(object.dislikeInfo))
                throw TypeError(".AlaLiveInfo.dislikeInfo: array expected");
            message.dislikeInfo = [];
            for (let i = 0; i < object.dislikeInfo.length; ++i) {
                if (typeof object.dislikeInfo[i] !== "object")
                    throw TypeError(".AlaLiveInfo.dislikeInfo: object expected");
                message.dislikeInfo[i] = $root.DislikeInfo.fromObject(object.dislikeInfo[i]);
            }
        }
        if (object.roomId != null)
            if ($util.Long)
                (message.roomId = $util.Long.fromValue(object.roomId)).unsigned = true;
            else if (typeof object.roomId === "string")
                message.roomId = parseInt(object.roomId, 10);
            else if (typeof object.roomId === "number")
                message.roomId = object.roomId;
            else if (typeof object.roomId === "object")
                message.roomId = new $util.LongBits(object.roomId.low >>> 0, object.roomId.high >>> 0).toNumber(true);
        if (object.roomStatus != null)
            message.roomStatus = object.roomStatus | 0;
        if (object.roomName != null)
            message.roomName = String(object.roomName);
        if (object.forumUserLiveMsg != null)
            message.forumUserLiveMsg = String(object.forumUserLiveMsg);
        if (object.coverWide != null)
            message.coverWide = String(object.coverWide);
        if (object.yyExt != null) {
            if (typeof object.yyExt !== "object")
                throw TypeError(".AlaLiveInfo.yyExt: object expected");
            message.yyExt = $root.YyExt.fromObject(object.yyExt);
        }
        if (object.showPage != null)
            message.showPage = object.showPage | 0;
        if (object.userLabel != null) {
            if (typeof object.userLabel !== "object")
                throw TypeError(".AlaLiveInfo.userLabel: object expected");
            message.userLabel = $root.UniversalLabel.fromObject(object.userLabel);
        }
        if (object.flv != null)
            message.flv = String(object.flv);
        if (object.pageFrom != null)
            message.pageFrom = object.pageFrom | 0;
        if (object.scheme != null)
            message.scheme = String(object.scheme);
        if (object.playerSize != null) {
            if (typeof object.playerSize !== "object")
                throw TypeError(".AlaLiveInfo.playerSize: object expected");
            message.playerSize = $root.WidthHeight.fromObject(object.playerSize);
        }
        if (object.containerSize != null) {
            if (typeof object.containerSize !== "object")
                throw TypeError(".AlaLiveInfo.containerSize: object expected");
            message.containerSize = $root.WidthHeight.fromObject(object.containerSize);
        }
        return message;
    };

    /**
     * Creates a plain object from an AlaLiveInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AlaLiveInfo
     * @static
     * @param {AlaLiveInfo} message AlaLiveInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AlaLiveInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.stageDislikeInfo = [];
            object.dislikeInfo = [];
        }
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.liveId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.liveId = options.longs === String ? "0" : 0;
            object.cover = "";
            object.sessionId = "";
            object.rtmpUrl = "";
            object.hlsUrl = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.groupId = options.longs === String ? "0" : 0;
            object.mediaUrl = "";
            object.mediaPic = "";
            object.mediaId = "";
            object.mediaSubtitle = "";
            object.description = "";
            object.userInfo = null;
            object.duration = 0;
            object.audienceCount = 0;
            object.liveType = 0;
            object.screenDirection = 0;
            object.labelName = "";
            object.liveStatus = 0;
            object.shareInfo = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.distance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.distance = options.longs === String ? "0" : 0;
            object.thirdAppId = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.threadId = options.longs === String ? "0" : 0;
            object.label = null;
            object.challengeInfo = null;
            object.frsTopliveType = 0;
            object.frsToplivePic = "";
            object.frsTopliveForce = 0;
            object.liveFrom = 0;
            object.thirdRoomId = "";
            object.routerType = "";
            object.thirdLiveType = "";
            object.firstHeadline = "";
            object.secondHeadline = "";
            object.pbDisplayType = 0;
            object.recomReason = "";
            object.openRecomReason = 0;
            object.openRecomLocation = 0;
            object.openRecomFans = 0;
            object.openRecomDuration = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.roomId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.roomId = options.longs === String ? "0" : 0;
            object.roomStatus = 0;
            object.roomName = "";
            object.forumUserLiveMsg = "";
            object.coverWide = "";
            object.yyExt = null;
            object.showPage = 0;
            object.userLabel = null;
            object.flv = "";
            object.pageFrom = 0;
            object.scheme = "";
            object.playerSize = null;
            object.containerSize = null;
        }
        if (message.liveId != null && message.hasOwnProperty("liveId"))
            if (typeof message.liveId === "number")
                object.liveId = options.longs === String ? String(message.liveId) : message.liveId;
            else
                object.liveId = options.longs === String ? $util.Long.prototype.toString.call(message.liveId) : options.longs === Number ? new $util.LongBits(message.liveId.low >>> 0, message.liveId.high >>> 0).toNumber(true) : message.liveId;
        if (message.cover != null && message.hasOwnProperty("cover"))
            object.cover = message.cover;
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        if (message.rtmpUrl != null && message.hasOwnProperty("rtmpUrl"))
            object.rtmpUrl = message.rtmpUrl;
        if (message.hlsUrl != null && message.hasOwnProperty("hlsUrl"))
            object.hlsUrl = message.hlsUrl;
        if (message.groupId != null && message.hasOwnProperty("groupId"))
            if (typeof message.groupId === "number")
                object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
            else
                object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
        if (message.mediaUrl != null && message.hasOwnProperty("mediaUrl"))
            object.mediaUrl = message.mediaUrl;
        if (message.mediaPic != null && message.hasOwnProperty("mediaPic"))
            object.mediaPic = message.mediaPic;
        if (message.mediaId != null && message.hasOwnProperty("mediaId"))
            object.mediaId = message.mediaId;
        if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
            object.mediaSubtitle = message.mediaSubtitle;
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.userInfo != null && message.hasOwnProperty("userInfo"))
            object.userInfo = $root.AlaUserInfo.toObject(message.userInfo, options);
        if (message.duration != null && message.hasOwnProperty("duration"))
            object.duration = message.duration;
        if (message.audienceCount != null && message.hasOwnProperty("audienceCount"))
            object.audienceCount = message.audienceCount;
        if (message.liveType != null && message.hasOwnProperty("liveType"))
            object.liveType = message.liveType;
        if (message.screenDirection != null && message.hasOwnProperty("screenDirection"))
            object.screenDirection = message.screenDirection;
        if (message.labelName != null && message.hasOwnProperty("labelName"))
            object.labelName = message.labelName;
        if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
            object.liveStatus = message.liveStatus;
        if (message.shareInfo != null && message.hasOwnProperty("shareInfo"))
            object.shareInfo = $root.AlaShareInfo.toObject(message.shareInfo, options);
        if (message.distance != null && message.hasOwnProperty("distance"))
            if (typeof message.distance === "number")
                object.distance = options.longs === String ? String(message.distance) : message.distance;
            else
                object.distance = options.longs === String ? $util.Long.prototype.toString.call(message.distance) : options.longs === Number ? new $util.LongBits(message.distance.low >>> 0, message.distance.high >>> 0).toNumber(true) : message.distance;
        if (message.thirdAppId != null && message.hasOwnProperty("thirdAppId"))
            object.thirdAppId = message.thirdAppId;
        if (message.threadId != null && message.hasOwnProperty("threadId"))
            if (typeof message.threadId === "number")
                object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
            else
                object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber(true) : message.threadId;
        if (message.stageDislikeInfo && message.stageDislikeInfo.length) {
            object.stageDislikeInfo = [];
            for (let j = 0; j < message.stageDislikeInfo.length; ++j)
                object.stageDislikeInfo[j] = $root.AlaStageDislikeInfo.toObject(message.stageDislikeInfo[j], options);
        }
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = $root.AlaCoverLabel.toObject(message.label, options);
        if (message.challengeInfo != null && message.hasOwnProperty("challengeInfo"))
            object.challengeInfo = $root.AlaChallengeInfo.toObject(message.challengeInfo, options);
        if (message.frsTopliveType != null && message.hasOwnProperty("frsTopliveType"))
            object.frsTopliveType = message.frsTopliveType;
        if (message.frsToplivePic != null && message.hasOwnProperty("frsToplivePic"))
            object.frsToplivePic = message.frsToplivePic;
        if (message.frsTopliveForce != null && message.hasOwnProperty("frsTopliveForce"))
            object.frsTopliveForce = message.frsTopliveForce;
        if (message.liveFrom != null && message.hasOwnProperty("liveFrom"))
            object.liveFrom = message.liveFrom;
        if (message.thirdRoomId != null && message.hasOwnProperty("thirdRoomId"))
            object.thirdRoomId = message.thirdRoomId;
        if (message.routerType != null && message.hasOwnProperty("routerType"))
            object.routerType = message.routerType;
        if (message.thirdLiveType != null && message.hasOwnProperty("thirdLiveType"))
            object.thirdLiveType = message.thirdLiveType;
        if (message.firstHeadline != null && message.hasOwnProperty("firstHeadline"))
            object.firstHeadline = message.firstHeadline;
        if (message.secondHeadline != null && message.hasOwnProperty("secondHeadline"))
            object.secondHeadline = message.secondHeadline;
        if (message.pbDisplayType != null && message.hasOwnProperty("pbDisplayType"))
            object.pbDisplayType = message.pbDisplayType;
        if (message.recomReason != null && message.hasOwnProperty("recomReason"))
            object.recomReason = message.recomReason;
        if (message.openRecomReason != null && message.hasOwnProperty("openRecomReason"))
            object.openRecomReason = message.openRecomReason;
        if (message.openRecomLocation != null && message.hasOwnProperty("openRecomLocation"))
            object.openRecomLocation = message.openRecomLocation;
        if (message.openRecomFans != null && message.hasOwnProperty("openRecomFans"))
            object.openRecomFans = message.openRecomFans;
        if (message.openRecomDuration != null && message.hasOwnProperty("openRecomDuration"))
            object.openRecomDuration = message.openRecomDuration;
        if (message.dislikeInfo && message.dislikeInfo.length) {
            object.dislikeInfo = [];
            for (let j = 0; j < message.dislikeInfo.length; ++j)
                object.dislikeInfo[j] = $root.DislikeInfo.toObject(message.dislikeInfo[j], options);
        }
        if (message.roomId != null && message.hasOwnProperty("roomId"))
            if (typeof message.roomId === "number")
                object.roomId = options.longs === String ? String(message.roomId) : message.roomId;
            else
                object.roomId = options.longs === String ? $util.Long.prototype.toString.call(message.roomId) : options.longs === Number ? new $util.LongBits(message.roomId.low >>> 0, message.roomId.high >>> 0).toNumber(true) : message.roomId;
        if (message.roomStatus != null && message.hasOwnProperty("roomStatus"))
            object.roomStatus = message.roomStatus;
        if (message.roomName != null && message.hasOwnProperty("roomName"))
            object.roomName = message.roomName;
        if (message.forumUserLiveMsg != null && message.hasOwnProperty("forumUserLiveMsg"))
            object.forumUserLiveMsg = message.forumUserLiveMsg;
        if (message.coverWide != null && message.hasOwnProperty("coverWide"))
            object.coverWide = message.coverWide;
        if (message.yyExt != null && message.hasOwnProperty("yyExt"))
            object.yyExt = $root.YyExt.toObject(message.yyExt, options);
        if (message.showPage != null && message.hasOwnProperty("showPage"))
            object.showPage = message.showPage;
        if (message.userLabel != null && message.hasOwnProperty("userLabel"))
            object.userLabel = $root.UniversalLabel.toObject(message.userLabel, options);
        if (message.flv != null && message.hasOwnProperty("flv"))
            object.flv = message.flv;
        if (message.pageFrom != null && message.hasOwnProperty("pageFrom"))
            object.pageFrom = message.pageFrom;
        if (message.scheme != null && message.hasOwnProperty("scheme"))
            object.scheme = message.scheme;
        if (message.playerSize != null && message.hasOwnProperty("playerSize"))
            object.playerSize = $root.WidthHeight.toObject(message.playerSize, options);
        if (message.containerSize != null && message.hasOwnProperty("containerSize"))
            object.containerSize = $root.WidthHeight.toObject(message.containerSize, options);
        return object;
    };

    /**
     * Converts this AlaLiveInfo to JSON.
     * @function toJSON
     * @memberof AlaLiveInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AlaLiveInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AlaLiveInfo
     * @function getTypeUrl
     * @memberof AlaLiveInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AlaLiveInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AlaLiveInfo";
    };

    return AlaLiveInfo;
})();

export const AlaChallengeInfo = $root.AlaChallengeInfo = (() => {

    /**
     * Properties of an AlaChallengeInfo.
     * @exports IAlaChallengeInfo
     * @interface IAlaChallengeInfo
     * @property {number|Long|null} [challengeId] AlaChallengeInfo challengeId
     * @property {number|Long|null} [winningNum] AlaChallengeInfo winningNum
     * @property {string|null} [rivalSession] AlaChallengeInfo rivalSession
     * @property {string|null} [rivalRtmpUrl] AlaChallengeInfo rivalRtmpUrl
     * @property {string|null} [rivalHlsUrl] AlaChallengeInfo rivalHlsUrl
     * @property {string|null} [ext] AlaChallengeInfo ext
     */

    /**
     * Constructs a new AlaChallengeInfo.
     * @exports AlaChallengeInfo
     * @classdesc Represents an AlaChallengeInfo.
     * @implements IAlaChallengeInfo
     * @constructor
     * @param {IAlaChallengeInfo=} [properties] Properties to set
     */
    function AlaChallengeInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AlaChallengeInfo challengeId.
     * @member {number|Long} challengeId
     * @memberof AlaChallengeInfo
     * @instance
     */
    AlaChallengeInfo.prototype.challengeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AlaChallengeInfo winningNum.
     * @member {number|Long} winningNum
     * @memberof AlaChallengeInfo
     * @instance
     */
    AlaChallengeInfo.prototype.winningNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AlaChallengeInfo rivalSession.
     * @member {string} rivalSession
     * @memberof AlaChallengeInfo
     * @instance
     */
    AlaChallengeInfo.prototype.rivalSession = "";

    /**
     * AlaChallengeInfo rivalRtmpUrl.
     * @member {string} rivalRtmpUrl
     * @memberof AlaChallengeInfo
     * @instance
     */
    AlaChallengeInfo.prototype.rivalRtmpUrl = "";

    /**
     * AlaChallengeInfo rivalHlsUrl.
     * @member {string} rivalHlsUrl
     * @memberof AlaChallengeInfo
     * @instance
     */
    AlaChallengeInfo.prototype.rivalHlsUrl = "";

    /**
     * AlaChallengeInfo ext.
     * @member {string} ext
     * @memberof AlaChallengeInfo
     * @instance
     */
    AlaChallengeInfo.prototype.ext = "";

    /**
     * Creates a new AlaChallengeInfo instance using the specified properties.
     * @function create
     * @memberof AlaChallengeInfo
     * @static
     * @param {IAlaChallengeInfo=} [properties] Properties to set
     * @returns {AlaChallengeInfo} AlaChallengeInfo instance
     */
    AlaChallengeInfo.create = function create(properties) {
        return new AlaChallengeInfo(properties);
    };

    /**
     * Encodes the specified AlaChallengeInfo message. Does not implicitly {@link AlaChallengeInfo.verify|verify} messages.
     * @function encode
     * @memberof AlaChallengeInfo
     * @static
     * @param {IAlaChallengeInfo} message AlaChallengeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaChallengeInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.challengeId != null && Object.hasOwnProperty.call(message, "challengeId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.challengeId);
        if (message.winningNum != null && Object.hasOwnProperty.call(message, "winningNum"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.winningNum);
        if (message.rivalSession != null && Object.hasOwnProperty.call(message, "rivalSession"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.rivalSession);
        if (message.rivalRtmpUrl != null && Object.hasOwnProperty.call(message, "rivalRtmpUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.rivalRtmpUrl);
        if (message.rivalHlsUrl != null && Object.hasOwnProperty.call(message, "rivalHlsUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.rivalHlsUrl);
        if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.ext);
        return writer;
    };

    /**
     * Encodes the specified AlaChallengeInfo message, length delimited. Does not implicitly {@link AlaChallengeInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AlaChallengeInfo
     * @static
     * @param {IAlaChallengeInfo} message AlaChallengeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaChallengeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AlaChallengeInfo message from the specified reader or buffer.
     * @function decode
     * @memberof AlaChallengeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AlaChallengeInfo} AlaChallengeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaChallengeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlaChallengeInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.challengeId = reader.int64();
                    break;
                }
            case 2: {
                    message.winningNum = reader.int64();
                    break;
                }
            case 3: {
                    message.rivalSession = reader.string();
                    break;
                }
            case 4: {
                    message.rivalRtmpUrl = reader.string();
                    break;
                }
            case 5: {
                    message.rivalHlsUrl = reader.string();
                    break;
                }
            case 6: {
                    message.ext = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AlaChallengeInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AlaChallengeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AlaChallengeInfo} AlaChallengeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaChallengeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AlaChallengeInfo message.
     * @function verify
     * @memberof AlaChallengeInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AlaChallengeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.challengeId != null && message.hasOwnProperty("challengeId"))
            if (!$util.isInteger(message.challengeId) && !(message.challengeId && $util.isInteger(message.challengeId.low) && $util.isInteger(message.challengeId.high)))
                return "challengeId: integer|Long expected";
        if (message.winningNum != null && message.hasOwnProperty("winningNum"))
            if (!$util.isInteger(message.winningNum) && !(message.winningNum && $util.isInteger(message.winningNum.low) && $util.isInteger(message.winningNum.high)))
                return "winningNum: integer|Long expected";
        if (message.rivalSession != null && message.hasOwnProperty("rivalSession"))
            if (!$util.isString(message.rivalSession))
                return "rivalSession: string expected";
        if (message.rivalRtmpUrl != null && message.hasOwnProperty("rivalRtmpUrl"))
            if (!$util.isString(message.rivalRtmpUrl))
                return "rivalRtmpUrl: string expected";
        if (message.rivalHlsUrl != null && message.hasOwnProperty("rivalHlsUrl"))
            if (!$util.isString(message.rivalHlsUrl))
                return "rivalHlsUrl: string expected";
        if (message.ext != null && message.hasOwnProperty("ext"))
            if (!$util.isString(message.ext))
                return "ext: string expected";
        return null;
    };

    /**
     * Creates an AlaChallengeInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AlaChallengeInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AlaChallengeInfo} AlaChallengeInfo
     */
    AlaChallengeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.AlaChallengeInfo)
            return object;
        let message = new $root.AlaChallengeInfo();
        if (object.challengeId != null)
            if ($util.Long)
                (message.challengeId = $util.Long.fromValue(object.challengeId)).unsigned = false;
            else if (typeof object.challengeId === "string")
                message.challengeId = parseInt(object.challengeId, 10);
            else if (typeof object.challengeId === "number")
                message.challengeId = object.challengeId;
            else if (typeof object.challengeId === "object")
                message.challengeId = new $util.LongBits(object.challengeId.low >>> 0, object.challengeId.high >>> 0).toNumber();
        if (object.winningNum != null)
            if ($util.Long)
                (message.winningNum = $util.Long.fromValue(object.winningNum)).unsigned = false;
            else if (typeof object.winningNum === "string")
                message.winningNum = parseInt(object.winningNum, 10);
            else if (typeof object.winningNum === "number")
                message.winningNum = object.winningNum;
            else if (typeof object.winningNum === "object")
                message.winningNum = new $util.LongBits(object.winningNum.low >>> 0, object.winningNum.high >>> 0).toNumber();
        if (object.rivalSession != null)
            message.rivalSession = String(object.rivalSession);
        if (object.rivalRtmpUrl != null)
            message.rivalRtmpUrl = String(object.rivalRtmpUrl);
        if (object.rivalHlsUrl != null)
            message.rivalHlsUrl = String(object.rivalHlsUrl);
        if (object.ext != null)
            message.ext = String(object.ext);
        return message;
    };

    /**
     * Creates a plain object from an AlaChallengeInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AlaChallengeInfo
     * @static
     * @param {AlaChallengeInfo} message AlaChallengeInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AlaChallengeInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.challengeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.challengeId = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.winningNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.winningNum = options.longs === String ? "0" : 0;
            object.rivalSession = "";
            object.rivalRtmpUrl = "";
            object.rivalHlsUrl = "";
            object.ext = "";
        }
        if (message.challengeId != null && message.hasOwnProperty("challengeId"))
            if (typeof message.challengeId === "number")
                object.challengeId = options.longs === String ? String(message.challengeId) : message.challengeId;
            else
                object.challengeId = options.longs === String ? $util.Long.prototype.toString.call(message.challengeId) : options.longs === Number ? new $util.LongBits(message.challengeId.low >>> 0, message.challengeId.high >>> 0).toNumber() : message.challengeId;
        if (message.winningNum != null && message.hasOwnProperty("winningNum"))
            if (typeof message.winningNum === "number")
                object.winningNum = options.longs === String ? String(message.winningNum) : message.winningNum;
            else
                object.winningNum = options.longs === String ? $util.Long.prototype.toString.call(message.winningNum) : options.longs === Number ? new $util.LongBits(message.winningNum.low >>> 0, message.winningNum.high >>> 0).toNumber() : message.winningNum;
        if (message.rivalSession != null && message.hasOwnProperty("rivalSession"))
            object.rivalSession = message.rivalSession;
        if (message.rivalRtmpUrl != null && message.hasOwnProperty("rivalRtmpUrl"))
            object.rivalRtmpUrl = message.rivalRtmpUrl;
        if (message.rivalHlsUrl != null && message.hasOwnProperty("rivalHlsUrl"))
            object.rivalHlsUrl = message.rivalHlsUrl;
        if (message.ext != null && message.hasOwnProperty("ext"))
            object.ext = message.ext;
        return object;
    };

    /**
     * Converts this AlaChallengeInfo to JSON.
     * @function toJSON
     * @memberof AlaChallengeInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AlaChallengeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AlaChallengeInfo
     * @function getTypeUrl
     * @memberof AlaChallengeInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AlaChallengeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AlaChallengeInfo";
    };

    return AlaChallengeInfo;
})();

export const AlaCoverLabel = $root.AlaCoverLabel = (() => {

    /**
     * Properties of an AlaCoverLabel.
     * @exports IAlaCoverLabel
     * @interface IAlaCoverLabel
     * @property {number|null} [labelId] AlaCoverLabel labelId
     * @property {string|null} [labelName] AlaCoverLabel labelName
     * @property {string|null} [labelRgb] AlaCoverLabel labelRgb
     */

    /**
     * Constructs a new AlaCoverLabel.
     * @exports AlaCoverLabel
     * @classdesc Represents an AlaCoverLabel.
     * @implements IAlaCoverLabel
     * @constructor
     * @param {IAlaCoverLabel=} [properties] Properties to set
     */
    function AlaCoverLabel(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AlaCoverLabel labelId.
     * @member {number} labelId
     * @memberof AlaCoverLabel
     * @instance
     */
    AlaCoverLabel.prototype.labelId = 0;

    /**
     * AlaCoverLabel labelName.
     * @member {string} labelName
     * @memberof AlaCoverLabel
     * @instance
     */
    AlaCoverLabel.prototype.labelName = "";

    /**
     * AlaCoverLabel labelRgb.
     * @member {string} labelRgb
     * @memberof AlaCoverLabel
     * @instance
     */
    AlaCoverLabel.prototype.labelRgb = "";

    /**
     * Creates a new AlaCoverLabel instance using the specified properties.
     * @function create
     * @memberof AlaCoverLabel
     * @static
     * @param {IAlaCoverLabel=} [properties] Properties to set
     * @returns {AlaCoverLabel} AlaCoverLabel instance
     */
    AlaCoverLabel.create = function create(properties) {
        return new AlaCoverLabel(properties);
    };

    /**
     * Encodes the specified AlaCoverLabel message. Does not implicitly {@link AlaCoverLabel.verify|verify} messages.
     * @function encode
     * @memberof AlaCoverLabel
     * @static
     * @param {IAlaCoverLabel} message AlaCoverLabel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaCoverLabel.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.labelId != null && Object.hasOwnProperty.call(message, "labelId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.labelId);
        if (message.labelName != null && Object.hasOwnProperty.call(message, "labelName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.labelName);
        if (message.labelRgb != null && Object.hasOwnProperty.call(message, "labelRgb"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.labelRgb);
        return writer;
    };

    /**
     * Encodes the specified AlaCoverLabel message, length delimited. Does not implicitly {@link AlaCoverLabel.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AlaCoverLabel
     * @static
     * @param {IAlaCoverLabel} message AlaCoverLabel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaCoverLabel.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AlaCoverLabel message from the specified reader or buffer.
     * @function decode
     * @memberof AlaCoverLabel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AlaCoverLabel} AlaCoverLabel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaCoverLabel.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlaCoverLabel();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.labelId = reader.uint32();
                    break;
                }
            case 2: {
                    message.labelName = reader.string();
                    break;
                }
            case 3: {
                    message.labelRgb = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AlaCoverLabel message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AlaCoverLabel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AlaCoverLabel} AlaCoverLabel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaCoverLabel.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AlaCoverLabel message.
     * @function verify
     * @memberof AlaCoverLabel
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AlaCoverLabel.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.labelId != null && message.hasOwnProperty("labelId"))
            if (!$util.isInteger(message.labelId))
                return "labelId: integer expected";
        if (message.labelName != null && message.hasOwnProperty("labelName"))
            if (!$util.isString(message.labelName))
                return "labelName: string expected";
        if (message.labelRgb != null && message.hasOwnProperty("labelRgb"))
            if (!$util.isString(message.labelRgb))
                return "labelRgb: string expected";
        return null;
    };

    /**
     * Creates an AlaCoverLabel message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AlaCoverLabel
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AlaCoverLabel} AlaCoverLabel
     */
    AlaCoverLabel.fromObject = function fromObject(object) {
        if (object instanceof $root.AlaCoverLabel)
            return object;
        let message = new $root.AlaCoverLabel();
        if (object.labelId != null)
            message.labelId = object.labelId >>> 0;
        if (object.labelName != null)
            message.labelName = String(object.labelName);
        if (object.labelRgb != null)
            message.labelRgb = String(object.labelRgb);
        return message;
    };

    /**
     * Creates a plain object from an AlaCoverLabel message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AlaCoverLabel
     * @static
     * @param {AlaCoverLabel} message AlaCoverLabel
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AlaCoverLabel.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.labelId = 0;
            object.labelName = "";
            object.labelRgb = "";
        }
        if (message.labelId != null && message.hasOwnProperty("labelId"))
            object.labelId = message.labelId;
        if (message.labelName != null && message.hasOwnProperty("labelName"))
            object.labelName = message.labelName;
        if (message.labelRgb != null && message.hasOwnProperty("labelRgb"))
            object.labelRgb = message.labelRgb;
        return object;
    };

    /**
     * Converts this AlaCoverLabel to JSON.
     * @function toJSON
     * @memberof AlaCoverLabel
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AlaCoverLabel.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AlaCoverLabel
     * @function getTypeUrl
     * @memberof AlaCoverLabel
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AlaCoverLabel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AlaCoverLabel";
    };

    return AlaCoverLabel;
})();

export const AlaShareInfo = $root.AlaShareInfo = (() => {

    /**
     * Properties of an AlaShareInfo.
     * @exports IAlaShareInfo
     * @interface IAlaShareInfo
     * @property {string|null} [content] AlaShareInfo content
     * @property {number|null} [shareUserCount] AlaShareInfo shareUserCount
     * @property {number|null} [shareCount] AlaShareInfo shareCount
     * @property {number|Long|null} [recordTid] AlaShareInfo recordTid
     */

    /**
     * Constructs a new AlaShareInfo.
     * @exports AlaShareInfo
     * @classdesc Represents an AlaShareInfo.
     * @implements IAlaShareInfo
     * @constructor
     * @param {IAlaShareInfo=} [properties] Properties to set
     */
    function AlaShareInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AlaShareInfo content.
     * @member {string} content
     * @memberof AlaShareInfo
     * @instance
     */
    AlaShareInfo.prototype.content = "";

    /**
     * AlaShareInfo shareUserCount.
     * @member {number} shareUserCount
     * @memberof AlaShareInfo
     * @instance
     */
    AlaShareInfo.prototype.shareUserCount = 0;

    /**
     * AlaShareInfo shareCount.
     * @member {number} shareCount
     * @memberof AlaShareInfo
     * @instance
     */
    AlaShareInfo.prototype.shareCount = 0;

    /**
     * AlaShareInfo recordTid.
     * @member {number|Long} recordTid
     * @memberof AlaShareInfo
     * @instance
     */
    AlaShareInfo.prototype.recordTid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new AlaShareInfo instance using the specified properties.
     * @function create
     * @memberof AlaShareInfo
     * @static
     * @param {IAlaShareInfo=} [properties] Properties to set
     * @returns {AlaShareInfo} AlaShareInfo instance
     */
    AlaShareInfo.create = function create(properties) {
        return new AlaShareInfo(properties);
    };

    /**
     * Encodes the specified AlaShareInfo message. Does not implicitly {@link AlaShareInfo.verify|verify} messages.
     * @function encode
     * @memberof AlaShareInfo
     * @static
     * @param {IAlaShareInfo} message AlaShareInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaShareInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.content != null && Object.hasOwnProperty.call(message, "content"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
        if (message.shareUserCount != null && Object.hasOwnProperty.call(message, "shareUserCount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.shareUserCount);
        if (message.shareCount != null && Object.hasOwnProperty.call(message, "shareCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.shareCount);
        if (message.recordTid != null && Object.hasOwnProperty.call(message, "recordTid"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.recordTid);
        return writer;
    };

    /**
     * Encodes the specified AlaShareInfo message, length delimited. Does not implicitly {@link AlaShareInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AlaShareInfo
     * @static
     * @param {IAlaShareInfo} message AlaShareInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaShareInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AlaShareInfo message from the specified reader or buffer.
     * @function decode
     * @memberof AlaShareInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AlaShareInfo} AlaShareInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaShareInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlaShareInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.content = reader.string();
                    break;
                }
            case 2: {
                    message.shareUserCount = reader.int32();
                    break;
                }
            case 3: {
                    message.shareCount = reader.int32();
                    break;
                }
            case 4: {
                    message.recordTid = reader.int64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AlaShareInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AlaShareInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AlaShareInfo} AlaShareInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaShareInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AlaShareInfo message.
     * @function verify
     * @memberof AlaShareInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AlaShareInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.content != null && message.hasOwnProperty("content"))
            if (!$util.isString(message.content))
                return "content: string expected";
        if (message.shareUserCount != null && message.hasOwnProperty("shareUserCount"))
            if (!$util.isInteger(message.shareUserCount))
                return "shareUserCount: integer expected";
        if (message.shareCount != null && message.hasOwnProperty("shareCount"))
            if (!$util.isInteger(message.shareCount))
                return "shareCount: integer expected";
        if (message.recordTid != null && message.hasOwnProperty("recordTid"))
            if (!$util.isInteger(message.recordTid) && !(message.recordTid && $util.isInteger(message.recordTid.low) && $util.isInteger(message.recordTid.high)))
                return "recordTid: integer|Long expected";
        return null;
    };

    /**
     * Creates an AlaShareInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AlaShareInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AlaShareInfo} AlaShareInfo
     */
    AlaShareInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.AlaShareInfo)
            return object;
        let message = new $root.AlaShareInfo();
        if (object.content != null)
            message.content = String(object.content);
        if (object.shareUserCount != null)
            message.shareUserCount = object.shareUserCount | 0;
        if (object.shareCount != null)
            message.shareCount = object.shareCount | 0;
        if (object.recordTid != null)
            if ($util.Long)
                (message.recordTid = $util.Long.fromValue(object.recordTid)).unsigned = false;
            else if (typeof object.recordTid === "string")
                message.recordTid = parseInt(object.recordTid, 10);
            else if (typeof object.recordTid === "number")
                message.recordTid = object.recordTid;
            else if (typeof object.recordTid === "object")
                message.recordTid = new $util.LongBits(object.recordTid.low >>> 0, object.recordTid.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from an AlaShareInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AlaShareInfo
     * @static
     * @param {AlaShareInfo} message AlaShareInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AlaShareInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.content = "";
            object.shareUserCount = 0;
            object.shareCount = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.recordTid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.recordTid = options.longs === String ? "0" : 0;
        }
        if (message.content != null && message.hasOwnProperty("content"))
            object.content = message.content;
        if (message.shareUserCount != null && message.hasOwnProperty("shareUserCount"))
            object.shareUserCount = message.shareUserCount;
        if (message.shareCount != null && message.hasOwnProperty("shareCount"))
            object.shareCount = message.shareCount;
        if (message.recordTid != null && message.hasOwnProperty("recordTid"))
            if (typeof message.recordTid === "number")
                object.recordTid = options.longs === String ? String(message.recordTid) : message.recordTid;
            else
                object.recordTid = options.longs === String ? $util.Long.prototype.toString.call(message.recordTid) : options.longs === Number ? new $util.LongBits(message.recordTid.low >>> 0, message.recordTid.high >>> 0).toNumber() : message.recordTid;
        return object;
    };

    /**
     * Converts this AlaShareInfo to JSON.
     * @function toJSON
     * @memberof AlaShareInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AlaShareInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AlaShareInfo
     * @function getTypeUrl
     * @memberof AlaShareInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AlaShareInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AlaShareInfo";
    };

    return AlaShareInfo;
})();

export const AlaStageDislikeInfo = $root.AlaStageDislikeInfo = (() => {

    /**
     * Properties of an AlaStageDislikeInfo.
     * @exports IAlaStageDislikeInfo
     * @interface IAlaStageDislikeInfo
     * @property {string|null} [dislikeReason] AlaStageDislikeInfo dislikeReason
     * @property {number|null} [dislikeId] AlaStageDislikeInfo dislikeId
     */

    /**
     * Constructs a new AlaStageDislikeInfo.
     * @exports AlaStageDislikeInfo
     * @classdesc Represents an AlaStageDislikeInfo.
     * @implements IAlaStageDislikeInfo
     * @constructor
     * @param {IAlaStageDislikeInfo=} [properties] Properties to set
     */
    function AlaStageDislikeInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AlaStageDislikeInfo dislikeReason.
     * @member {string} dislikeReason
     * @memberof AlaStageDislikeInfo
     * @instance
     */
    AlaStageDislikeInfo.prototype.dislikeReason = "";

    /**
     * AlaStageDislikeInfo dislikeId.
     * @member {number} dislikeId
     * @memberof AlaStageDislikeInfo
     * @instance
     */
    AlaStageDislikeInfo.prototype.dislikeId = 0;

    /**
     * Creates a new AlaStageDislikeInfo instance using the specified properties.
     * @function create
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {IAlaStageDislikeInfo=} [properties] Properties to set
     * @returns {AlaStageDislikeInfo} AlaStageDislikeInfo instance
     */
    AlaStageDislikeInfo.create = function create(properties) {
        return new AlaStageDislikeInfo(properties);
    };

    /**
     * Encodes the specified AlaStageDislikeInfo message. Does not implicitly {@link AlaStageDislikeInfo.verify|verify} messages.
     * @function encode
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {IAlaStageDislikeInfo} message AlaStageDislikeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaStageDislikeInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dislikeReason != null && Object.hasOwnProperty.call(message, "dislikeReason"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.dislikeReason);
        if (message.dislikeId != null && Object.hasOwnProperty.call(message, "dislikeId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dislikeId);
        return writer;
    };

    /**
     * Encodes the specified AlaStageDislikeInfo message, length delimited. Does not implicitly {@link AlaStageDislikeInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {IAlaStageDislikeInfo} message AlaStageDislikeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaStageDislikeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AlaStageDislikeInfo message from the specified reader or buffer.
     * @function decode
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AlaStageDislikeInfo} AlaStageDislikeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaStageDislikeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlaStageDislikeInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.dislikeReason = reader.string();
                    break;
                }
            case 2: {
                    message.dislikeId = reader.uint32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AlaStageDislikeInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AlaStageDislikeInfo} AlaStageDislikeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaStageDislikeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AlaStageDislikeInfo message.
     * @function verify
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AlaStageDislikeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
            if (!$util.isString(message.dislikeReason))
                return "dislikeReason: string expected";
        if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
            if (!$util.isInteger(message.dislikeId))
                return "dislikeId: integer expected";
        return null;
    };

    /**
     * Creates an AlaStageDislikeInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AlaStageDislikeInfo} AlaStageDislikeInfo
     */
    AlaStageDislikeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.AlaStageDislikeInfo)
            return object;
        let message = new $root.AlaStageDislikeInfo();
        if (object.dislikeReason != null)
            message.dislikeReason = String(object.dislikeReason);
        if (object.dislikeId != null)
            message.dislikeId = object.dislikeId >>> 0;
        return message;
    };

    /**
     * Creates a plain object from an AlaStageDislikeInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {AlaStageDislikeInfo} message AlaStageDislikeInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AlaStageDislikeInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.dislikeReason = "";
            object.dislikeId = 0;
        }
        if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
            object.dislikeReason = message.dislikeReason;
        if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
            object.dislikeId = message.dislikeId;
        return object;
    };

    /**
     * Converts this AlaStageDislikeInfo to JSON.
     * @function toJSON
     * @memberof AlaStageDislikeInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AlaStageDislikeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AlaStageDislikeInfo
     * @function getTypeUrl
     * @memberof AlaStageDislikeInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AlaStageDislikeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AlaStageDislikeInfo";
    };

    return AlaStageDislikeInfo;
})();

export const AlaUserInfo = $root.AlaUserInfo = (() => {

    /**
     * Properties of an AlaUserInfo.
     * @exports IAlaUserInfo
     * @interface IAlaUserInfo
     * @property {number|Long|null} [alaId] AlaUserInfo alaId
     * @property {string|null} [userName] AlaUserInfo userName
     * @property {string|null} [portrait] AlaUserInfo portrait
     * @property {string|null} [description] AlaUserInfo description
     * @property {string|null} [sex] AlaUserInfo sex
     * @property {number|Long|null} [enterLive] AlaUserInfo enterLive
     * @property {number|Long|null} [anchorLive] AlaUserInfo anchorLive
     * @property {number|null} [liveStatus] AlaUserInfo liveStatus
     * @property {number|Long|null} [liveId] AlaUserInfo liveId
     * @property {string|null} [location] AlaUserInfo location
     * @property {number|null} [lng] AlaUserInfo lng
     * @property {number|null} [lat] AlaUserInfo lat
     * @property {number|null} [updateTime] AlaUserInfo updateTime
     * @property {number|Long|null} [charmCount] AlaUserInfo charmCount
     * @property {number|Long|null} [levelExp] AlaUserInfo levelExp
     * @property {number|null} [isOfficial] AlaUserInfo isOfficial
     * @property {string|null} [verifyStatus] AlaUserInfo verifyStatus
     * @property {number|null} [levelId] AlaUserInfo levelId
     * @property {string|null} [greatAnchorIcon] AlaUserInfo greatAnchorIcon
     * @property {string|null} [greatAnchorDescGrade] AlaUserInfo greatAnchorDescGrade
     * @property {string|null} [greatAnchorDescRole] AlaUserInfo greatAnchorDescRole
     * @property {string|null} [levelName] AlaUserInfo levelName
     * @property {number|Long|null} [userId] AlaUserInfo userId
     * @property {number|null} [anchorFans] AlaUserInfo anchorFans
     * @property {IYyExt|null} [yyExt] AlaUserInfo yyExt
     */

    /**
     * Constructs a new AlaUserInfo.
     * @exports AlaUserInfo
     * @classdesc Represents an AlaUserInfo.
     * @implements IAlaUserInfo
     * @constructor
     * @param {IAlaUserInfo=} [properties] Properties to set
     */
    function AlaUserInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AlaUserInfo alaId.
     * @member {number|Long} alaId
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.alaId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaUserInfo userName.
     * @member {string} userName
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.userName = "";

    /**
     * AlaUserInfo portrait.
     * @member {string} portrait
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.portrait = "";

    /**
     * AlaUserInfo description.
     * @member {string} description
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.description = "";

    /**
     * AlaUserInfo sex.
     * @member {string} sex
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.sex = "";

    /**
     * AlaUserInfo enterLive.
     * @member {number|Long} enterLive
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.enterLive = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaUserInfo anchorLive.
     * @member {number|Long} anchorLive
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.anchorLive = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaUserInfo liveStatus.
     * @member {number} liveStatus
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.liveStatus = 0;

    /**
     * AlaUserInfo liveId.
     * @member {number|Long} liveId
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.liveId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaUserInfo location.
     * @member {string} location
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.location = "";

    /**
     * AlaUserInfo lng.
     * @member {number} lng
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.lng = 0;

    /**
     * AlaUserInfo lat.
     * @member {number} lat
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.lat = 0;

    /**
     * AlaUserInfo updateTime.
     * @member {number} updateTime
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.updateTime = 0;

    /**
     * AlaUserInfo charmCount.
     * @member {number|Long} charmCount
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.charmCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaUserInfo levelExp.
     * @member {number|Long} levelExp
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.levelExp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaUserInfo isOfficial.
     * @member {number} isOfficial
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.isOfficial = 0;

    /**
     * AlaUserInfo verifyStatus.
     * @member {string} verifyStatus
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.verifyStatus = "";

    /**
     * AlaUserInfo levelId.
     * @member {number} levelId
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.levelId = 0;

    /**
     * AlaUserInfo greatAnchorIcon.
     * @member {string} greatAnchorIcon
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.greatAnchorIcon = "";

    /**
     * AlaUserInfo greatAnchorDescGrade.
     * @member {string} greatAnchorDescGrade
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.greatAnchorDescGrade = "";

    /**
     * AlaUserInfo greatAnchorDescRole.
     * @member {string} greatAnchorDescRole
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.greatAnchorDescRole = "";

    /**
     * AlaUserInfo levelName.
     * @member {string} levelName
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.levelName = "";

    /**
     * AlaUserInfo userId.
     * @member {number|Long} userId
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AlaUserInfo anchorFans.
     * @member {number} anchorFans
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.anchorFans = 0;

    /**
     * AlaUserInfo yyExt.
     * @member {IYyExt|null|undefined} yyExt
     * @memberof AlaUserInfo
     * @instance
     */
    AlaUserInfo.prototype.yyExt = null;

    /**
     * Creates a new AlaUserInfo instance using the specified properties.
     * @function create
     * @memberof AlaUserInfo
     * @static
     * @param {IAlaUserInfo=} [properties] Properties to set
     * @returns {AlaUserInfo} AlaUserInfo instance
     */
    AlaUserInfo.create = function create(properties) {
        return new AlaUserInfo(properties);
    };

    /**
     * Encodes the specified AlaUserInfo message. Does not implicitly {@link AlaUserInfo.verify|verify} messages.
     * @function encode
     * @memberof AlaUserInfo
     * @static
     * @param {IAlaUserInfo} message AlaUserInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaUserInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.alaId != null && Object.hasOwnProperty.call(message, "alaId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.alaId);
        if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.userName);
        if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.portrait);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
        if (message.sex != null && Object.hasOwnProperty.call(message, "sex"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.sex);
        if (message.enterLive != null && Object.hasOwnProperty.call(message, "enterLive"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.enterLive);
        if (message.anchorLive != null && Object.hasOwnProperty.call(message, "anchorLive"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.anchorLive);
        if (message.liveStatus != null && Object.hasOwnProperty.call(message, "liveStatus"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.liveStatus);
        if (message.liveId != null && Object.hasOwnProperty.call(message, "liveId"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.liveId);
        if (message.location != null && Object.hasOwnProperty.call(message, "location"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.location);
        if (message.lng != null && Object.hasOwnProperty.call(message, "lng"))
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.lng);
        if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.lat);
        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.updateTime);
        if (message.charmCount != null && Object.hasOwnProperty.call(message, "charmCount"))
            writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.charmCount);
        if (message.levelExp != null && Object.hasOwnProperty.call(message, "levelExp"))
            writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.levelExp);
        if (message.isOfficial != null && Object.hasOwnProperty.call(message, "isOfficial"))
            writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.isOfficial);
        if (message.verifyStatus != null && Object.hasOwnProperty.call(message, "verifyStatus"))
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.verifyStatus);
        if (message.levelId != null && Object.hasOwnProperty.call(message, "levelId"))
            writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.levelId);
        if (message.greatAnchorIcon != null && Object.hasOwnProperty.call(message, "greatAnchorIcon"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.greatAnchorIcon);
        if (message.greatAnchorDescGrade != null && Object.hasOwnProperty.call(message, "greatAnchorDescGrade"))
            writer.uint32(/* id 20, wireType 2 =*/162).string(message.greatAnchorDescGrade);
        if (message.greatAnchorDescRole != null && Object.hasOwnProperty.call(message, "greatAnchorDescRole"))
            writer.uint32(/* id 21, wireType 2 =*/170).string(message.greatAnchorDescRole);
        if (message.levelName != null && Object.hasOwnProperty.call(message, "levelName"))
            writer.uint32(/* id 22, wireType 2 =*/178).string(message.levelName);
        if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
            writer.uint32(/* id 23, wireType 0 =*/184).uint64(message.userId);
        if (message.anchorFans != null && Object.hasOwnProperty.call(message, "anchorFans"))
            writer.uint32(/* id 24, wireType 0 =*/192).int32(message.anchorFans);
        if (message.yyExt != null && Object.hasOwnProperty.call(message, "yyExt"))
            $root.YyExt.encode(message.yyExt, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AlaUserInfo message, length delimited. Does not implicitly {@link AlaUserInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AlaUserInfo
     * @static
     * @param {IAlaUserInfo} message AlaUserInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AlaUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AlaUserInfo message from the specified reader or buffer.
     * @function decode
     * @memberof AlaUserInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AlaUserInfo} AlaUserInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaUserInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AlaUserInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.alaId = reader.uint64();
                    break;
                }
            case 2: {
                    message.userName = reader.string();
                    break;
                }
            case 3: {
                    message.portrait = reader.string();
                    break;
                }
            case 4: {
                    message.description = reader.string();
                    break;
                }
            case 5: {
                    message.sex = reader.string();
                    break;
                }
            case 6: {
                    message.enterLive = reader.uint64();
                    break;
                }
            case 7: {
                    message.anchorLive = reader.uint64();
                    break;
                }
            case 8: {
                    message.liveStatus = reader.uint32();
                    break;
                }
            case 9: {
                    message.liveId = reader.uint64();
                    break;
                }
            case 10: {
                    message.location = reader.string();
                    break;
                }
            case 11: {
                    message.lng = reader.double();
                    break;
                }
            case 12: {
                    message.lat = reader.double();
                    break;
                }
            case 13: {
                    message.updateTime = reader.uint32();
                    break;
                }
            case 14: {
                    message.charmCount = reader.uint64();
                    break;
                }
            case 15: {
                    message.levelExp = reader.uint64();
                    break;
                }
            case 16: {
                    message.isOfficial = reader.uint32();
                    break;
                }
            case 17: {
                    message.verifyStatus = reader.string();
                    break;
                }
            case 18: {
                    message.levelId = reader.uint32();
                    break;
                }
            case 19: {
                    message.greatAnchorIcon = reader.string();
                    break;
                }
            case 20: {
                    message.greatAnchorDescGrade = reader.string();
                    break;
                }
            case 21: {
                    message.greatAnchorDescRole = reader.string();
                    break;
                }
            case 22: {
                    message.levelName = reader.string();
                    break;
                }
            case 23: {
                    message.userId = reader.uint64();
                    break;
                }
            case 24: {
                    message.anchorFans = reader.int32();
                    break;
                }
            case 25: {
                    message.yyExt = $root.YyExt.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AlaUserInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AlaUserInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AlaUserInfo} AlaUserInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AlaUserInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AlaUserInfo message.
     * @function verify
     * @memberof AlaUserInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AlaUserInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.alaId != null && message.hasOwnProperty("alaId"))
            if (!$util.isInteger(message.alaId) && !(message.alaId && $util.isInteger(message.alaId.low) && $util.isInteger(message.alaId.high)))
                return "alaId: integer|Long expected";
        if (message.userName != null && message.hasOwnProperty("userName"))
            if (!$util.isString(message.userName))
                return "userName: string expected";
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            if (!$util.isString(message.portrait))
                return "portrait: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.sex != null && message.hasOwnProperty("sex"))
            if (!$util.isString(message.sex))
                return "sex: string expected";
        if (message.enterLive != null && message.hasOwnProperty("enterLive"))
            if (!$util.isInteger(message.enterLive) && !(message.enterLive && $util.isInteger(message.enterLive.low) && $util.isInteger(message.enterLive.high)))
                return "enterLive: integer|Long expected";
        if (message.anchorLive != null && message.hasOwnProperty("anchorLive"))
            if (!$util.isInteger(message.anchorLive) && !(message.anchorLive && $util.isInteger(message.anchorLive.low) && $util.isInteger(message.anchorLive.high)))
                return "anchorLive: integer|Long expected";
        if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
            if (!$util.isInteger(message.liveStatus))
                return "liveStatus: integer expected";
        if (message.liveId != null && message.hasOwnProperty("liveId"))
            if (!$util.isInteger(message.liveId) && !(message.liveId && $util.isInteger(message.liveId.low) && $util.isInteger(message.liveId.high)))
                return "liveId: integer|Long expected";
        if (message.location != null && message.hasOwnProperty("location"))
            if (!$util.isString(message.location))
                return "location: string expected";
        if (message.lng != null && message.hasOwnProperty("lng"))
            if (typeof message.lng !== "number")
                return "lng: number expected";
        if (message.lat != null && message.hasOwnProperty("lat"))
            if (typeof message.lat !== "number")
                return "lat: number expected";
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            if (!$util.isInteger(message.updateTime))
                return "updateTime: integer expected";
        if (message.charmCount != null && message.hasOwnProperty("charmCount"))
            if (!$util.isInteger(message.charmCount) && !(message.charmCount && $util.isInteger(message.charmCount.low) && $util.isInteger(message.charmCount.high)))
                return "charmCount: integer|Long expected";
        if (message.levelExp != null && message.hasOwnProperty("levelExp"))
            if (!$util.isInteger(message.levelExp) && !(message.levelExp && $util.isInteger(message.levelExp.low) && $util.isInteger(message.levelExp.high)))
                return "levelExp: integer|Long expected";
        if (message.isOfficial != null && message.hasOwnProperty("isOfficial"))
            if (!$util.isInteger(message.isOfficial))
                return "isOfficial: integer expected";
        if (message.verifyStatus != null && message.hasOwnProperty("verifyStatus"))
            if (!$util.isString(message.verifyStatus))
                return "verifyStatus: string expected";
        if (message.levelId != null && message.hasOwnProperty("levelId"))
            if (!$util.isInteger(message.levelId))
                return "levelId: integer expected";
        if (message.greatAnchorIcon != null && message.hasOwnProperty("greatAnchorIcon"))
            if (!$util.isString(message.greatAnchorIcon))
                return "greatAnchorIcon: string expected";
        if (message.greatAnchorDescGrade != null && message.hasOwnProperty("greatAnchorDescGrade"))
            if (!$util.isString(message.greatAnchorDescGrade))
                return "greatAnchorDescGrade: string expected";
        if (message.greatAnchorDescRole != null && message.hasOwnProperty("greatAnchorDescRole"))
            if (!$util.isString(message.greatAnchorDescRole))
                return "greatAnchorDescRole: string expected";
        if (message.levelName != null && message.hasOwnProperty("levelName"))
            if (!$util.isString(message.levelName))
                return "levelName: string expected";
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                return "userId: integer|Long expected";
        if (message.anchorFans != null && message.hasOwnProperty("anchorFans"))
            if (!$util.isInteger(message.anchorFans))
                return "anchorFans: integer expected";
        if (message.yyExt != null && message.hasOwnProperty("yyExt")) {
            let error = $root.YyExt.verify(message.yyExt);
            if (error)
                return "yyExt." + error;
        }
        return null;
    };

    /**
     * Creates an AlaUserInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AlaUserInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AlaUserInfo} AlaUserInfo
     */
    AlaUserInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.AlaUserInfo)
            return object;
        let message = new $root.AlaUserInfo();
        if (object.alaId != null)
            if ($util.Long)
                (message.alaId = $util.Long.fromValue(object.alaId)).unsigned = true;
            else if (typeof object.alaId === "string")
                message.alaId = parseInt(object.alaId, 10);
            else if (typeof object.alaId === "number")
                message.alaId = object.alaId;
            else if (typeof object.alaId === "object")
                message.alaId = new $util.LongBits(object.alaId.low >>> 0, object.alaId.high >>> 0).toNumber(true);
        if (object.userName != null)
            message.userName = String(object.userName);
        if (object.portrait != null)
            message.portrait = String(object.portrait);
        if (object.description != null)
            message.description = String(object.description);
        if (object.sex != null)
            message.sex = String(object.sex);
        if (object.enterLive != null)
            if ($util.Long)
                (message.enterLive = $util.Long.fromValue(object.enterLive)).unsigned = true;
            else if (typeof object.enterLive === "string")
                message.enterLive = parseInt(object.enterLive, 10);
            else if (typeof object.enterLive === "number")
                message.enterLive = object.enterLive;
            else if (typeof object.enterLive === "object")
                message.enterLive = new $util.LongBits(object.enterLive.low >>> 0, object.enterLive.high >>> 0).toNumber(true);
        if (object.anchorLive != null)
            if ($util.Long)
                (message.anchorLive = $util.Long.fromValue(object.anchorLive)).unsigned = true;
            else if (typeof object.anchorLive === "string")
                message.anchorLive = parseInt(object.anchorLive, 10);
            else if (typeof object.anchorLive === "number")
                message.anchorLive = object.anchorLive;
            else if (typeof object.anchorLive === "object")
                message.anchorLive = new $util.LongBits(object.anchorLive.low >>> 0, object.anchorLive.high >>> 0).toNumber(true);
        if (object.liveStatus != null)
            message.liveStatus = object.liveStatus >>> 0;
        if (object.liveId != null)
            if ($util.Long)
                (message.liveId = $util.Long.fromValue(object.liveId)).unsigned = true;
            else if (typeof object.liveId === "string")
                message.liveId = parseInt(object.liveId, 10);
            else if (typeof object.liveId === "number")
                message.liveId = object.liveId;
            else if (typeof object.liveId === "object")
                message.liveId = new $util.LongBits(object.liveId.low >>> 0, object.liveId.high >>> 0).toNumber(true);
        if (object.location != null)
            message.location = String(object.location);
        if (object.lng != null)
            message.lng = Number(object.lng);
        if (object.lat != null)
            message.lat = Number(object.lat);
        if (object.updateTime != null)
            message.updateTime = object.updateTime >>> 0;
        if (object.charmCount != null)
            if ($util.Long)
                (message.charmCount = $util.Long.fromValue(object.charmCount)).unsigned = true;
            else if (typeof object.charmCount === "string")
                message.charmCount = parseInt(object.charmCount, 10);
            else if (typeof object.charmCount === "number")
                message.charmCount = object.charmCount;
            else if (typeof object.charmCount === "object")
                message.charmCount = new $util.LongBits(object.charmCount.low >>> 0, object.charmCount.high >>> 0).toNumber(true);
        if (object.levelExp != null)
            if ($util.Long)
                (message.levelExp = $util.Long.fromValue(object.levelExp)).unsigned = true;
            else if (typeof object.levelExp === "string")
                message.levelExp = parseInt(object.levelExp, 10);
            else if (typeof object.levelExp === "number")
                message.levelExp = object.levelExp;
            else if (typeof object.levelExp === "object")
                message.levelExp = new $util.LongBits(object.levelExp.low >>> 0, object.levelExp.high >>> 0).toNumber(true);
        if (object.isOfficial != null)
            message.isOfficial = object.isOfficial >>> 0;
        if (object.verifyStatus != null)
            message.verifyStatus = String(object.verifyStatus);
        if (object.levelId != null)
            message.levelId = object.levelId >>> 0;
        if (object.greatAnchorIcon != null)
            message.greatAnchorIcon = String(object.greatAnchorIcon);
        if (object.greatAnchorDescGrade != null)
            message.greatAnchorDescGrade = String(object.greatAnchorDescGrade);
        if (object.greatAnchorDescRole != null)
            message.greatAnchorDescRole = String(object.greatAnchorDescRole);
        if (object.levelName != null)
            message.levelName = String(object.levelName);
        if (object.userId != null)
            if ($util.Long)
                (message.userId = $util.Long.fromValue(object.userId)).unsigned = true;
            else if (typeof object.userId === "string")
                message.userId = parseInt(object.userId, 10);
            else if (typeof object.userId === "number")
                message.userId = object.userId;
            else if (typeof object.userId === "object")
                message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber(true);
        if (object.anchorFans != null)
            message.anchorFans = object.anchorFans | 0;
        if (object.yyExt != null) {
            if (typeof object.yyExt !== "object")
                throw TypeError(".AlaUserInfo.yyExt: object expected");
            message.yyExt = $root.YyExt.fromObject(object.yyExt);
        }
        return message;
    };

    /**
     * Creates a plain object from an AlaUserInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AlaUserInfo
     * @static
     * @param {AlaUserInfo} message AlaUserInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AlaUserInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.alaId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.alaId = options.longs === String ? "0" : 0;
            object.userName = "";
            object.portrait = "";
            object.description = "";
            object.sex = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.enterLive = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.enterLive = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.anchorLive = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.anchorLive = options.longs === String ? "0" : 0;
            object.liveStatus = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.liveId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.liveId = options.longs === String ? "0" : 0;
            object.location = "";
            object.lng = 0;
            object.lat = 0;
            object.updateTime = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.charmCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.charmCount = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.levelExp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.levelExp = options.longs === String ? "0" : 0;
            object.isOfficial = 0;
            object.verifyStatus = "";
            object.levelId = 0;
            object.greatAnchorIcon = "";
            object.greatAnchorDescGrade = "";
            object.greatAnchorDescRole = "";
            object.levelName = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.userId = options.longs === String ? "0" : 0;
            object.anchorFans = 0;
            object.yyExt = null;
        }
        if (message.alaId != null && message.hasOwnProperty("alaId"))
            if (typeof message.alaId === "number")
                object.alaId = options.longs === String ? String(message.alaId) : message.alaId;
            else
                object.alaId = options.longs === String ? $util.Long.prototype.toString.call(message.alaId) : options.longs === Number ? new $util.LongBits(message.alaId.low >>> 0, message.alaId.high >>> 0).toNumber(true) : message.alaId;
        if (message.userName != null && message.hasOwnProperty("userName"))
            object.userName = message.userName;
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            object.portrait = message.portrait;
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.sex != null && message.hasOwnProperty("sex"))
            object.sex = message.sex;
        if (message.enterLive != null && message.hasOwnProperty("enterLive"))
            if (typeof message.enterLive === "number")
                object.enterLive = options.longs === String ? String(message.enterLive) : message.enterLive;
            else
                object.enterLive = options.longs === String ? $util.Long.prototype.toString.call(message.enterLive) : options.longs === Number ? new $util.LongBits(message.enterLive.low >>> 0, message.enterLive.high >>> 0).toNumber(true) : message.enterLive;
        if (message.anchorLive != null && message.hasOwnProperty("anchorLive"))
            if (typeof message.anchorLive === "number")
                object.anchorLive = options.longs === String ? String(message.anchorLive) : message.anchorLive;
            else
                object.anchorLive = options.longs === String ? $util.Long.prototype.toString.call(message.anchorLive) : options.longs === Number ? new $util.LongBits(message.anchorLive.low >>> 0, message.anchorLive.high >>> 0).toNumber(true) : message.anchorLive;
        if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
            object.liveStatus = message.liveStatus;
        if (message.liveId != null && message.hasOwnProperty("liveId"))
            if (typeof message.liveId === "number")
                object.liveId = options.longs === String ? String(message.liveId) : message.liveId;
            else
                object.liveId = options.longs === String ? $util.Long.prototype.toString.call(message.liveId) : options.longs === Number ? new $util.LongBits(message.liveId.low >>> 0, message.liveId.high >>> 0).toNumber(true) : message.liveId;
        if (message.location != null && message.hasOwnProperty("location"))
            object.location = message.location;
        if (message.lng != null && message.hasOwnProperty("lng"))
            object.lng = options.json && !isFinite(message.lng) ? String(message.lng) : message.lng;
        if (message.lat != null && message.hasOwnProperty("lat"))
            object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            object.updateTime = message.updateTime;
        if (message.charmCount != null && message.hasOwnProperty("charmCount"))
            if (typeof message.charmCount === "number")
                object.charmCount = options.longs === String ? String(message.charmCount) : message.charmCount;
            else
                object.charmCount = options.longs === String ? $util.Long.prototype.toString.call(message.charmCount) : options.longs === Number ? new $util.LongBits(message.charmCount.low >>> 0, message.charmCount.high >>> 0).toNumber(true) : message.charmCount;
        if (message.levelExp != null && message.hasOwnProperty("levelExp"))
            if (typeof message.levelExp === "number")
                object.levelExp = options.longs === String ? String(message.levelExp) : message.levelExp;
            else
                object.levelExp = options.longs === String ? $util.Long.prototype.toString.call(message.levelExp) : options.longs === Number ? new $util.LongBits(message.levelExp.low >>> 0, message.levelExp.high >>> 0).toNumber(true) : message.levelExp;
        if (message.isOfficial != null && message.hasOwnProperty("isOfficial"))
            object.isOfficial = message.isOfficial;
        if (message.verifyStatus != null && message.hasOwnProperty("verifyStatus"))
            object.verifyStatus = message.verifyStatus;
        if (message.levelId != null && message.hasOwnProperty("levelId"))
            object.levelId = message.levelId;
        if (message.greatAnchorIcon != null && message.hasOwnProperty("greatAnchorIcon"))
            object.greatAnchorIcon = message.greatAnchorIcon;
        if (message.greatAnchorDescGrade != null && message.hasOwnProperty("greatAnchorDescGrade"))
            object.greatAnchorDescGrade = message.greatAnchorDescGrade;
        if (message.greatAnchorDescRole != null && message.hasOwnProperty("greatAnchorDescRole"))
            object.greatAnchorDescRole = message.greatAnchorDescRole;
        if (message.levelName != null && message.hasOwnProperty("levelName"))
            object.levelName = message.levelName;
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (typeof message.userId === "number")
                object.userId = options.longs === String ? String(message.userId) : message.userId;
            else
                object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber(true) : message.userId;
        if (message.anchorFans != null && message.hasOwnProperty("anchorFans"))
            object.anchorFans = message.anchorFans;
        if (message.yyExt != null && message.hasOwnProperty("yyExt"))
            object.yyExt = $root.YyExt.toObject(message.yyExt, options);
        return object;
    };

    /**
     * Converts this AlaUserInfo to JSON.
     * @function toJSON
     * @memberof AlaUserInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AlaUserInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AlaUserInfo
     * @function getTypeUrl
     * @memberof AlaUserInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AlaUserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AlaUserInfo";
    };

    return AlaUserInfo;
})();

export const YyExt = $root.YyExt = (() => {

    /**
     * Properties of a YyExt.
     * @exports IYyExt
     * @interface IYyExt
     * @property {string|null} [sid] YyExt sid
     * @property {string|null} [ssid] YyExt ssid
     * @property {string|null} [templateId] YyExt templateId
     * @property {string|null} [yyUid] YyExt yyUid
     * @property {number|null} [isYyGame] YyExt isYyGame
     * @property {string|null} [streamInfo] YyExt streamInfo
     * @property {string|null} [rankShow] YyExt rankShow
     * @property {string|null} [iconUrl] YyExt iconUrl
     * @property {string|null} [feedId] YyExt feedId
     */

    /**
     * Constructs a new YyExt.
     * @exports YyExt
     * @classdesc Represents a YyExt.
     * @implements IYyExt
     * @constructor
     * @param {IYyExt=} [properties] Properties to set
     */
    function YyExt(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * YyExt sid.
     * @member {string} sid
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.sid = "";

    /**
     * YyExt ssid.
     * @member {string} ssid
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.ssid = "";

    /**
     * YyExt templateId.
     * @member {string} templateId
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.templateId = "";

    /**
     * YyExt yyUid.
     * @member {string} yyUid
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.yyUid = "";

    /**
     * YyExt isYyGame.
     * @member {number} isYyGame
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.isYyGame = 0;

    /**
     * YyExt streamInfo.
     * @member {string} streamInfo
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.streamInfo = "";

    /**
     * YyExt rankShow.
     * @member {string} rankShow
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.rankShow = "";

    /**
     * YyExt iconUrl.
     * @member {string} iconUrl
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.iconUrl = "";

    /**
     * YyExt feedId.
     * @member {string} feedId
     * @memberof YyExt
     * @instance
     */
    YyExt.prototype.feedId = "";

    /**
     * Creates a new YyExt instance using the specified properties.
     * @function create
     * @memberof YyExt
     * @static
     * @param {IYyExt=} [properties] Properties to set
     * @returns {YyExt} YyExt instance
     */
    YyExt.create = function create(properties) {
        return new YyExt(properties);
    };

    /**
     * Encodes the specified YyExt message. Does not implicitly {@link YyExt.verify|verify} messages.
     * @function encode
     * @memberof YyExt
     * @static
     * @param {IYyExt} message YyExt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    YyExt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sid);
        if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ssid);
        if (message.templateId != null && Object.hasOwnProperty.call(message, "templateId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.templateId);
        if (message.yyUid != null && Object.hasOwnProperty.call(message, "yyUid"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.yyUid);
        if (message.isYyGame != null && Object.hasOwnProperty.call(message, "isYyGame"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.isYyGame);
        if (message.streamInfo != null && Object.hasOwnProperty.call(message, "streamInfo"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.streamInfo);
        if (message.rankShow != null && Object.hasOwnProperty.call(message, "rankShow"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.rankShow);
        if (message.iconUrl != null && Object.hasOwnProperty.call(message, "iconUrl"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.iconUrl);
        if (message.feedId != null && Object.hasOwnProperty.call(message, "feedId"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.feedId);
        return writer;
    };

    /**
     * Encodes the specified YyExt message, length delimited. Does not implicitly {@link YyExt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof YyExt
     * @static
     * @param {IYyExt} message YyExt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    YyExt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a YyExt message from the specified reader or buffer.
     * @function decode
     * @memberof YyExt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {YyExt} YyExt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    YyExt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.YyExt();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.sid = reader.string();
                    break;
                }
            case 2: {
                    message.ssid = reader.string();
                    break;
                }
            case 3: {
                    message.templateId = reader.string();
                    break;
                }
            case 4: {
                    message.yyUid = reader.string();
                    break;
                }
            case 5: {
                    message.isYyGame = reader.int32();
                    break;
                }
            case 6: {
                    message.streamInfo = reader.string();
                    break;
                }
            case 7: {
                    message.rankShow = reader.string();
                    break;
                }
            case 8: {
                    message.iconUrl = reader.string();
                    break;
                }
            case 9: {
                    message.feedId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a YyExt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof YyExt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {YyExt} YyExt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    YyExt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a YyExt message.
     * @function verify
     * @memberof YyExt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    YyExt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sid != null && message.hasOwnProperty("sid"))
            if (!$util.isString(message.sid))
                return "sid: string expected";
        if (message.ssid != null && message.hasOwnProperty("ssid"))
            if (!$util.isString(message.ssid))
                return "ssid: string expected";
        if (message.templateId != null && message.hasOwnProperty("templateId"))
            if (!$util.isString(message.templateId))
                return "templateId: string expected";
        if (message.yyUid != null && message.hasOwnProperty("yyUid"))
            if (!$util.isString(message.yyUid))
                return "yyUid: string expected";
        if (message.isYyGame != null && message.hasOwnProperty("isYyGame"))
            if (!$util.isInteger(message.isYyGame))
                return "isYyGame: integer expected";
        if (message.streamInfo != null && message.hasOwnProperty("streamInfo"))
            if (!$util.isString(message.streamInfo))
                return "streamInfo: string expected";
        if (message.rankShow != null && message.hasOwnProperty("rankShow"))
            if (!$util.isString(message.rankShow))
                return "rankShow: string expected";
        if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
            if (!$util.isString(message.iconUrl))
                return "iconUrl: string expected";
        if (message.feedId != null && message.hasOwnProperty("feedId"))
            if (!$util.isString(message.feedId))
                return "feedId: string expected";
        return null;
    };

    /**
     * Creates a YyExt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof YyExt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {YyExt} YyExt
     */
    YyExt.fromObject = function fromObject(object) {
        if (object instanceof $root.YyExt)
            return object;
        let message = new $root.YyExt();
        if (object.sid != null)
            message.sid = String(object.sid);
        if (object.ssid != null)
            message.ssid = String(object.ssid);
        if (object.templateId != null)
            message.templateId = String(object.templateId);
        if (object.yyUid != null)
            message.yyUid = String(object.yyUid);
        if (object.isYyGame != null)
            message.isYyGame = object.isYyGame | 0;
        if (object.streamInfo != null)
            message.streamInfo = String(object.streamInfo);
        if (object.rankShow != null)
            message.rankShow = String(object.rankShow);
        if (object.iconUrl != null)
            message.iconUrl = String(object.iconUrl);
        if (object.feedId != null)
            message.feedId = String(object.feedId);
        return message;
    };

    /**
     * Creates a plain object from a YyExt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof YyExt
     * @static
     * @param {YyExt} message YyExt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    YyExt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.sid = "";
            object.ssid = "";
            object.templateId = "";
            object.yyUid = "";
            object.isYyGame = 0;
            object.streamInfo = "";
            object.rankShow = "";
            object.iconUrl = "";
            object.feedId = "";
        }
        if (message.sid != null && message.hasOwnProperty("sid"))
            object.sid = message.sid;
        if (message.ssid != null && message.hasOwnProperty("ssid"))
            object.ssid = message.ssid;
        if (message.templateId != null && message.hasOwnProperty("templateId"))
            object.templateId = message.templateId;
        if (message.yyUid != null && message.hasOwnProperty("yyUid"))
            object.yyUid = message.yyUid;
        if (message.isYyGame != null && message.hasOwnProperty("isYyGame"))
            object.isYyGame = message.isYyGame;
        if (message.streamInfo != null && message.hasOwnProperty("streamInfo"))
            object.streamInfo = message.streamInfo;
        if (message.rankShow != null && message.hasOwnProperty("rankShow"))
            object.rankShow = message.rankShow;
        if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
            object.iconUrl = message.iconUrl;
        if (message.feedId != null && message.hasOwnProperty("feedId"))
            object.feedId = message.feedId;
        return object;
    };

    /**
     * Converts this YyExt to JSON.
     * @function toJSON
     * @memberof YyExt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    YyExt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for YyExt
     * @function getTypeUrl
     * @memberof YyExt
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    YyExt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/YyExt";
    };

    return YyExt;
})();

export const DislikeInfo = $root.DislikeInfo = (() => {

    /**
     * Properties of a DislikeInfo.
     * @exports IDislikeInfo
     * @interface IDislikeInfo
     * @property {string|null} [dislikeReason] DislikeInfo dislikeReason
     * @property {number|null} [dislikeId] DislikeInfo dislikeId
     * @property {string|null} [extra] DislikeInfo extra
     */

    /**
     * Constructs a new DislikeInfo.
     * @exports DislikeInfo
     * @classdesc Represents a DislikeInfo.
     * @implements IDislikeInfo
     * @constructor
     * @param {IDislikeInfo=} [properties] Properties to set
     */
    function DislikeInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DislikeInfo dislikeReason.
     * @member {string} dislikeReason
     * @memberof DislikeInfo
     * @instance
     */
    DislikeInfo.prototype.dislikeReason = "";

    /**
     * DislikeInfo dislikeId.
     * @member {number} dislikeId
     * @memberof DislikeInfo
     * @instance
     */
    DislikeInfo.prototype.dislikeId = 0;

    /**
     * DislikeInfo extra.
     * @member {string} extra
     * @memberof DislikeInfo
     * @instance
     */
    DislikeInfo.prototype.extra = "";

    /**
     * Creates a new DislikeInfo instance using the specified properties.
     * @function create
     * @memberof DislikeInfo
     * @static
     * @param {IDislikeInfo=} [properties] Properties to set
     * @returns {DislikeInfo} DislikeInfo instance
     */
    DislikeInfo.create = function create(properties) {
        return new DislikeInfo(properties);
    };

    /**
     * Encodes the specified DislikeInfo message. Does not implicitly {@link DislikeInfo.verify|verify} messages.
     * @function encode
     * @memberof DislikeInfo
     * @static
     * @param {IDislikeInfo} message DislikeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DislikeInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dislikeReason != null && Object.hasOwnProperty.call(message, "dislikeReason"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.dislikeReason);
        if (message.dislikeId != null && Object.hasOwnProperty.call(message, "dislikeId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dislikeId);
        if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.extra);
        return writer;
    };

    /**
     * Encodes the specified DislikeInfo message, length delimited. Does not implicitly {@link DislikeInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DislikeInfo
     * @static
     * @param {IDislikeInfo} message DislikeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DislikeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DislikeInfo message from the specified reader or buffer.
     * @function decode
     * @memberof DislikeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DislikeInfo} DislikeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DislikeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DislikeInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.dislikeReason = reader.string();
                    break;
                }
            case 2: {
                    message.dislikeId = reader.uint32();
                    break;
                }
            case 3: {
                    message.extra = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DislikeInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DislikeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DislikeInfo} DislikeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DislikeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DislikeInfo message.
     * @function verify
     * @memberof DislikeInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DislikeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
            if (!$util.isString(message.dislikeReason))
                return "dislikeReason: string expected";
        if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
            if (!$util.isInteger(message.dislikeId))
                return "dislikeId: integer expected";
        if (message.extra != null && message.hasOwnProperty("extra"))
            if (!$util.isString(message.extra))
                return "extra: string expected";
        return null;
    };

    /**
     * Creates a DislikeInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DislikeInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DislikeInfo} DislikeInfo
     */
    DislikeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.DislikeInfo)
            return object;
        let message = new $root.DislikeInfo();
        if (object.dislikeReason != null)
            message.dislikeReason = String(object.dislikeReason);
        if (object.dislikeId != null)
            message.dislikeId = object.dislikeId >>> 0;
        if (object.extra != null)
            message.extra = String(object.extra);
        return message;
    };

    /**
     * Creates a plain object from a DislikeInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DislikeInfo
     * @static
     * @param {DislikeInfo} message DislikeInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DislikeInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.dislikeReason = "";
            object.dislikeId = 0;
            object.extra = "";
        }
        if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
            object.dislikeReason = message.dislikeReason;
        if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
            object.dislikeId = message.dislikeId;
        if (message.extra != null && message.hasOwnProperty("extra"))
            object.extra = message.extra;
        return object;
    };

    /**
     * Converts this DislikeInfo to JSON.
     * @function toJSON
     * @memberof DislikeInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DislikeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DislikeInfo
     * @function getTypeUrl
     * @memberof DislikeInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DislikeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/DislikeInfo";
    };

    return DislikeInfo;
})();

export const UniversalLabel = $root.UniversalLabel = (() => {

    /**
     * Properties of an UniversalLabel.
     * @exports IUniversalLabel
     * @interface IUniversalLabel
     * @property {string|null} [labelId] UniversalLabel labelId
     * @property {string|null} [labelText] UniversalLabel labelText
     * @property {string|null} [textColor] UniversalLabel textColor
     * @property {string|null} [textColorBlack] UniversalLabel textColorBlack
     * @property {string|null} [backgroundColor] UniversalLabel backgroundColor
     * @property {string|null} [backgroundColorBlack] UniversalLabel backgroundColorBlack
     * @property {number|null} [roundRadius] UniversalLabel roundRadius
     */

    /**
     * Constructs a new UniversalLabel.
     * @exports UniversalLabel
     * @classdesc Represents an UniversalLabel.
     * @implements IUniversalLabel
     * @constructor
     * @param {IUniversalLabel=} [properties] Properties to set
     */
    function UniversalLabel(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UniversalLabel labelId.
     * @member {string} labelId
     * @memberof UniversalLabel
     * @instance
     */
    UniversalLabel.prototype.labelId = "";

    /**
     * UniversalLabel labelText.
     * @member {string} labelText
     * @memberof UniversalLabel
     * @instance
     */
    UniversalLabel.prototype.labelText = "";

    /**
     * UniversalLabel textColor.
     * @member {string} textColor
     * @memberof UniversalLabel
     * @instance
     */
    UniversalLabel.prototype.textColor = "";

    /**
     * UniversalLabel textColorBlack.
     * @member {string} textColorBlack
     * @memberof UniversalLabel
     * @instance
     */
    UniversalLabel.prototype.textColorBlack = "";

    /**
     * UniversalLabel backgroundColor.
     * @member {string} backgroundColor
     * @memberof UniversalLabel
     * @instance
     */
    UniversalLabel.prototype.backgroundColor = "";

    /**
     * UniversalLabel backgroundColorBlack.
     * @member {string} backgroundColorBlack
     * @memberof UniversalLabel
     * @instance
     */
    UniversalLabel.prototype.backgroundColorBlack = "";

    /**
     * UniversalLabel roundRadius.
     * @member {number} roundRadius
     * @memberof UniversalLabel
     * @instance
     */
    UniversalLabel.prototype.roundRadius = 0;

    /**
     * Creates a new UniversalLabel instance using the specified properties.
     * @function create
     * @memberof UniversalLabel
     * @static
     * @param {IUniversalLabel=} [properties] Properties to set
     * @returns {UniversalLabel} UniversalLabel instance
     */
    UniversalLabel.create = function create(properties) {
        return new UniversalLabel(properties);
    };

    /**
     * Encodes the specified UniversalLabel message. Does not implicitly {@link UniversalLabel.verify|verify} messages.
     * @function encode
     * @memberof UniversalLabel
     * @static
     * @param {IUniversalLabel} message UniversalLabel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UniversalLabel.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.labelId != null && Object.hasOwnProperty.call(message, "labelId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.labelId);
        if (message.labelText != null && Object.hasOwnProperty.call(message, "labelText"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.labelText);
        if (message.textColor != null && Object.hasOwnProperty.call(message, "textColor"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.textColor);
        if (message.textColorBlack != null && Object.hasOwnProperty.call(message, "textColorBlack"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.textColorBlack);
        if (message.backgroundColor != null && Object.hasOwnProperty.call(message, "backgroundColor"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.backgroundColor);
        if (message.backgroundColorBlack != null && Object.hasOwnProperty.call(message, "backgroundColorBlack"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.backgroundColorBlack);
        if (message.roundRadius != null && Object.hasOwnProperty.call(message, "roundRadius"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.roundRadius);
        return writer;
    };

    /**
     * Encodes the specified UniversalLabel message, length delimited. Does not implicitly {@link UniversalLabel.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UniversalLabel
     * @static
     * @param {IUniversalLabel} message UniversalLabel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UniversalLabel.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UniversalLabel message from the specified reader or buffer.
     * @function decode
     * @memberof UniversalLabel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UniversalLabel} UniversalLabel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UniversalLabel.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UniversalLabel();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.labelId = reader.string();
                    break;
                }
            case 2: {
                    message.labelText = reader.string();
                    break;
                }
            case 3: {
                    message.textColor = reader.string();
                    break;
                }
            case 4: {
                    message.textColorBlack = reader.string();
                    break;
                }
            case 5: {
                    message.backgroundColor = reader.string();
                    break;
                }
            case 6: {
                    message.backgroundColorBlack = reader.string();
                    break;
                }
            case 7: {
                    message.roundRadius = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UniversalLabel message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UniversalLabel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UniversalLabel} UniversalLabel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UniversalLabel.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UniversalLabel message.
     * @function verify
     * @memberof UniversalLabel
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UniversalLabel.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.labelId != null && message.hasOwnProperty("labelId"))
            if (!$util.isString(message.labelId))
                return "labelId: string expected";
        if (message.labelText != null && message.hasOwnProperty("labelText"))
            if (!$util.isString(message.labelText))
                return "labelText: string expected";
        if (message.textColor != null && message.hasOwnProperty("textColor"))
            if (!$util.isString(message.textColor))
                return "textColor: string expected";
        if (message.textColorBlack != null && message.hasOwnProperty("textColorBlack"))
            if (!$util.isString(message.textColorBlack))
                return "textColorBlack: string expected";
        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
            if (!$util.isString(message.backgroundColor))
                return "backgroundColor: string expected";
        if (message.backgroundColorBlack != null && message.hasOwnProperty("backgroundColorBlack"))
            if (!$util.isString(message.backgroundColorBlack))
                return "backgroundColorBlack: string expected";
        if (message.roundRadius != null && message.hasOwnProperty("roundRadius"))
            if (!$util.isInteger(message.roundRadius))
                return "roundRadius: integer expected";
        return null;
    };

    /**
     * Creates an UniversalLabel message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UniversalLabel
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UniversalLabel} UniversalLabel
     */
    UniversalLabel.fromObject = function fromObject(object) {
        if (object instanceof $root.UniversalLabel)
            return object;
        let message = new $root.UniversalLabel();
        if (object.labelId != null)
            message.labelId = String(object.labelId);
        if (object.labelText != null)
            message.labelText = String(object.labelText);
        if (object.textColor != null)
            message.textColor = String(object.textColor);
        if (object.textColorBlack != null)
            message.textColorBlack = String(object.textColorBlack);
        if (object.backgroundColor != null)
            message.backgroundColor = String(object.backgroundColor);
        if (object.backgroundColorBlack != null)
            message.backgroundColorBlack = String(object.backgroundColorBlack);
        if (object.roundRadius != null)
            message.roundRadius = object.roundRadius | 0;
        return message;
    };

    /**
     * Creates a plain object from an UniversalLabel message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UniversalLabel
     * @static
     * @param {UniversalLabel} message UniversalLabel
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UniversalLabel.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.labelId = "";
            object.labelText = "";
            object.textColor = "";
            object.textColorBlack = "";
            object.backgroundColor = "";
            object.backgroundColorBlack = "";
            object.roundRadius = 0;
        }
        if (message.labelId != null && message.hasOwnProperty("labelId"))
            object.labelId = message.labelId;
        if (message.labelText != null && message.hasOwnProperty("labelText"))
            object.labelText = message.labelText;
        if (message.textColor != null && message.hasOwnProperty("textColor"))
            object.textColor = message.textColor;
        if (message.textColorBlack != null && message.hasOwnProperty("textColorBlack"))
            object.textColorBlack = message.textColorBlack;
        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
            object.backgroundColor = message.backgroundColor;
        if (message.backgroundColorBlack != null && message.hasOwnProperty("backgroundColorBlack"))
            object.backgroundColorBlack = message.backgroundColorBlack;
        if (message.roundRadius != null && message.hasOwnProperty("roundRadius"))
            object.roundRadius = message.roundRadius;
        return object;
    };

    /**
     * Converts this UniversalLabel to JSON.
     * @function toJSON
     * @memberof UniversalLabel
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UniversalLabel.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UniversalLabel
     * @function getTypeUrl
     * @memberof UniversalLabel
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UniversalLabel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/UniversalLabel";
    };

    return UniversalLabel;
})();

export const WidthHeight = $root.WidthHeight = (() => {

    /**
     * Properties of a WidthHeight.
     * @exports IWidthHeight
     * @interface IWidthHeight
     * @property {number|null} [width] WidthHeight width
     * @property {number|null} [height] WidthHeight height
     */

    /**
     * Constructs a new WidthHeight.
     * @exports WidthHeight
     * @classdesc Represents a WidthHeight.
     * @implements IWidthHeight
     * @constructor
     * @param {IWidthHeight=} [properties] Properties to set
     */
    function WidthHeight(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WidthHeight width.
     * @member {number} width
     * @memberof WidthHeight
     * @instance
     */
    WidthHeight.prototype.width = 0;

    /**
     * WidthHeight height.
     * @member {number} height
     * @memberof WidthHeight
     * @instance
     */
    WidthHeight.prototype.height = 0;

    /**
     * Creates a new WidthHeight instance using the specified properties.
     * @function create
     * @memberof WidthHeight
     * @static
     * @param {IWidthHeight=} [properties] Properties to set
     * @returns {WidthHeight} WidthHeight instance
     */
    WidthHeight.create = function create(properties) {
        return new WidthHeight(properties);
    };

    /**
     * Encodes the specified WidthHeight message. Does not implicitly {@link WidthHeight.verify|verify} messages.
     * @function encode
     * @memberof WidthHeight
     * @static
     * @param {IWidthHeight} message WidthHeight message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WidthHeight.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.width != null && Object.hasOwnProperty.call(message, "width"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.width);
        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.height);
        return writer;
    };

    /**
     * Encodes the specified WidthHeight message, length delimited. Does not implicitly {@link WidthHeight.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WidthHeight
     * @static
     * @param {IWidthHeight} message WidthHeight message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WidthHeight.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WidthHeight message from the specified reader or buffer.
     * @function decode
     * @memberof WidthHeight
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WidthHeight} WidthHeight
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WidthHeight.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WidthHeight();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.width = reader.int32();
                    break;
                }
            case 2: {
                    message.height = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WidthHeight message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WidthHeight
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WidthHeight} WidthHeight
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WidthHeight.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WidthHeight message.
     * @function verify
     * @memberof WidthHeight
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WidthHeight.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.width != null && message.hasOwnProperty("width"))
            if (!$util.isInteger(message.width))
                return "width: integer expected";
        if (message.height != null && message.hasOwnProperty("height"))
            if (!$util.isInteger(message.height))
                return "height: integer expected";
        return null;
    };

    /**
     * Creates a WidthHeight message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WidthHeight
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WidthHeight} WidthHeight
     */
    WidthHeight.fromObject = function fromObject(object) {
        if (object instanceof $root.WidthHeight)
            return object;
        let message = new $root.WidthHeight();
        if (object.width != null)
            message.width = object.width | 0;
        if (object.height != null)
            message.height = object.height | 0;
        return message;
    };

    /**
     * Creates a plain object from a WidthHeight message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WidthHeight
     * @static
     * @param {WidthHeight} message WidthHeight
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WidthHeight.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.width = 0;
            object.height = 0;
        }
        if (message.width != null && message.hasOwnProperty("width"))
            object.width = message.width;
        if (message.height != null && message.hasOwnProperty("height"))
            object.height = message.height;
        return object;
    };

    /**
     * Converts this WidthHeight to JSON.
     * @function toJSON
     * @memberof WidthHeight
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WidthHeight.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for WidthHeight
     * @function getTypeUrl
     * @memberof WidthHeight
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    WidthHeight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/WidthHeight";
    };

    return WidthHeight;
})();

export const BaijiahaoInfo = $root.BaijiahaoInfo = (() => {

    /**
     * Properties of a BaijiahaoInfo.
     * @exports IBaijiahaoInfo
     * @interface IBaijiahaoInfo
     * @property {string|null} [name] BaijiahaoInfo name
     * @property {string|null} [avatar] BaijiahaoInfo avatar
     * @property {string|null} [avatarH] BaijiahaoInfo avatarH
     * @property {string|null} [brief] BaijiahaoInfo brief
     * @property {number|null} [authId] BaijiahaoInfo authId
     * @property {string|null} [authDesc] BaijiahaoInfo authDesc
     * @property {number|null} [canModifyAvatar] BaijiahaoInfo canModifyAvatar
     */

    /**
     * Constructs a new BaijiahaoInfo.
     * @exports BaijiahaoInfo
     * @classdesc Represents a BaijiahaoInfo.
     * @implements IBaijiahaoInfo
     * @constructor
     * @param {IBaijiahaoInfo=} [properties] Properties to set
     */
    function BaijiahaoInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BaijiahaoInfo name.
     * @member {string} name
     * @memberof BaijiahaoInfo
     * @instance
     */
    BaijiahaoInfo.prototype.name = "";

    /**
     * BaijiahaoInfo avatar.
     * @member {string} avatar
     * @memberof BaijiahaoInfo
     * @instance
     */
    BaijiahaoInfo.prototype.avatar = "";

    /**
     * BaijiahaoInfo avatarH.
     * @member {string} avatarH
     * @memberof BaijiahaoInfo
     * @instance
     */
    BaijiahaoInfo.prototype.avatarH = "";

    /**
     * BaijiahaoInfo brief.
     * @member {string} brief
     * @memberof BaijiahaoInfo
     * @instance
     */
    BaijiahaoInfo.prototype.brief = "";

    /**
     * BaijiahaoInfo authId.
     * @member {number} authId
     * @memberof BaijiahaoInfo
     * @instance
     */
    BaijiahaoInfo.prototype.authId = 0;

    /**
     * BaijiahaoInfo authDesc.
     * @member {string} authDesc
     * @memberof BaijiahaoInfo
     * @instance
     */
    BaijiahaoInfo.prototype.authDesc = "";

    /**
     * BaijiahaoInfo canModifyAvatar.
     * @member {number} canModifyAvatar
     * @memberof BaijiahaoInfo
     * @instance
     */
    BaijiahaoInfo.prototype.canModifyAvatar = 0;

    /**
     * Creates a new BaijiahaoInfo instance using the specified properties.
     * @function create
     * @memberof BaijiahaoInfo
     * @static
     * @param {IBaijiahaoInfo=} [properties] Properties to set
     * @returns {BaijiahaoInfo} BaijiahaoInfo instance
     */
    BaijiahaoInfo.create = function create(properties) {
        return new BaijiahaoInfo(properties);
    };

    /**
     * Encodes the specified BaijiahaoInfo message. Does not implicitly {@link BaijiahaoInfo.verify|verify} messages.
     * @function encode
     * @memberof BaijiahaoInfo
     * @static
     * @param {IBaijiahaoInfo} message BaijiahaoInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BaijiahaoInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.avatar);
        if (message.avatarH != null && Object.hasOwnProperty.call(message, "avatarH"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarH);
        if (message.brief != null && Object.hasOwnProperty.call(message, "brief"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.brief);
        if (message.authId != null && Object.hasOwnProperty.call(message, "authId"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.authId);
        if (message.authDesc != null && Object.hasOwnProperty.call(message, "authDesc"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.authDesc);
        if (message.canModifyAvatar != null && Object.hasOwnProperty.call(message, "canModifyAvatar"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.canModifyAvatar);
        return writer;
    };

    /**
     * Encodes the specified BaijiahaoInfo message, length delimited. Does not implicitly {@link BaijiahaoInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BaijiahaoInfo
     * @static
     * @param {IBaijiahaoInfo} message BaijiahaoInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BaijiahaoInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BaijiahaoInfo message from the specified reader or buffer.
     * @function decode
     * @memberof BaijiahaoInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BaijiahaoInfo} BaijiahaoInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BaijiahaoInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BaijiahaoInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.name = reader.string();
                    break;
                }
            case 2: {
                    message.avatar = reader.string();
                    break;
                }
            case 3: {
                    message.avatarH = reader.string();
                    break;
                }
            case 4: {
                    message.brief = reader.string();
                    break;
                }
            case 5: {
                    message.authId = reader.int32();
                    break;
                }
            case 6: {
                    message.authDesc = reader.string();
                    break;
                }
            case 7: {
                    message.canModifyAvatar = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BaijiahaoInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BaijiahaoInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BaijiahaoInfo} BaijiahaoInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BaijiahaoInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BaijiahaoInfo message.
     * @function verify
     * @memberof BaijiahaoInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BaijiahaoInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.avatar != null && message.hasOwnProperty("avatar"))
            if (!$util.isString(message.avatar))
                return "avatar: string expected";
        if (message.avatarH != null && message.hasOwnProperty("avatarH"))
            if (!$util.isString(message.avatarH))
                return "avatarH: string expected";
        if (message.brief != null && message.hasOwnProperty("brief"))
            if (!$util.isString(message.brief))
                return "brief: string expected";
        if (message.authId != null && message.hasOwnProperty("authId"))
            if (!$util.isInteger(message.authId))
                return "authId: integer expected";
        if (message.authDesc != null && message.hasOwnProperty("authDesc"))
            if (!$util.isString(message.authDesc))
                return "authDesc: string expected";
        if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
            if (!$util.isInteger(message.canModifyAvatar))
                return "canModifyAvatar: integer expected";
        return null;
    };

    /**
     * Creates a BaijiahaoInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BaijiahaoInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BaijiahaoInfo} BaijiahaoInfo
     */
    BaijiahaoInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.BaijiahaoInfo)
            return object;
        let message = new $root.BaijiahaoInfo();
        if (object.name != null)
            message.name = String(object.name);
        if (object.avatar != null)
            message.avatar = String(object.avatar);
        if (object.avatarH != null)
            message.avatarH = String(object.avatarH);
        if (object.brief != null)
            message.brief = String(object.brief);
        if (object.authId != null)
            message.authId = object.authId | 0;
        if (object.authDesc != null)
            message.authDesc = String(object.authDesc);
        if (object.canModifyAvatar != null)
            message.canModifyAvatar = object.canModifyAvatar | 0;
        return message;
    };

    /**
     * Creates a plain object from a BaijiahaoInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BaijiahaoInfo
     * @static
     * @param {BaijiahaoInfo} message BaijiahaoInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BaijiahaoInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.avatar = "";
            object.avatarH = "";
            object.brief = "";
            object.authId = 0;
            object.authDesc = "";
            object.canModifyAvatar = 0;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.avatar != null && message.hasOwnProperty("avatar"))
            object.avatar = message.avatar;
        if (message.avatarH != null && message.hasOwnProperty("avatarH"))
            object.avatarH = message.avatarH;
        if (message.brief != null && message.hasOwnProperty("brief"))
            object.brief = message.brief;
        if (message.authId != null && message.hasOwnProperty("authId"))
            object.authId = message.authId;
        if (message.authDesc != null && message.hasOwnProperty("authDesc"))
            object.authDesc = message.authDesc;
        if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
            object.canModifyAvatar = message.canModifyAvatar;
        return object;
    };

    /**
     * Converts this BaijiahaoInfo to JSON.
     * @function toJSON
     * @memberof BaijiahaoInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BaijiahaoInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BaijiahaoInfo
     * @function getTypeUrl
     * @memberof BaijiahaoInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BaijiahaoInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BaijiahaoInfo";
    };

    return BaijiahaoInfo;
})();

export const Balv = $root.Balv = (() => {

    /**
     * Properties of a Balv.
     * @exports IBalv
     * @interface IBalv
     * @property {number|null} [isBlack] Balv isBlack
     * @property {number|null} [isBlock] Balv isBlock
     * @property {number|null} [daysTofree] Balv daysTofree
     */

    /**
     * Constructs a new Balv.
     * @exports Balv
     * @classdesc Represents a Balv.
     * @implements IBalv
     * @constructor
     * @param {IBalv=} [properties] Properties to set
     */
    function Balv(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Balv isBlack.
     * @member {number} isBlack
     * @memberof Balv
     * @instance
     */
    Balv.prototype.isBlack = 0;

    /**
     * Balv isBlock.
     * @member {number} isBlock
     * @memberof Balv
     * @instance
     */
    Balv.prototype.isBlock = 0;

    /**
     * Balv daysTofree.
     * @member {number} daysTofree
     * @memberof Balv
     * @instance
     */
    Balv.prototype.daysTofree = 0;

    /**
     * Creates a new Balv instance using the specified properties.
     * @function create
     * @memberof Balv
     * @static
     * @param {IBalv=} [properties] Properties to set
     * @returns {Balv} Balv instance
     */
    Balv.create = function create(properties) {
        return new Balv(properties);
    };

    /**
     * Encodes the specified Balv message. Does not implicitly {@link Balv.verify|verify} messages.
     * @function encode
     * @memberof Balv
     * @static
     * @param {IBalv} message Balv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Balv.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isBlack != null && Object.hasOwnProperty.call(message, "isBlack"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isBlack);
        if (message.isBlock != null && Object.hasOwnProperty.call(message, "isBlock"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isBlock);
        if (message.daysTofree != null && Object.hasOwnProperty.call(message, "daysTofree"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.daysTofree);
        return writer;
    };

    /**
     * Encodes the specified Balv message, length delimited. Does not implicitly {@link Balv.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Balv
     * @static
     * @param {IBalv} message Balv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Balv.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Balv message from the specified reader or buffer.
     * @function decode
     * @memberof Balv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Balv} Balv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Balv.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Balv();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isBlack = reader.int32();
                    break;
                }
            case 2: {
                    message.isBlock = reader.int32();
                    break;
                }
            case 3: {
                    message.daysTofree = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Balv message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Balv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Balv} Balv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Balv.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Balv message.
     * @function verify
     * @memberof Balv
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Balv.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isBlack != null && message.hasOwnProperty("isBlack"))
            if (!$util.isInteger(message.isBlack))
                return "isBlack: integer expected";
        if (message.isBlock != null && message.hasOwnProperty("isBlock"))
            if (!$util.isInteger(message.isBlock))
                return "isBlock: integer expected";
        if (message.daysTofree != null && message.hasOwnProperty("daysTofree"))
            if (!$util.isInteger(message.daysTofree))
                return "daysTofree: integer expected";
        return null;
    };

    /**
     * Creates a Balv message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Balv
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Balv} Balv
     */
    Balv.fromObject = function fromObject(object) {
        if (object instanceof $root.Balv)
            return object;
        let message = new $root.Balv();
        if (object.isBlack != null)
            message.isBlack = object.isBlack | 0;
        if (object.isBlock != null)
            message.isBlock = object.isBlock | 0;
        if (object.daysTofree != null)
            message.daysTofree = object.daysTofree | 0;
        return message;
    };

    /**
     * Creates a plain object from a Balv message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Balv
     * @static
     * @param {Balv} message Balv
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Balv.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.isBlack = 0;
            object.isBlock = 0;
            object.daysTofree = 0;
        }
        if (message.isBlack != null && message.hasOwnProperty("isBlack"))
            object.isBlack = message.isBlack;
        if (message.isBlock != null && message.hasOwnProperty("isBlock"))
            object.isBlock = message.isBlock;
        if (message.daysTofree != null && message.hasOwnProperty("daysTofree"))
            object.daysTofree = message.daysTofree;
        return object;
    };

    /**
     * Converts this Balv to JSON.
     * @function toJSON
     * @memberof Balv
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Balv.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Balv
     * @function getTypeUrl
     * @memberof Balv
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Balv.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Balv";
    };

    return Balv;
})();

export const BawuThrones = $root.BawuThrones = (() => {

    /**
     * Properties of a BawuThrones.
     * @exports IBawuThrones
     * @interface IBawuThrones
     * @property {number|null} [totalRecommendNum] BawuThrones totalRecommendNum
     * @property {number|null} [usedRecommendNum] BawuThrones usedRecommendNum
     * @property {string|null} [bazhuLevel] BawuThrones bazhuLevel
     * @property {number|null} [usedBcastCnt] BawuThrones usedBcastCnt
     * @property {number|null} [totalBcastCnt] BawuThrones totalBcastCnt
     * @property {number|null} [newestBcastPv] BawuThrones newestBcastPv
     * @property {number|null} [hasSendBcast] BawuThrones hasSendBcast
     * @property {number|null} [newestBcastPushuserCnt] BawuThrones newestBcastPushuserCnt
     */

    /**
     * Constructs a new BawuThrones.
     * @exports BawuThrones
     * @classdesc Represents a BawuThrones.
     * @implements IBawuThrones
     * @constructor
     * @param {IBawuThrones=} [properties] Properties to set
     */
    function BawuThrones(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BawuThrones totalRecommendNum.
     * @member {number} totalRecommendNum
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.totalRecommendNum = 0;

    /**
     * BawuThrones usedRecommendNum.
     * @member {number} usedRecommendNum
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.usedRecommendNum = 0;

    /**
     * BawuThrones bazhuLevel.
     * @member {string} bazhuLevel
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.bazhuLevel = "";

    /**
     * BawuThrones usedBcastCnt.
     * @member {number} usedBcastCnt
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.usedBcastCnt = 0;

    /**
     * BawuThrones totalBcastCnt.
     * @member {number} totalBcastCnt
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.totalBcastCnt = 0;

    /**
     * BawuThrones newestBcastPv.
     * @member {number} newestBcastPv
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.newestBcastPv = 0;

    /**
     * BawuThrones hasSendBcast.
     * @member {number} hasSendBcast
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.hasSendBcast = 0;

    /**
     * BawuThrones newestBcastPushuserCnt.
     * @member {number} newestBcastPushuserCnt
     * @memberof BawuThrones
     * @instance
     */
    BawuThrones.prototype.newestBcastPushuserCnt = 0;

    /**
     * Creates a new BawuThrones instance using the specified properties.
     * @function create
     * @memberof BawuThrones
     * @static
     * @param {IBawuThrones=} [properties] Properties to set
     * @returns {BawuThrones} BawuThrones instance
     */
    BawuThrones.create = function create(properties) {
        return new BawuThrones(properties);
    };

    /**
     * Encodes the specified BawuThrones message. Does not implicitly {@link BawuThrones.verify|verify} messages.
     * @function encode
     * @memberof BawuThrones
     * @static
     * @param {IBawuThrones} message BawuThrones message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BawuThrones.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.totalRecommendNum != null && Object.hasOwnProperty.call(message, "totalRecommendNum"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.totalRecommendNum);
        if (message.usedRecommendNum != null && Object.hasOwnProperty.call(message, "usedRecommendNum"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.usedRecommendNum);
        if (message.bazhuLevel != null && Object.hasOwnProperty.call(message, "bazhuLevel"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.bazhuLevel);
        if (message.usedBcastCnt != null && Object.hasOwnProperty.call(message, "usedBcastCnt"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.usedBcastCnt);
        if (message.totalBcastCnt != null && Object.hasOwnProperty.call(message, "totalBcastCnt"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.totalBcastCnt);
        if (message.newestBcastPv != null && Object.hasOwnProperty.call(message, "newestBcastPv"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.newestBcastPv);
        if (message.hasSendBcast != null && Object.hasOwnProperty.call(message, "hasSendBcast"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.hasSendBcast);
        if (message.newestBcastPushuserCnt != null && Object.hasOwnProperty.call(message, "newestBcastPushuserCnt"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.newestBcastPushuserCnt);
        return writer;
    };

    /**
     * Encodes the specified BawuThrones message, length delimited. Does not implicitly {@link BawuThrones.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BawuThrones
     * @static
     * @param {IBawuThrones} message BawuThrones message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BawuThrones.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BawuThrones message from the specified reader or buffer.
     * @function decode
     * @memberof BawuThrones
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BawuThrones} BawuThrones
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BawuThrones.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BawuThrones();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.totalRecommendNum = reader.int32();
                    break;
                }
            case 2: {
                    message.usedRecommendNum = reader.int32();
                    break;
                }
            case 3: {
                    message.bazhuLevel = reader.string();
                    break;
                }
            case 4: {
                    message.usedBcastCnt = reader.int32();
                    break;
                }
            case 5: {
                    message.totalBcastCnt = reader.int32();
                    break;
                }
            case 6: {
                    message.newestBcastPv = reader.int32();
                    break;
                }
            case 7: {
                    message.hasSendBcast = reader.int32();
                    break;
                }
            case 8: {
                    message.newestBcastPushuserCnt = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BawuThrones message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BawuThrones
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BawuThrones} BawuThrones
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BawuThrones.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BawuThrones message.
     * @function verify
     * @memberof BawuThrones
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BawuThrones.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.totalRecommendNum != null && message.hasOwnProperty("totalRecommendNum"))
            if (!$util.isInteger(message.totalRecommendNum))
                return "totalRecommendNum: integer expected";
        if (message.usedRecommendNum != null && message.hasOwnProperty("usedRecommendNum"))
            if (!$util.isInteger(message.usedRecommendNum))
                return "usedRecommendNum: integer expected";
        if (message.bazhuLevel != null && message.hasOwnProperty("bazhuLevel"))
            if (!$util.isString(message.bazhuLevel))
                return "bazhuLevel: string expected";
        if (message.usedBcastCnt != null && message.hasOwnProperty("usedBcastCnt"))
            if (!$util.isInteger(message.usedBcastCnt))
                return "usedBcastCnt: integer expected";
        if (message.totalBcastCnt != null && message.hasOwnProperty("totalBcastCnt"))
            if (!$util.isInteger(message.totalBcastCnt))
                return "totalBcastCnt: integer expected";
        if (message.newestBcastPv != null && message.hasOwnProperty("newestBcastPv"))
            if (!$util.isInteger(message.newestBcastPv))
                return "newestBcastPv: integer expected";
        if (message.hasSendBcast != null && message.hasOwnProperty("hasSendBcast"))
            if (!$util.isInteger(message.hasSendBcast))
                return "hasSendBcast: integer expected";
        if (message.newestBcastPushuserCnt != null && message.hasOwnProperty("newestBcastPushuserCnt"))
            if (!$util.isInteger(message.newestBcastPushuserCnt))
                return "newestBcastPushuserCnt: integer expected";
        return null;
    };

    /**
     * Creates a BawuThrones message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BawuThrones
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BawuThrones} BawuThrones
     */
    BawuThrones.fromObject = function fromObject(object) {
        if (object instanceof $root.BawuThrones)
            return object;
        let message = new $root.BawuThrones();
        if (object.totalRecommendNum != null)
            message.totalRecommendNum = object.totalRecommendNum | 0;
        if (object.usedRecommendNum != null)
            message.usedRecommendNum = object.usedRecommendNum | 0;
        if (object.bazhuLevel != null)
            message.bazhuLevel = String(object.bazhuLevel);
        if (object.usedBcastCnt != null)
            message.usedBcastCnt = object.usedBcastCnt | 0;
        if (object.totalBcastCnt != null)
            message.totalBcastCnt = object.totalBcastCnt | 0;
        if (object.newestBcastPv != null)
            message.newestBcastPv = object.newestBcastPv | 0;
        if (object.hasSendBcast != null)
            message.hasSendBcast = object.hasSendBcast | 0;
        if (object.newestBcastPushuserCnt != null)
            message.newestBcastPushuserCnt = object.newestBcastPushuserCnt | 0;
        return message;
    };

    /**
     * Creates a plain object from a BawuThrones message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BawuThrones
     * @static
     * @param {BawuThrones} message BawuThrones
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BawuThrones.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.totalRecommendNum = 0;
            object.usedRecommendNum = 0;
            object.bazhuLevel = "";
            object.usedBcastCnt = 0;
            object.totalBcastCnt = 0;
            object.newestBcastPv = 0;
            object.hasSendBcast = 0;
            object.newestBcastPushuserCnt = 0;
        }
        if (message.totalRecommendNum != null && message.hasOwnProperty("totalRecommendNum"))
            object.totalRecommendNum = message.totalRecommendNum;
        if (message.usedRecommendNum != null && message.hasOwnProperty("usedRecommendNum"))
            object.usedRecommendNum = message.usedRecommendNum;
        if (message.bazhuLevel != null && message.hasOwnProperty("bazhuLevel"))
            object.bazhuLevel = message.bazhuLevel;
        if (message.usedBcastCnt != null && message.hasOwnProperty("usedBcastCnt"))
            object.usedBcastCnt = message.usedBcastCnt;
        if (message.totalBcastCnt != null && message.hasOwnProperty("totalBcastCnt"))
            object.totalBcastCnt = message.totalBcastCnt;
        if (message.newestBcastPv != null && message.hasOwnProperty("newestBcastPv"))
            object.newestBcastPv = message.newestBcastPv;
        if (message.hasSendBcast != null && message.hasOwnProperty("hasSendBcast"))
            object.hasSendBcast = message.hasSendBcast;
        if (message.newestBcastPushuserCnt != null && message.hasOwnProperty("newestBcastPushuserCnt"))
            object.newestBcastPushuserCnt = message.newestBcastPushuserCnt;
        return object;
    };

    /**
     * Converts this BawuThrones to JSON.
     * @function toJSON
     * @memberof BawuThrones
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BawuThrones.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BawuThrones
     * @function getTypeUrl
     * @memberof BawuThrones
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BawuThrones.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BawuThrones";
    };

    return BawuThrones;
})();

export const BazhuSign = $root.BazhuSign = (() => {

    /**
     * Properties of a BazhuSign.
     * @exports IBazhuSign
     * @interface IBazhuSign
     * @property {string|null} [desc] BazhuSign desc
     * @property {string|null} [level] BazhuSign level
     */

    /**
     * Constructs a new BazhuSign.
     * @exports BazhuSign
     * @classdesc Represents a BazhuSign.
     * @implements IBazhuSign
     * @constructor
     * @param {IBazhuSign=} [properties] Properties to set
     */
    function BazhuSign(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BazhuSign desc.
     * @member {string} desc
     * @memberof BazhuSign
     * @instance
     */
    BazhuSign.prototype.desc = "";

    /**
     * BazhuSign level.
     * @member {string} level
     * @memberof BazhuSign
     * @instance
     */
    BazhuSign.prototype.level = "";

    /**
     * Creates a new BazhuSign instance using the specified properties.
     * @function create
     * @memberof BazhuSign
     * @static
     * @param {IBazhuSign=} [properties] Properties to set
     * @returns {BazhuSign} BazhuSign instance
     */
    BazhuSign.create = function create(properties) {
        return new BazhuSign(properties);
    };

    /**
     * Encodes the specified BazhuSign message. Does not implicitly {@link BazhuSign.verify|verify} messages.
     * @function encode
     * @memberof BazhuSign
     * @static
     * @param {IBazhuSign} message BazhuSign message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BazhuSign.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.desc);
        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.level);
        return writer;
    };

    /**
     * Encodes the specified BazhuSign message, length delimited. Does not implicitly {@link BazhuSign.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BazhuSign
     * @static
     * @param {IBazhuSign} message BazhuSign message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BazhuSign.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BazhuSign message from the specified reader or buffer.
     * @function decode
     * @memberof BazhuSign
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BazhuSign} BazhuSign
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BazhuSign.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BazhuSign();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.desc = reader.string();
                    break;
                }
            case 2: {
                    message.level = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BazhuSign message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BazhuSign
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BazhuSign} BazhuSign
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BazhuSign.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BazhuSign message.
     * @function verify
     * @memberof BazhuSign
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BazhuSign.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.desc != null && message.hasOwnProperty("desc"))
            if (!$util.isString(message.desc))
                return "desc: string expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isString(message.level))
                return "level: string expected";
        return null;
    };

    /**
     * Creates a BazhuSign message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BazhuSign
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BazhuSign} BazhuSign
     */
    BazhuSign.fromObject = function fromObject(object) {
        if (object instanceof $root.BazhuSign)
            return object;
        let message = new $root.BazhuSign();
        if (object.desc != null)
            message.desc = String(object.desc);
        if (object.level != null)
            message.level = String(object.level);
        return message;
    };

    /**
     * Creates a plain object from a BazhuSign message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BazhuSign
     * @static
     * @param {BazhuSign} message BazhuSign
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BazhuSign.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.desc = "";
            object.level = "";
        }
        if (message.desc != null && message.hasOwnProperty("desc"))
            object.desc = message.desc;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        return object;
    };

    /**
     * Converts this BazhuSign to JSON.
     * @function toJSON
     * @memberof BazhuSign
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BazhuSign.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BazhuSign
     * @function getTypeUrl
     * @memberof BazhuSign
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BazhuSign.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BazhuSign";
    };

    return BazhuSign;
})();

export const BirthdayInfo = $root.BirthdayInfo = (() => {

    /**
     * Properties of a BirthdayInfo.
     * @exports IBirthdayInfo
     * @interface IBirthdayInfo
     * @property {number|Long|null} [birthdayTime] BirthdayInfo birthdayTime
     * @property {number|null} [birthdayShowStatus] BirthdayInfo birthdayShowStatus
     * @property {string|null} [constellation] BirthdayInfo constellation
     * @property {number|null} [age] BirthdayInfo age
     */

    /**
     * Constructs a new BirthdayInfo.
     * @exports BirthdayInfo
     * @classdesc Represents a BirthdayInfo.
     * @implements IBirthdayInfo
     * @constructor
     * @param {IBirthdayInfo=} [properties] Properties to set
     */
    function BirthdayInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BirthdayInfo birthdayTime.
     * @member {number|Long} birthdayTime
     * @memberof BirthdayInfo
     * @instance
     */
    BirthdayInfo.prototype.birthdayTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * BirthdayInfo birthdayShowStatus.
     * @member {number} birthdayShowStatus
     * @memberof BirthdayInfo
     * @instance
     */
    BirthdayInfo.prototype.birthdayShowStatus = 0;

    /**
     * BirthdayInfo constellation.
     * @member {string} constellation
     * @memberof BirthdayInfo
     * @instance
     */
    BirthdayInfo.prototype.constellation = "";

    /**
     * BirthdayInfo age.
     * @member {number} age
     * @memberof BirthdayInfo
     * @instance
     */
    BirthdayInfo.prototype.age = 0;

    /**
     * Creates a new BirthdayInfo instance using the specified properties.
     * @function create
     * @memberof BirthdayInfo
     * @static
     * @param {IBirthdayInfo=} [properties] Properties to set
     * @returns {BirthdayInfo} BirthdayInfo instance
     */
    BirthdayInfo.create = function create(properties) {
        return new BirthdayInfo(properties);
    };

    /**
     * Encodes the specified BirthdayInfo message. Does not implicitly {@link BirthdayInfo.verify|verify} messages.
     * @function encode
     * @memberof BirthdayInfo
     * @static
     * @param {IBirthdayInfo} message BirthdayInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BirthdayInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.birthdayTime != null && Object.hasOwnProperty.call(message, "birthdayTime"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.birthdayTime);
        if (message.birthdayShowStatus != null && Object.hasOwnProperty.call(message, "birthdayShowStatus"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.birthdayShowStatus);
        if (message.constellation != null && Object.hasOwnProperty.call(message, "constellation"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.constellation);
        if (message.age != null && Object.hasOwnProperty.call(message, "age"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.age);
        return writer;
    };

    /**
     * Encodes the specified BirthdayInfo message, length delimited. Does not implicitly {@link BirthdayInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BirthdayInfo
     * @static
     * @param {IBirthdayInfo} message BirthdayInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BirthdayInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BirthdayInfo message from the specified reader or buffer.
     * @function decode
     * @memberof BirthdayInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BirthdayInfo} BirthdayInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BirthdayInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BirthdayInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.birthdayTime = reader.int64();
                    break;
                }
            case 2: {
                    message.birthdayShowStatus = reader.uint32();
                    break;
                }
            case 3: {
                    message.constellation = reader.string();
                    break;
                }
            case 4: {
                    message.age = reader.uint32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BirthdayInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BirthdayInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BirthdayInfo} BirthdayInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BirthdayInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BirthdayInfo message.
     * @function verify
     * @memberof BirthdayInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BirthdayInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.birthdayTime != null && message.hasOwnProperty("birthdayTime"))
            if (!$util.isInteger(message.birthdayTime) && !(message.birthdayTime && $util.isInteger(message.birthdayTime.low) && $util.isInteger(message.birthdayTime.high)))
                return "birthdayTime: integer|Long expected";
        if (message.birthdayShowStatus != null && message.hasOwnProperty("birthdayShowStatus"))
            if (!$util.isInteger(message.birthdayShowStatus))
                return "birthdayShowStatus: integer expected";
        if (message.constellation != null && message.hasOwnProperty("constellation"))
            if (!$util.isString(message.constellation))
                return "constellation: string expected";
        if (message.age != null && message.hasOwnProperty("age"))
            if (!$util.isInteger(message.age))
                return "age: integer expected";
        return null;
    };

    /**
     * Creates a BirthdayInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BirthdayInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BirthdayInfo} BirthdayInfo
     */
    BirthdayInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.BirthdayInfo)
            return object;
        let message = new $root.BirthdayInfo();
        if (object.birthdayTime != null)
            if ($util.Long)
                (message.birthdayTime = $util.Long.fromValue(object.birthdayTime)).unsigned = false;
            else if (typeof object.birthdayTime === "string")
                message.birthdayTime = parseInt(object.birthdayTime, 10);
            else if (typeof object.birthdayTime === "number")
                message.birthdayTime = object.birthdayTime;
            else if (typeof object.birthdayTime === "object")
                message.birthdayTime = new $util.LongBits(object.birthdayTime.low >>> 0, object.birthdayTime.high >>> 0).toNumber();
        if (object.birthdayShowStatus != null)
            message.birthdayShowStatus = object.birthdayShowStatus >>> 0;
        if (object.constellation != null)
            message.constellation = String(object.constellation);
        if (object.age != null)
            message.age = object.age >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a BirthdayInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BirthdayInfo
     * @static
     * @param {BirthdayInfo} message BirthdayInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BirthdayInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.birthdayTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.birthdayTime = options.longs === String ? "0" : 0;
            object.birthdayShowStatus = 0;
            object.constellation = "";
            object.age = 0;
        }
        if (message.birthdayTime != null && message.hasOwnProperty("birthdayTime"))
            if (typeof message.birthdayTime === "number")
                object.birthdayTime = options.longs === String ? String(message.birthdayTime) : message.birthdayTime;
            else
                object.birthdayTime = options.longs === String ? $util.Long.prototype.toString.call(message.birthdayTime) : options.longs === Number ? new $util.LongBits(message.birthdayTime.low >>> 0, message.birthdayTime.high >>> 0).toNumber() : message.birthdayTime;
        if (message.birthdayShowStatus != null && message.hasOwnProperty("birthdayShowStatus"))
            object.birthdayShowStatus = message.birthdayShowStatus;
        if (message.constellation != null && message.hasOwnProperty("constellation"))
            object.constellation = message.constellation;
        if (message.age != null && message.hasOwnProperty("age"))
            object.age = message.age;
        return object;
    };

    /**
     * Converts this BirthdayInfo to JSON.
     * @function toJSON
     * @memberof BirthdayInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BirthdayInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BirthdayInfo
     * @function getTypeUrl
     * @memberof BirthdayInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BirthdayInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BirthdayInfo";
    };

    return BirthdayInfo;
})();

export const BusinessAccountInfo = $root.BusinessAccountInfo = (() => {

    /**
     * Properties of a BusinessAccountInfo.
     * @exports IBusinessAccountInfo
     * @interface IBusinessAccountInfo
     * @property {number|null} [isBusinessAccount] BusinessAccountInfo isBusinessAccount
     * @property {number|null} [isForumBusinessAccount] BusinessAccountInfo isForumBusinessAccount
     * @property {string|null} [businessName] BusinessAccountInfo businessName
     * @property {string|null} [identifiExplain] BusinessAccountInfo identifiExplain
     */

    /**
     * Constructs a new BusinessAccountInfo.
     * @exports BusinessAccountInfo
     * @classdesc Represents a BusinessAccountInfo.
     * @implements IBusinessAccountInfo
     * @constructor
     * @param {IBusinessAccountInfo=} [properties] Properties to set
     */
    function BusinessAccountInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BusinessAccountInfo isBusinessAccount.
     * @member {number} isBusinessAccount
     * @memberof BusinessAccountInfo
     * @instance
     */
    BusinessAccountInfo.prototype.isBusinessAccount = 0;

    /**
     * BusinessAccountInfo isForumBusinessAccount.
     * @member {number} isForumBusinessAccount
     * @memberof BusinessAccountInfo
     * @instance
     */
    BusinessAccountInfo.prototype.isForumBusinessAccount = 0;

    /**
     * BusinessAccountInfo businessName.
     * @member {string} businessName
     * @memberof BusinessAccountInfo
     * @instance
     */
    BusinessAccountInfo.prototype.businessName = "";

    /**
     * BusinessAccountInfo identifiExplain.
     * @member {string} identifiExplain
     * @memberof BusinessAccountInfo
     * @instance
     */
    BusinessAccountInfo.prototype.identifiExplain = "";

    /**
     * Creates a new BusinessAccountInfo instance using the specified properties.
     * @function create
     * @memberof BusinessAccountInfo
     * @static
     * @param {IBusinessAccountInfo=} [properties] Properties to set
     * @returns {BusinessAccountInfo} BusinessAccountInfo instance
     */
    BusinessAccountInfo.create = function create(properties) {
        return new BusinessAccountInfo(properties);
    };

    /**
     * Encodes the specified BusinessAccountInfo message. Does not implicitly {@link BusinessAccountInfo.verify|verify} messages.
     * @function encode
     * @memberof BusinessAccountInfo
     * @static
     * @param {IBusinessAccountInfo} message BusinessAccountInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BusinessAccountInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isBusinessAccount != null && Object.hasOwnProperty.call(message, "isBusinessAccount"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isBusinessAccount);
        if (message.isForumBusinessAccount != null && Object.hasOwnProperty.call(message, "isForumBusinessAccount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isForumBusinessAccount);
        if (message.businessName != null && Object.hasOwnProperty.call(message, "businessName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.businessName);
        if (message.identifiExplain != null && Object.hasOwnProperty.call(message, "identifiExplain"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.identifiExplain);
        return writer;
    };

    /**
     * Encodes the specified BusinessAccountInfo message, length delimited. Does not implicitly {@link BusinessAccountInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BusinessAccountInfo
     * @static
     * @param {IBusinessAccountInfo} message BusinessAccountInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BusinessAccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BusinessAccountInfo message from the specified reader or buffer.
     * @function decode
     * @memberof BusinessAccountInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BusinessAccountInfo} BusinessAccountInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BusinessAccountInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BusinessAccountInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isBusinessAccount = reader.int32();
                    break;
                }
            case 2: {
                    message.isForumBusinessAccount = reader.int32();
                    break;
                }
            case 3: {
                    message.businessName = reader.string();
                    break;
                }
            case 4: {
                    message.identifiExplain = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BusinessAccountInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BusinessAccountInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BusinessAccountInfo} BusinessAccountInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BusinessAccountInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BusinessAccountInfo message.
     * @function verify
     * @memberof BusinessAccountInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BusinessAccountInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isBusinessAccount != null && message.hasOwnProperty("isBusinessAccount"))
            if (!$util.isInteger(message.isBusinessAccount))
                return "isBusinessAccount: integer expected";
        if (message.isForumBusinessAccount != null && message.hasOwnProperty("isForumBusinessAccount"))
            if (!$util.isInteger(message.isForumBusinessAccount))
                return "isForumBusinessAccount: integer expected";
        if (message.businessName != null && message.hasOwnProperty("businessName"))
            if (!$util.isString(message.businessName))
                return "businessName: string expected";
        if (message.identifiExplain != null && message.hasOwnProperty("identifiExplain"))
            if (!$util.isString(message.identifiExplain))
                return "identifiExplain: string expected";
        return null;
    };

    /**
     * Creates a BusinessAccountInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BusinessAccountInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BusinessAccountInfo} BusinessAccountInfo
     */
    BusinessAccountInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.BusinessAccountInfo)
            return object;
        let message = new $root.BusinessAccountInfo();
        if (object.isBusinessAccount != null)
            message.isBusinessAccount = object.isBusinessAccount | 0;
        if (object.isForumBusinessAccount != null)
            message.isForumBusinessAccount = object.isForumBusinessAccount | 0;
        if (object.businessName != null)
            message.businessName = String(object.businessName);
        if (object.identifiExplain != null)
            message.identifiExplain = String(object.identifiExplain);
        return message;
    };

    /**
     * Creates a plain object from a BusinessAccountInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BusinessAccountInfo
     * @static
     * @param {BusinessAccountInfo} message BusinessAccountInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BusinessAccountInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.isBusinessAccount = 0;
            object.isForumBusinessAccount = 0;
            object.businessName = "";
            object.identifiExplain = "";
        }
        if (message.isBusinessAccount != null && message.hasOwnProperty("isBusinessAccount"))
            object.isBusinessAccount = message.isBusinessAccount;
        if (message.isForumBusinessAccount != null && message.hasOwnProperty("isForumBusinessAccount"))
            object.isForumBusinessAccount = message.isForumBusinessAccount;
        if (message.businessName != null && message.hasOwnProperty("businessName"))
            object.businessName = message.businessName;
        if (message.identifiExplain != null && message.hasOwnProperty("identifiExplain"))
            object.identifiExplain = message.identifiExplain;
        return object;
    };

    /**
     * Converts this BusinessAccountInfo to JSON.
     * @function toJSON
     * @memberof BusinessAccountInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BusinessAccountInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BusinessAccountInfo
     * @function getTypeUrl
     * @memberof BusinessAccountInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BusinessAccountInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/BusinessAccountInfo";
    };

    return BusinessAccountInfo;
})();

export const CallFansInfo = $root.CallFansInfo = (() => {

    /**
     * Properties of a CallFansInfo.
     * @exports ICallFansInfo
     * @interface ICallFansInfo
     * @property {number|null} [canCall] CallFansInfo canCall
     * @property {number|Long|null} [threadId] CallFansInfo threadId
     */

    /**
     * Constructs a new CallFansInfo.
     * @exports CallFansInfo
     * @classdesc Represents a CallFansInfo.
     * @implements ICallFansInfo
     * @constructor
     * @param {ICallFansInfo=} [properties] Properties to set
     */
    function CallFansInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CallFansInfo canCall.
     * @member {number} canCall
     * @memberof CallFansInfo
     * @instance
     */
    CallFansInfo.prototype.canCall = 0;

    /**
     * CallFansInfo threadId.
     * @member {number|Long} threadId
     * @memberof CallFansInfo
     * @instance
     */
    CallFansInfo.prototype.threadId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new CallFansInfo instance using the specified properties.
     * @function create
     * @memberof CallFansInfo
     * @static
     * @param {ICallFansInfo=} [properties] Properties to set
     * @returns {CallFansInfo} CallFansInfo instance
     */
    CallFansInfo.create = function create(properties) {
        return new CallFansInfo(properties);
    };

    /**
     * Encodes the specified CallFansInfo message. Does not implicitly {@link CallFansInfo.verify|verify} messages.
     * @function encode
     * @memberof CallFansInfo
     * @static
     * @param {ICallFansInfo} message CallFansInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallFansInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.canCall != null && Object.hasOwnProperty.call(message, "canCall"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.canCall);
        if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.threadId);
        return writer;
    };

    /**
     * Encodes the specified CallFansInfo message, length delimited. Does not implicitly {@link CallFansInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CallFansInfo
     * @static
     * @param {ICallFansInfo} message CallFansInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallFansInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CallFansInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CallFansInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CallFansInfo} CallFansInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallFansInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallFansInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.canCall = reader.int32();
                    break;
                }
            case 2: {
                    message.threadId = reader.int64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CallFansInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CallFansInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CallFansInfo} CallFansInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallFansInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CallFansInfo message.
     * @function verify
     * @memberof CallFansInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CallFansInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.canCall != null && message.hasOwnProperty("canCall"))
            if (!$util.isInteger(message.canCall))
                return "canCall: integer expected";
        if (message.threadId != null && message.hasOwnProperty("threadId"))
            if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                return "threadId: integer|Long expected";
        return null;
    };

    /**
     * Creates a CallFansInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CallFansInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CallFansInfo} CallFansInfo
     */
    CallFansInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.CallFansInfo)
            return object;
        let message = new $root.CallFansInfo();
        if (object.canCall != null)
            message.canCall = object.canCall | 0;
        if (object.threadId != null)
            if ($util.Long)
                (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = false;
            else if (typeof object.threadId === "string")
                message.threadId = parseInt(object.threadId, 10);
            else if (typeof object.threadId === "number")
                message.threadId = object.threadId;
            else if (typeof object.threadId === "object")
                message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a CallFansInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CallFansInfo
     * @static
     * @param {CallFansInfo} message CallFansInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CallFansInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.canCall = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.threadId = options.longs === String ? "0" : 0;
        }
        if (message.canCall != null && message.hasOwnProperty("canCall"))
            object.canCall = message.canCall;
        if (message.threadId != null && message.hasOwnProperty("threadId"))
            if (typeof message.threadId === "number")
                object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
            else
                object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber() : message.threadId;
        return object;
    };

    /**
     * Converts this CallFansInfo to JSON.
     * @function toJSON
     * @memberof CallFansInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CallFansInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CallFansInfo
     * @function getTypeUrl
     * @memberof CallFansInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CallFansInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CallFansInfo";
    };

    return CallFansInfo;
})();

export const ConsumeInfo = $root.ConsumeInfo = (() => {

    /**
     * Properties of a ConsumeInfo.
     * @exports IConsumeInfo
     * @interface IConsumeInfo
     * @property {string|null} [icon] ConsumeInfo icon
     * @property {string|null} [title] ConsumeInfo title
     * @property {string|null} [content] ConsumeInfo content
     */

    /**
     * Constructs a new ConsumeInfo.
     * @exports ConsumeInfo
     * @classdesc Represents a ConsumeInfo.
     * @implements IConsumeInfo
     * @constructor
     * @param {IConsumeInfo=} [properties] Properties to set
     */
    function ConsumeInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConsumeInfo icon.
     * @member {string} icon
     * @memberof ConsumeInfo
     * @instance
     */
    ConsumeInfo.prototype.icon = "";

    /**
     * ConsumeInfo title.
     * @member {string} title
     * @memberof ConsumeInfo
     * @instance
     */
    ConsumeInfo.prototype.title = "";

    /**
     * ConsumeInfo content.
     * @member {string} content
     * @memberof ConsumeInfo
     * @instance
     */
    ConsumeInfo.prototype.content = "";

    /**
     * Creates a new ConsumeInfo instance using the specified properties.
     * @function create
     * @memberof ConsumeInfo
     * @static
     * @param {IConsumeInfo=} [properties] Properties to set
     * @returns {ConsumeInfo} ConsumeInfo instance
     */
    ConsumeInfo.create = function create(properties) {
        return new ConsumeInfo(properties);
    };

    /**
     * Encodes the specified ConsumeInfo message. Does not implicitly {@link ConsumeInfo.verify|verify} messages.
     * @function encode
     * @memberof ConsumeInfo
     * @static
     * @param {IConsumeInfo} message ConsumeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConsumeInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.icon);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
        if (message.content != null && Object.hasOwnProperty.call(message, "content"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
        return writer;
    };

    /**
     * Encodes the specified ConsumeInfo message, length delimited. Does not implicitly {@link ConsumeInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConsumeInfo
     * @static
     * @param {IConsumeInfo} message ConsumeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConsumeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConsumeInfo message from the specified reader or buffer.
     * @function decode
     * @memberof ConsumeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConsumeInfo} ConsumeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConsumeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConsumeInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.icon = reader.string();
                    break;
                }
            case 2: {
                    message.title = reader.string();
                    break;
                }
            case 3: {
                    message.content = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConsumeInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConsumeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConsumeInfo} ConsumeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConsumeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConsumeInfo message.
     * @function verify
     * @memberof ConsumeInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConsumeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.icon != null && message.hasOwnProperty("icon"))
            if (!$util.isString(message.icon))
                return "icon: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.content != null && message.hasOwnProperty("content"))
            if (!$util.isString(message.content))
                return "content: string expected";
        return null;
    };

    /**
     * Creates a ConsumeInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConsumeInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConsumeInfo} ConsumeInfo
     */
    ConsumeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ConsumeInfo)
            return object;
        let message = new $root.ConsumeInfo();
        if (object.icon != null)
            message.icon = String(object.icon);
        if (object.title != null)
            message.title = String(object.title);
        if (object.content != null)
            message.content = String(object.content);
        return message;
    };

    /**
     * Creates a plain object from a ConsumeInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConsumeInfo
     * @static
     * @param {ConsumeInfo} message ConsumeInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConsumeInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.icon = "";
            object.title = "";
            object.content = "";
        }
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = message.icon;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.content != null && message.hasOwnProperty("content"))
            object.content = message.content;
        return object;
    };

    /**
     * Converts this ConsumeInfo to JSON.
     * @function toJSON
     * @memberof ConsumeInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConsumeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ConsumeInfo
     * @function getTypeUrl
     * @memberof ConsumeInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ConsumeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ConsumeInfo";
    };

    return ConsumeInfo;
})();

export const CreationData = $root.CreationData = (() => {

    /**
     * Properties of a CreationData.
     * @exports ICreationData
     * @interface ICreationData
     * @property {number|null} [viewCount] CreationData viewCount
     * @property {number|null} [agreeCount] CreationData agreeCount
     * @property {number|null} [viewCountTrend] CreationData viewCountTrend
     * @property {number|null} [agreeCountTrend] CreationData agreeCountTrend
     * @property {number|null} [commentCount] CreationData commentCount
     * @property {number|null} [commentTrend] CreationData commentTrend
     * @property {number|null} [validPlayCount] CreationData validPlayCount
     * @property {number|null} [validPlayCountTrend] CreationData validPlayCountTrend
     */

    /**
     * Constructs a new CreationData.
     * @exports CreationData
     * @classdesc Represents a CreationData.
     * @implements ICreationData
     * @constructor
     * @param {ICreationData=} [properties] Properties to set
     */
    function CreationData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreationData viewCount.
     * @member {number} viewCount
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.viewCount = 0;

    /**
     * CreationData agreeCount.
     * @member {number} agreeCount
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.agreeCount = 0;

    /**
     * CreationData viewCountTrend.
     * @member {number} viewCountTrend
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.viewCountTrend = 0;

    /**
     * CreationData agreeCountTrend.
     * @member {number} agreeCountTrend
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.agreeCountTrend = 0;

    /**
     * CreationData commentCount.
     * @member {number} commentCount
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.commentCount = 0;

    /**
     * CreationData commentTrend.
     * @member {number} commentTrend
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.commentTrend = 0;

    /**
     * CreationData validPlayCount.
     * @member {number} validPlayCount
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.validPlayCount = 0;

    /**
     * CreationData validPlayCountTrend.
     * @member {number} validPlayCountTrend
     * @memberof CreationData
     * @instance
     */
    CreationData.prototype.validPlayCountTrend = 0;

    /**
     * Creates a new CreationData instance using the specified properties.
     * @function create
     * @memberof CreationData
     * @static
     * @param {ICreationData=} [properties] Properties to set
     * @returns {CreationData} CreationData instance
     */
    CreationData.create = function create(properties) {
        return new CreationData(properties);
    };

    /**
     * Encodes the specified CreationData message. Does not implicitly {@link CreationData.verify|verify} messages.
     * @function encode
     * @memberof CreationData
     * @static
     * @param {ICreationData} message CreationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreationData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.viewCount != null && Object.hasOwnProperty.call(message, "viewCount"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.viewCount);
        if (message.agreeCount != null && Object.hasOwnProperty.call(message, "agreeCount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.agreeCount);
        if (message.viewCountTrend != null && Object.hasOwnProperty.call(message, "viewCountTrend"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.viewCountTrend);
        if (message.agreeCountTrend != null && Object.hasOwnProperty.call(message, "agreeCountTrend"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.agreeCountTrend);
        if (message.commentCount != null && Object.hasOwnProperty.call(message, "commentCount"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.commentCount);
        if (message.commentTrend != null && Object.hasOwnProperty.call(message, "commentTrend"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.commentTrend);
        if (message.validPlayCount != null && Object.hasOwnProperty.call(message, "validPlayCount"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.validPlayCount);
        if (message.validPlayCountTrend != null && Object.hasOwnProperty.call(message, "validPlayCountTrend"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.validPlayCountTrend);
        return writer;
    };

    /**
     * Encodes the specified CreationData message, length delimited. Does not implicitly {@link CreationData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreationData
     * @static
     * @param {ICreationData} message CreationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreationData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreationData message from the specified reader or buffer.
     * @function decode
     * @memberof CreationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreationData} CreationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreationData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreationData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.viewCount = reader.int32();
                    break;
                }
            case 2: {
                    message.agreeCount = reader.int32();
                    break;
                }
            case 3: {
                    message.viewCountTrend = reader.int32();
                    break;
                }
            case 4: {
                    message.agreeCountTrend = reader.int32();
                    break;
                }
            case 5: {
                    message.commentCount = reader.int32();
                    break;
                }
            case 6: {
                    message.commentTrend = reader.int32();
                    break;
                }
            case 7: {
                    message.validPlayCount = reader.int32();
                    break;
                }
            case 8: {
                    message.validPlayCountTrend = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreationData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreationData} CreationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreationData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreationData message.
     * @function verify
     * @memberof CreationData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreationData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.viewCount != null && message.hasOwnProperty("viewCount"))
            if (!$util.isInteger(message.viewCount))
                return "viewCount: integer expected";
        if (message.agreeCount != null && message.hasOwnProperty("agreeCount"))
            if (!$util.isInteger(message.agreeCount))
                return "agreeCount: integer expected";
        if (message.viewCountTrend != null && message.hasOwnProperty("viewCountTrend"))
            if (!$util.isInteger(message.viewCountTrend))
                return "viewCountTrend: integer expected";
        if (message.agreeCountTrend != null && message.hasOwnProperty("agreeCountTrend"))
            if (!$util.isInteger(message.agreeCountTrend))
                return "agreeCountTrend: integer expected";
        if (message.commentCount != null && message.hasOwnProperty("commentCount"))
            if (!$util.isInteger(message.commentCount))
                return "commentCount: integer expected";
        if (message.commentTrend != null && message.hasOwnProperty("commentTrend"))
            if (!$util.isInteger(message.commentTrend))
                return "commentTrend: integer expected";
        if (message.validPlayCount != null && message.hasOwnProperty("validPlayCount"))
            if (!$util.isInteger(message.validPlayCount))
                return "validPlayCount: integer expected";
        if (message.validPlayCountTrend != null && message.hasOwnProperty("validPlayCountTrend"))
            if (!$util.isInteger(message.validPlayCountTrend))
                return "validPlayCountTrend: integer expected";
        return null;
    };

    /**
     * Creates a CreationData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreationData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreationData} CreationData
     */
    CreationData.fromObject = function fromObject(object) {
        if (object instanceof $root.CreationData)
            return object;
        let message = new $root.CreationData();
        if (object.viewCount != null)
            message.viewCount = object.viewCount | 0;
        if (object.agreeCount != null)
            message.agreeCount = object.agreeCount | 0;
        if (object.viewCountTrend != null)
            message.viewCountTrend = object.viewCountTrend | 0;
        if (object.agreeCountTrend != null)
            message.agreeCountTrend = object.agreeCountTrend | 0;
        if (object.commentCount != null)
            message.commentCount = object.commentCount | 0;
        if (object.commentTrend != null)
            message.commentTrend = object.commentTrend | 0;
        if (object.validPlayCount != null)
            message.validPlayCount = object.validPlayCount | 0;
        if (object.validPlayCountTrend != null)
            message.validPlayCountTrend = object.validPlayCountTrend | 0;
        return message;
    };

    /**
     * Creates a plain object from a CreationData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreationData
     * @static
     * @param {CreationData} message CreationData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreationData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.viewCount = 0;
            object.agreeCount = 0;
            object.viewCountTrend = 0;
            object.agreeCountTrend = 0;
            object.commentCount = 0;
            object.commentTrend = 0;
            object.validPlayCount = 0;
            object.validPlayCountTrend = 0;
        }
        if (message.viewCount != null && message.hasOwnProperty("viewCount"))
            object.viewCount = message.viewCount;
        if (message.agreeCount != null && message.hasOwnProperty("agreeCount"))
            object.agreeCount = message.agreeCount;
        if (message.viewCountTrend != null && message.hasOwnProperty("viewCountTrend"))
            object.viewCountTrend = message.viewCountTrend;
        if (message.agreeCountTrend != null && message.hasOwnProperty("agreeCountTrend"))
            object.agreeCountTrend = message.agreeCountTrend;
        if (message.commentCount != null && message.hasOwnProperty("commentCount"))
            object.commentCount = message.commentCount;
        if (message.commentTrend != null && message.hasOwnProperty("commentTrend"))
            object.commentTrend = message.commentTrend;
        if (message.validPlayCount != null && message.hasOwnProperty("validPlayCount"))
            object.validPlayCount = message.validPlayCount;
        if (message.validPlayCountTrend != null && message.hasOwnProperty("validPlayCountTrend"))
            object.validPlayCountTrend = message.validPlayCountTrend;
        return object;
    };

    /**
     * Converts this CreationData to JSON.
     * @function toJSON
     * @memberof CreationData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreationData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CreationData
     * @function getTypeUrl
     * @memberof CreationData
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CreationData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CreationData";
    };

    return CreationData;
})();

export const Ecom = $root.Ecom = (() => {

    /**
     * Properties of an Ecom.
     * @exports IEcom
     * @interface IEcom
     * @property {number|null} [isSeller] Ecom isSeller
     */

    /**
     * Constructs a new Ecom.
     * @exports Ecom
     * @classdesc Represents an Ecom.
     * @implements IEcom
     * @constructor
     * @param {IEcom=} [properties] Properties to set
     */
    function Ecom(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Ecom isSeller.
     * @member {number} isSeller
     * @memberof Ecom
     * @instance
     */
    Ecom.prototype.isSeller = 0;

    /**
     * Creates a new Ecom instance using the specified properties.
     * @function create
     * @memberof Ecom
     * @static
     * @param {IEcom=} [properties] Properties to set
     * @returns {Ecom} Ecom instance
     */
    Ecom.create = function create(properties) {
        return new Ecom(properties);
    };

    /**
     * Encodes the specified Ecom message. Does not implicitly {@link Ecom.verify|verify} messages.
     * @function encode
     * @memberof Ecom
     * @static
     * @param {IEcom} message Ecom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Ecom.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isSeller != null && Object.hasOwnProperty.call(message, "isSeller"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.isSeller);
        return writer;
    };

    /**
     * Encodes the specified Ecom message, length delimited. Does not implicitly {@link Ecom.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Ecom
     * @static
     * @param {IEcom} message Ecom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Ecom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Ecom message from the specified reader or buffer.
     * @function decode
     * @memberof Ecom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Ecom} Ecom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Ecom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ecom();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isSeller = reader.uint32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Ecom message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Ecom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Ecom} Ecom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Ecom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Ecom message.
     * @function verify
     * @memberof Ecom
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Ecom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isSeller != null && message.hasOwnProperty("isSeller"))
            if (!$util.isInteger(message.isSeller))
                return "isSeller: integer expected";
        return null;
    };

    /**
     * Creates an Ecom message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Ecom
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Ecom} Ecom
     */
    Ecom.fromObject = function fromObject(object) {
        if (object instanceof $root.Ecom)
            return object;
        let message = new $root.Ecom();
        if (object.isSeller != null)
            message.isSeller = object.isSeller >>> 0;
        return message;
    };

    /**
     * Creates a plain object from an Ecom message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Ecom
     * @static
     * @param {Ecom} message Ecom
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Ecom.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.isSeller = 0;
        if (message.isSeller != null && message.hasOwnProperty("isSeller"))
            object.isSeller = message.isSeller;
        return object;
    };

    /**
     * Converts this Ecom to JSON.
     * @function toJSON
     * @memberof Ecom
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Ecom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Ecom
     * @function getTypeUrl
     * @memberof Ecom
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Ecom.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Ecom";
    };

    return Ecom;
})();

export const EditConfig = $root.EditConfig = (() => {

    /**
     * Properties of an EditConfig.
     * @exports IEditConfig
     * @interface IEditConfig
     * @property {number|null} [showEdit] EditConfig showEdit
     * @property {number|null} [isFirstEdit] EditConfig isFirstEdit
     */

    /**
     * Constructs a new EditConfig.
     * @exports EditConfig
     * @classdesc Represents an EditConfig.
     * @implements IEditConfig
     * @constructor
     * @param {IEditConfig=} [properties] Properties to set
     */
    function EditConfig(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EditConfig showEdit.
     * @member {number} showEdit
     * @memberof EditConfig
     * @instance
     */
    EditConfig.prototype.showEdit = 0;

    /**
     * EditConfig isFirstEdit.
     * @member {number} isFirstEdit
     * @memberof EditConfig
     * @instance
     */
    EditConfig.prototype.isFirstEdit = 0;

    /**
     * Creates a new EditConfig instance using the specified properties.
     * @function create
     * @memberof EditConfig
     * @static
     * @param {IEditConfig=} [properties] Properties to set
     * @returns {EditConfig} EditConfig instance
     */
    EditConfig.create = function create(properties) {
        return new EditConfig(properties);
    };

    /**
     * Encodes the specified EditConfig message. Does not implicitly {@link EditConfig.verify|verify} messages.
     * @function encode
     * @memberof EditConfig
     * @static
     * @param {IEditConfig} message EditConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EditConfig.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.showEdit != null && Object.hasOwnProperty.call(message, "showEdit"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.showEdit);
        if (message.isFirstEdit != null && Object.hasOwnProperty.call(message, "isFirstEdit"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isFirstEdit);
        return writer;
    };

    /**
     * Encodes the specified EditConfig message, length delimited. Does not implicitly {@link EditConfig.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EditConfig
     * @static
     * @param {IEditConfig} message EditConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EditConfig.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EditConfig message from the specified reader or buffer.
     * @function decode
     * @memberof EditConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EditConfig} EditConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EditConfig.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EditConfig();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.showEdit = reader.int32();
                    break;
                }
            case 2: {
                    message.isFirstEdit = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EditConfig message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EditConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EditConfig} EditConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EditConfig.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EditConfig message.
     * @function verify
     * @memberof EditConfig
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EditConfig.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.showEdit != null && message.hasOwnProperty("showEdit"))
            if (!$util.isInteger(message.showEdit))
                return "showEdit: integer expected";
        if (message.isFirstEdit != null && message.hasOwnProperty("isFirstEdit"))
            if (!$util.isInteger(message.isFirstEdit))
                return "isFirstEdit: integer expected";
        return null;
    };

    /**
     * Creates an EditConfig message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EditConfig
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EditConfig} EditConfig
     */
    EditConfig.fromObject = function fromObject(object) {
        if (object instanceof $root.EditConfig)
            return object;
        let message = new $root.EditConfig();
        if (object.showEdit != null)
            message.showEdit = object.showEdit | 0;
        if (object.isFirstEdit != null)
            message.isFirstEdit = object.isFirstEdit | 0;
        return message;
    };

    /**
     * Creates a plain object from an EditConfig message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EditConfig
     * @static
     * @param {EditConfig} message EditConfig
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EditConfig.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.showEdit = 0;
            object.isFirstEdit = 0;
        }
        if (message.showEdit != null && message.hasOwnProperty("showEdit"))
            object.showEdit = message.showEdit;
        if (message.isFirstEdit != null && message.hasOwnProperty("isFirstEdit"))
            object.isFirstEdit = message.isFirstEdit;
        return object;
    };

    /**
     * Converts this EditConfig to JSON.
     * @function toJSON
     * @memberof EditConfig
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EditConfig.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EditConfig
     * @function getTypeUrl
     * @memberof EditConfig
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EditConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/EditConfig";
    };

    return EditConfig;
})();

export const EsportInfo = $root.EsportInfo = (() => {

    /**
     * Properties of an EsportInfo.
     * @exports IEsportInfo
     * @interface IEsportInfo
     * @property {string|null} [intro] EsportInfo intro
     */

    /**
     * Constructs a new EsportInfo.
     * @exports EsportInfo
     * @classdesc Represents an EsportInfo.
     * @implements IEsportInfo
     * @constructor
     * @param {IEsportInfo=} [properties] Properties to set
     */
    function EsportInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EsportInfo intro.
     * @member {string} intro
     * @memberof EsportInfo
     * @instance
     */
    EsportInfo.prototype.intro = "";

    /**
     * Creates a new EsportInfo instance using the specified properties.
     * @function create
     * @memberof EsportInfo
     * @static
     * @param {IEsportInfo=} [properties] Properties to set
     * @returns {EsportInfo} EsportInfo instance
     */
    EsportInfo.create = function create(properties) {
        return new EsportInfo(properties);
    };

    /**
     * Encodes the specified EsportInfo message. Does not implicitly {@link EsportInfo.verify|verify} messages.
     * @function encode
     * @memberof EsportInfo
     * @static
     * @param {IEsportInfo} message EsportInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EsportInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.intro != null && Object.hasOwnProperty.call(message, "intro"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.intro);
        return writer;
    };

    /**
     * Encodes the specified EsportInfo message, length delimited. Does not implicitly {@link EsportInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EsportInfo
     * @static
     * @param {IEsportInfo} message EsportInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EsportInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EsportInfo message from the specified reader or buffer.
     * @function decode
     * @memberof EsportInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EsportInfo} EsportInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EsportInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EsportInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.intro = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EsportInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EsportInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EsportInfo} EsportInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EsportInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EsportInfo message.
     * @function verify
     * @memberof EsportInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EsportInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.intro != null && message.hasOwnProperty("intro"))
            if (!$util.isString(message.intro))
                return "intro: string expected";
        return null;
    };

    /**
     * Creates an EsportInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EsportInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EsportInfo} EsportInfo
     */
    EsportInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.EsportInfo)
            return object;
        let message = new $root.EsportInfo();
        if (object.intro != null)
            message.intro = String(object.intro);
        return message;
    };

    /**
     * Creates a plain object from an EsportInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EsportInfo
     * @static
     * @param {EsportInfo} message EsportInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EsportInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.intro = "";
        if (message.intro != null && message.hasOwnProperty("intro"))
            object.intro = message.intro;
        return object;
    };

    /**
     * Converts this EsportInfo to JSON.
     * @function toJSON
     * @memberof EsportInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EsportInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EsportInfo
     * @function getTypeUrl
     * @memberof EsportInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EsportInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/EsportInfo";
    };

    return EsportInfo;
})();

export const ForumToolPerm = $root.ForumToolPerm = (() => {

    /**
     * Properties of a ForumToolPerm.
     * @exports IForumToolPerm
     * @interface IForumToolPerm
     * @property {number|Long|null} [perm] ForumToolPerm perm
     */

    /**
     * Constructs a new ForumToolPerm.
     * @exports ForumToolPerm
     * @classdesc Represents a ForumToolPerm.
     * @implements IForumToolPerm
     * @constructor
     * @param {IForumToolPerm=} [properties] Properties to set
     */
    function ForumToolPerm(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ForumToolPerm perm.
     * @member {number|Long} perm
     * @memberof ForumToolPerm
     * @instance
     */
    ForumToolPerm.prototype.perm = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new ForumToolPerm instance using the specified properties.
     * @function create
     * @memberof ForumToolPerm
     * @static
     * @param {IForumToolPerm=} [properties] Properties to set
     * @returns {ForumToolPerm} ForumToolPerm instance
     */
    ForumToolPerm.create = function create(properties) {
        return new ForumToolPerm(properties);
    };

    /**
     * Encodes the specified ForumToolPerm message. Does not implicitly {@link ForumToolPerm.verify|verify} messages.
     * @function encode
     * @memberof ForumToolPerm
     * @static
     * @param {IForumToolPerm} message ForumToolPerm message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ForumToolPerm.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.perm != null && Object.hasOwnProperty.call(message, "perm"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.perm);
        return writer;
    };

    /**
     * Encodes the specified ForumToolPerm message, length delimited. Does not implicitly {@link ForumToolPerm.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ForumToolPerm
     * @static
     * @param {IForumToolPerm} message ForumToolPerm message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ForumToolPerm.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ForumToolPerm message from the specified reader or buffer.
     * @function decode
     * @memberof ForumToolPerm
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ForumToolPerm} ForumToolPerm
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ForumToolPerm.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ForumToolPerm();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.perm = reader.int64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ForumToolPerm message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ForumToolPerm
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ForumToolPerm} ForumToolPerm
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ForumToolPerm.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ForumToolPerm message.
     * @function verify
     * @memberof ForumToolPerm
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ForumToolPerm.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.perm != null && message.hasOwnProperty("perm"))
            if (!$util.isInteger(message.perm) && !(message.perm && $util.isInteger(message.perm.low) && $util.isInteger(message.perm.high)))
                return "perm: integer|Long expected";
        return null;
    };

    /**
     * Creates a ForumToolPerm message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ForumToolPerm
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ForumToolPerm} ForumToolPerm
     */
    ForumToolPerm.fromObject = function fromObject(object) {
        if (object instanceof $root.ForumToolPerm)
            return object;
        let message = new $root.ForumToolPerm();
        if (object.perm != null)
            if ($util.Long)
                (message.perm = $util.Long.fromValue(object.perm)).unsigned = false;
            else if (typeof object.perm === "string")
                message.perm = parseInt(object.perm, 10);
            else if (typeof object.perm === "number")
                message.perm = object.perm;
            else if (typeof object.perm === "object")
                message.perm = new $util.LongBits(object.perm.low >>> 0, object.perm.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a ForumToolPerm message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ForumToolPerm
     * @static
     * @param {ForumToolPerm} message ForumToolPerm
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ForumToolPerm.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.perm = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.perm = options.longs === String ? "0" : 0;
        if (message.perm != null && message.hasOwnProperty("perm"))
            if (typeof message.perm === "number")
                object.perm = options.longs === String ? String(message.perm) : message.perm;
            else
                object.perm = options.longs === String ? $util.Long.prototype.toString.call(message.perm) : options.longs === Number ? new $util.LongBits(message.perm.low >>> 0, message.perm.high >>> 0).toNumber() : message.perm;
        return object;
    };

    /**
     * Converts this ForumToolPerm to JSON.
     * @function toJSON
     * @memberof ForumToolPerm
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ForumToolPerm.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ForumToolPerm
     * @function getTypeUrl
     * @memberof ForumToolPerm
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ForumToolPerm.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ForumToolPerm";
    };

    return ForumToolPerm;
})();

export const GiftInfo = $root.GiftInfo = (() => {

    /**
     * Properties of a GiftInfo.
     * @exports IGiftInfo
     * @interface IGiftInfo
     * @property {string|null} [icon] GiftInfo icon
     * @property {number|null} [num] GiftInfo num
     * @property {number|null} [giftId] GiftInfo giftId
     * @property {string|null} [giftName] GiftInfo giftName
     * @property {string|null} [largeThumbnailUrl] GiftInfo largeThumbnailUrl
     * @property {number|Long|null} [senderId] GiftInfo senderId
     * @property {string|null} [senderName] GiftInfo senderName
     */

    /**
     * Constructs a new GiftInfo.
     * @exports GiftInfo
     * @classdesc Represents a GiftInfo.
     * @implements IGiftInfo
     * @constructor
     * @param {IGiftInfo=} [properties] Properties to set
     */
    function GiftInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GiftInfo icon.
     * @member {string} icon
     * @memberof GiftInfo
     * @instance
     */
    GiftInfo.prototype.icon = "";

    /**
     * GiftInfo num.
     * @member {number} num
     * @memberof GiftInfo
     * @instance
     */
    GiftInfo.prototype.num = 0;

    /**
     * GiftInfo giftId.
     * @member {number} giftId
     * @memberof GiftInfo
     * @instance
     */
    GiftInfo.prototype.giftId = 0;

    /**
     * GiftInfo giftName.
     * @member {string} giftName
     * @memberof GiftInfo
     * @instance
     */
    GiftInfo.prototype.giftName = "";

    /**
     * GiftInfo largeThumbnailUrl.
     * @member {string} largeThumbnailUrl
     * @memberof GiftInfo
     * @instance
     */
    GiftInfo.prototype.largeThumbnailUrl = "";

    /**
     * GiftInfo senderId.
     * @member {number|Long} senderId
     * @memberof GiftInfo
     * @instance
     */
    GiftInfo.prototype.senderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * GiftInfo senderName.
     * @member {string} senderName
     * @memberof GiftInfo
     * @instance
     */
    GiftInfo.prototype.senderName = "";

    /**
     * Creates a new GiftInfo instance using the specified properties.
     * @function create
     * @memberof GiftInfo
     * @static
     * @param {IGiftInfo=} [properties] Properties to set
     * @returns {GiftInfo} GiftInfo instance
     */
    GiftInfo.create = function create(properties) {
        return new GiftInfo(properties);
    };

    /**
     * Encodes the specified GiftInfo message. Does not implicitly {@link GiftInfo.verify|verify} messages.
     * @function encode
     * @memberof GiftInfo
     * @static
     * @param {IGiftInfo} message GiftInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GiftInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.icon);
        if (message.num != null && Object.hasOwnProperty.call(message, "num"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
        if (message.giftId != null && Object.hasOwnProperty.call(message, "giftId"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.giftId);
        if (message.giftName != null && Object.hasOwnProperty.call(message, "giftName"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.giftName);
        if (message.largeThumbnailUrl != null && Object.hasOwnProperty.call(message, "largeThumbnailUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.largeThumbnailUrl);
        if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.senderId);
        if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.senderName);
        return writer;
    };

    /**
     * Encodes the specified GiftInfo message, length delimited. Does not implicitly {@link GiftInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GiftInfo
     * @static
     * @param {IGiftInfo} message GiftInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GiftInfo message from the specified reader or buffer.
     * @function decode
     * @memberof GiftInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GiftInfo} GiftInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GiftInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GiftInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.icon = reader.string();
                    break;
                }
            case 2: {
                    message.num = reader.int32();
                    break;
                }
            case 3: {
                    message.giftId = reader.uint32();
                    break;
                }
            case 4: {
                    message.giftName = reader.string();
                    break;
                }
            case 5: {
                    message.largeThumbnailUrl = reader.string();
                    break;
                }
            case 6: {
                    message.senderId = reader.uint64();
                    break;
                }
            case 7: {
                    message.senderName = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GiftInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GiftInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GiftInfo} GiftInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GiftInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GiftInfo message.
     * @function verify
     * @memberof GiftInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GiftInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.icon != null && message.hasOwnProperty("icon"))
            if (!$util.isString(message.icon))
                return "icon: string expected";
        if (message.num != null && message.hasOwnProperty("num"))
            if (!$util.isInteger(message.num))
                return "num: integer expected";
        if (message.giftId != null && message.hasOwnProperty("giftId"))
            if (!$util.isInteger(message.giftId))
                return "giftId: integer expected";
        if (message.giftName != null && message.hasOwnProperty("giftName"))
            if (!$util.isString(message.giftName))
                return "giftName: string expected";
        if (message.largeThumbnailUrl != null && message.hasOwnProperty("largeThumbnailUrl"))
            if (!$util.isString(message.largeThumbnailUrl))
                return "largeThumbnailUrl: string expected";
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            if (!$util.isInteger(message.senderId) && !(message.senderId && $util.isInteger(message.senderId.low) && $util.isInteger(message.senderId.high)))
                return "senderId: integer|Long expected";
        if (message.senderName != null && message.hasOwnProperty("senderName"))
            if (!$util.isString(message.senderName))
                return "senderName: string expected";
        return null;
    };

    /**
     * Creates a GiftInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GiftInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GiftInfo} GiftInfo
     */
    GiftInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.GiftInfo)
            return object;
        let message = new $root.GiftInfo();
        if (object.icon != null)
            message.icon = String(object.icon);
        if (object.num != null)
            message.num = object.num | 0;
        if (object.giftId != null)
            message.giftId = object.giftId >>> 0;
        if (object.giftName != null)
            message.giftName = String(object.giftName);
        if (object.largeThumbnailUrl != null)
            message.largeThumbnailUrl = String(object.largeThumbnailUrl);
        if (object.senderId != null)
            if ($util.Long)
                (message.senderId = $util.Long.fromValue(object.senderId)).unsigned = true;
            else if (typeof object.senderId === "string")
                message.senderId = parseInt(object.senderId, 10);
            else if (typeof object.senderId === "number")
                message.senderId = object.senderId;
            else if (typeof object.senderId === "object")
                message.senderId = new $util.LongBits(object.senderId.low >>> 0, object.senderId.high >>> 0).toNumber(true);
        if (object.senderName != null)
            message.senderName = String(object.senderName);
        return message;
    };

    /**
     * Creates a plain object from a GiftInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GiftInfo
     * @static
     * @param {GiftInfo} message GiftInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GiftInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.icon = "";
            object.num = 0;
            object.giftId = 0;
            object.giftName = "";
            object.largeThumbnailUrl = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.senderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.senderId = options.longs === String ? "0" : 0;
            object.senderName = "";
        }
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = message.icon;
        if (message.num != null && message.hasOwnProperty("num"))
            object.num = message.num;
        if (message.giftId != null && message.hasOwnProperty("giftId"))
            object.giftId = message.giftId;
        if (message.giftName != null && message.hasOwnProperty("giftName"))
            object.giftName = message.giftName;
        if (message.largeThumbnailUrl != null && message.hasOwnProperty("largeThumbnailUrl"))
            object.largeThumbnailUrl = message.largeThumbnailUrl;
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            if (typeof message.senderId === "number")
                object.senderId = options.longs === String ? String(message.senderId) : message.senderId;
            else
                object.senderId = options.longs === String ? $util.Long.prototype.toString.call(message.senderId) : options.longs === Number ? new $util.LongBits(message.senderId.low >>> 0, message.senderId.high >>> 0).toNumber(true) : message.senderId;
        if (message.senderName != null && message.hasOwnProperty("senderName"))
            object.senderName = message.senderName;
        return object;
    };

    /**
     * Converts this GiftInfo to JSON.
     * @function toJSON
     * @memberof GiftInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GiftInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GiftInfo
     * @function getTypeUrl
     * @memberof GiftInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GiftInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/GiftInfo";
    };

    return GiftInfo;
})();

export const GodInfo = $root.GodInfo = (() => {

    /**
     * Properties of a GodInfo.
     * @exports IGodInfo
     * @interface IGodInfo
     * @property {number|Long|null} [id] GodInfo id
     * @property {string|null} [intro] GodInfo intro
     * @property {number|null} [type] GodInfo type
     * @property {number|Long|null} [fid] GodInfo fid
     * @property {number|null} [followed] GodInfo followed
     * @property {string|null} [recommendReason] GodInfo recommendReason
     * @property {string|null} [forumName] GodInfo forumName
     * @property {number|null} [canSendMsg] GodInfo canSendMsg
     * @property {string|null} [prefix] GodInfo prefix
     */

    /**
     * Constructs a new GodInfo.
     * @exports GodInfo
     * @classdesc Represents a GodInfo.
     * @implements IGodInfo
     * @constructor
     * @param {IGodInfo=} [properties] Properties to set
     */
    function GodInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GodInfo id.
     * @member {number|Long} id
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * GodInfo intro.
     * @member {string} intro
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.intro = "";

    /**
     * GodInfo type.
     * @member {number} type
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.type = 0;

    /**
     * GodInfo fid.
     * @member {number|Long} fid
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.fid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * GodInfo followed.
     * @member {number} followed
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.followed = 0;

    /**
     * GodInfo recommendReason.
     * @member {string} recommendReason
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.recommendReason = "";

    /**
     * GodInfo forumName.
     * @member {string} forumName
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.forumName = "";

    /**
     * GodInfo canSendMsg.
     * @member {number} canSendMsg
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.canSendMsg = 0;

    /**
     * GodInfo prefix.
     * @member {string} prefix
     * @memberof GodInfo
     * @instance
     */
    GodInfo.prototype.prefix = "";

    /**
     * Creates a new GodInfo instance using the specified properties.
     * @function create
     * @memberof GodInfo
     * @static
     * @param {IGodInfo=} [properties] Properties to set
     * @returns {GodInfo} GodInfo instance
     */
    GodInfo.create = function create(properties) {
        return new GodInfo(properties);
    };

    /**
     * Encodes the specified GodInfo message. Does not implicitly {@link GodInfo.verify|verify} messages.
     * @function encode
     * @memberof GodInfo
     * @static
     * @param {IGodInfo} message GodInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GodInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
        if (message.intro != null && Object.hasOwnProperty.call(message, "intro"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.intro);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
        if (message.fid != null && Object.hasOwnProperty.call(message, "fid"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fid);
        if (message.followed != null && Object.hasOwnProperty.call(message, "followed"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.followed);
        if (message.recommendReason != null && Object.hasOwnProperty.call(message, "recommendReason"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.recommendReason);
        if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.forumName);
        if (message.canSendMsg != null && Object.hasOwnProperty.call(message, "canSendMsg"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.canSendMsg);
        if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.prefix);
        return writer;
    };

    /**
     * Encodes the specified GodInfo message, length delimited. Does not implicitly {@link GodInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GodInfo
     * @static
     * @param {IGodInfo} message GodInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GodInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GodInfo message from the specified reader or buffer.
     * @function decode
     * @memberof GodInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GodInfo} GodInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GodInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GodInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.id = reader.int64();
                    break;
                }
            case 2: {
                    message.intro = reader.string();
                    break;
                }
            case 3: {
                    message.type = reader.int32();
                    break;
                }
            case 4: {
                    message.fid = reader.int64();
                    break;
                }
            case 5: {
                    message.followed = reader.int32();
                    break;
                }
            case 6: {
                    message.recommendReason = reader.string();
                    break;
                }
            case 7: {
                    message.forumName = reader.string();
                    break;
                }
            case 8: {
                    message.canSendMsg = reader.int32();
                    break;
                }
            case 9: {
                    message.prefix = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GodInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GodInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GodInfo} GodInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GodInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GodInfo message.
     * @function verify
     * @memberof GodInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GodInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.intro != null && message.hasOwnProperty("intro"))
            if (!$util.isString(message.intro))
                return "intro: string expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.fid != null && message.hasOwnProperty("fid"))
            if (!$util.isInteger(message.fid) && !(message.fid && $util.isInteger(message.fid.low) && $util.isInteger(message.fid.high)))
                return "fid: integer|Long expected";
        if (message.followed != null && message.hasOwnProperty("followed"))
            if (!$util.isInteger(message.followed))
                return "followed: integer expected";
        if (message.recommendReason != null && message.hasOwnProperty("recommendReason"))
            if (!$util.isString(message.recommendReason))
                return "recommendReason: string expected";
        if (message.forumName != null && message.hasOwnProperty("forumName"))
            if (!$util.isString(message.forumName))
                return "forumName: string expected";
        if (message.canSendMsg != null && message.hasOwnProperty("canSendMsg"))
            if (!$util.isInteger(message.canSendMsg))
                return "canSendMsg: integer expected";
        if (message.prefix != null && message.hasOwnProperty("prefix"))
            if (!$util.isString(message.prefix))
                return "prefix: string expected";
        return null;
    };

    /**
     * Creates a GodInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GodInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GodInfo} GodInfo
     */
    GodInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.GodInfo)
            return object;
        let message = new $root.GodInfo();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.intro != null)
            message.intro = String(object.intro);
        if (object.type != null)
            message.type = object.type | 0;
        if (object.fid != null)
            if ($util.Long)
                (message.fid = $util.Long.fromValue(object.fid)).unsigned = false;
            else if (typeof object.fid === "string")
                message.fid = parseInt(object.fid, 10);
            else if (typeof object.fid === "number")
                message.fid = object.fid;
            else if (typeof object.fid === "object")
                message.fid = new $util.LongBits(object.fid.low >>> 0, object.fid.high >>> 0).toNumber();
        if (object.followed != null)
            message.followed = object.followed | 0;
        if (object.recommendReason != null)
            message.recommendReason = String(object.recommendReason);
        if (object.forumName != null)
            message.forumName = String(object.forumName);
        if (object.canSendMsg != null)
            message.canSendMsg = object.canSendMsg | 0;
        if (object.prefix != null)
            message.prefix = String(object.prefix);
        return message;
    };

    /**
     * Creates a plain object from a GodInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GodInfo
     * @static
     * @param {GodInfo} message GodInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GodInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.intro = "";
            object.type = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.fid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.fid = options.longs === String ? "0" : 0;
            object.followed = 0;
            object.recommendReason = "";
            object.forumName = "";
            object.canSendMsg = 0;
            object.prefix = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.intro != null && message.hasOwnProperty("intro"))
            object.intro = message.intro;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.fid != null && message.hasOwnProperty("fid"))
            if (typeof message.fid === "number")
                object.fid = options.longs === String ? String(message.fid) : message.fid;
            else
                object.fid = options.longs === String ? $util.Long.prototype.toString.call(message.fid) : options.longs === Number ? new $util.LongBits(message.fid.low >>> 0, message.fid.high >>> 0).toNumber() : message.fid;
        if (message.followed != null && message.hasOwnProperty("followed"))
            object.followed = message.followed;
        if (message.recommendReason != null && message.hasOwnProperty("recommendReason"))
            object.recommendReason = message.recommendReason;
        if (message.forumName != null && message.hasOwnProperty("forumName"))
            object.forumName = message.forumName;
        if (message.canSendMsg != null && message.hasOwnProperty("canSendMsg"))
            object.canSendMsg = message.canSendMsg;
        if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = message.prefix;
        return object;
    };

    /**
     * Converts this GodInfo to JSON.
     * @function toJSON
     * @memberof GodInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GodInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GodInfo
     * @function getTypeUrl
     * @memberof GodInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GodInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/GodInfo";
    };

    return GodInfo;
})();

export const Icon = $root.Icon = (() => {

    /**
     * Properties of an Icon.
     * @exports IIcon
     * @interface IIcon
     * @property {string|null} [name] Icon name
     * @property {number|null} [weight] Icon weight
     * @property {string|null} [url] Icon url
     * @property {string|null} [icon] Icon icon
     * @property {number|null} [value] Icon value
     * @property {ITerminal|null} [terminal] Icon terminal
     * @property {IPosition|null} [position] Icon position
     * @property {Array.<string>|null} [spriteInfo] Icon spriteInfo
     */

    /**
     * Constructs a new Icon.
     * @exports Icon
     * @classdesc Represents an Icon.
     * @implements IIcon
     * @constructor
     * @param {IIcon=} [properties] Properties to set
     */
    function Icon(properties) {
        this.spriteInfo = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Icon name.
     * @member {string} name
     * @memberof Icon
     * @instance
     */
    Icon.prototype.name = "";

    /**
     * Icon weight.
     * @member {number} weight
     * @memberof Icon
     * @instance
     */
    Icon.prototype.weight = 0;

    /**
     * Icon url.
     * @member {string} url
     * @memberof Icon
     * @instance
     */
    Icon.prototype.url = "";

    /**
     * Icon icon.
     * @member {string} icon
     * @memberof Icon
     * @instance
     */
    Icon.prototype.icon = "";

    /**
     * Icon value.
     * @member {number} value
     * @memberof Icon
     * @instance
     */
    Icon.prototype.value = 0;

    /**
     * Icon terminal.
     * @member {ITerminal|null|undefined} terminal
     * @memberof Icon
     * @instance
     */
    Icon.prototype.terminal = null;

    /**
     * Icon position.
     * @member {IPosition|null|undefined} position
     * @memberof Icon
     * @instance
     */
    Icon.prototype.position = null;

    /**
     * Icon spriteInfo.
     * @member {Array.<string>} spriteInfo
     * @memberof Icon
     * @instance
     */
    Icon.prototype.spriteInfo = $util.emptyArray;

    /**
     * Creates a new Icon instance using the specified properties.
     * @function create
     * @memberof Icon
     * @static
     * @param {IIcon=} [properties] Properties to set
     * @returns {Icon} Icon instance
     */
    Icon.create = function create(properties) {
        return new Icon(properties);
    };

    /**
     * Encodes the specified Icon message. Does not implicitly {@link Icon.verify|verify} messages.
     * @function encode
     * @memberof Icon
     * @static
     * @param {IIcon} message Icon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Icon.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.weight);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.icon);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.value);
        if (message.terminal != null && Object.hasOwnProperty.call(message, "terminal"))
            $root.Terminal.encode(message.terminal, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.position != null && Object.hasOwnProperty.call(message, "position"))
            $root.Position.encode(message.position, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.spriteInfo != null && message.spriteInfo.length)
            for (let i = 0; i < message.spriteInfo.length; ++i)
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.spriteInfo[i]);
        return writer;
    };

    /**
     * Encodes the specified Icon message, length delimited. Does not implicitly {@link Icon.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Icon
     * @static
     * @param {IIcon} message Icon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Icon.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Icon message from the specified reader or buffer.
     * @function decode
     * @memberof Icon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Icon} Icon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Icon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Icon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.name = reader.string();
                    break;
                }
            case 2: {
                    message.weight = reader.int32();
                    break;
                }
            case 3: {
                    message.url = reader.string();
                    break;
                }
            case 4: {
                    message.icon = reader.string();
                    break;
                }
            case 5: {
                    message.value = reader.int32();
                    break;
                }
            case 6: {
                    message.terminal = $root.Terminal.decode(reader, reader.uint32());
                    break;
                }
            case 7: {
                    message.position = $root.Position.decode(reader, reader.uint32());
                    break;
                }
            case 8: {
                    if (!(message.spriteInfo && message.spriteInfo.length))
                        message.spriteInfo = [];
                    message.spriteInfo.push(reader.string());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Icon message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Icon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Icon} Icon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Icon.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Icon message.
     * @function verify
     * @memberof Icon
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Icon.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.weight != null && message.hasOwnProperty("weight"))
            if (!$util.isInteger(message.weight))
                return "weight: integer expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.icon != null && message.hasOwnProperty("icon"))
            if (!$util.isString(message.icon))
                return "icon: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isInteger(message.value))
                return "value: integer expected";
        if (message.terminal != null && message.hasOwnProperty("terminal")) {
            let error = $root.Terminal.verify(message.terminal);
            if (error)
                return "terminal." + error;
        }
        if (message.position != null && message.hasOwnProperty("position")) {
            let error = $root.Position.verify(message.position);
            if (error)
                return "position." + error;
        }
        if (message.spriteInfo != null && message.hasOwnProperty("spriteInfo")) {
            if (!Array.isArray(message.spriteInfo))
                return "spriteInfo: array expected";
            for (let i = 0; i < message.spriteInfo.length; ++i)
                if (!$util.isString(message.spriteInfo[i]))
                    return "spriteInfo: string[] expected";
        }
        return null;
    };

    /**
     * Creates an Icon message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Icon
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Icon} Icon
     */
    Icon.fromObject = function fromObject(object) {
        if (object instanceof $root.Icon)
            return object;
        let message = new $root.Icon();
        if (object.name != null)
            message.name = String(object.name);
        if (object.weight != null)
            message.weight = object.weight | 0;
        if (object.url != null)
            message.url = String(object.url);
        if (object.icon != null)
            message.icon = String(object.icon);
        if (object.value != null)
            message.value = object.value | 0;
        if (object.terminal != null) {
            if (typeof object.terminal !== "object")
                throw TypeError(".Icon.terminal: object expected");
            message.terminal = $root.Terminal.fromObject(object.terminal);
        }
        if (object.position != null) {
            if (typeof object.position !== "object")
                throw TypeError(".Icon.position: object expected");
            message.position = $root.Position.fromObject(object.position);
        }
        if (object.spriteInfo) {
            if (!Array.isArray(object.spriteInfo))
                throw TypeError(".Icon.spriteInfo: array expected");
            message.spriteInfo = [];
            for (let i = 0; i < object.spriteInfo.length; ++i)
                message.spriteInfo[i] = String(object.spriteInfo[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from an Icon message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Icon
     * @static
     * @param {Icon} message Icon
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Icon.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.spriteInfo = [];
        if (options.defaults) {
            object.name = "";
            object.weight = 0;
            object.url = "";
            object.icon = "";
            object.value = 0;
            object.terminal = null;
            object.position = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.weight != null && message.hasOwnProperty("weight"))
            object.weight = message.weight;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = message.icon;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        if (message.terminal != null && message.hasOwnProperty("terminal"))
            object.terminal = $root.Terminal.toObject(message.terminal, options);
        if (message.position != null && message.hasOwnProperty("position"))
            object.position = $root.Position.toObject(message.position, options);
        if (message.spriteInfo && message.spriteInfo.length) {
            object.spriteInfo = [];
            for (let j = 0; j < message.spriteInfo.length; ++j)
                object.spriteInfo[j] = message.spriteInfo[j];
        }
        return object;
    };

    /**
     * Converts this Icon to JSON.
     * @function toJSON
     * @memberof Icon
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Icon.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Icon
     * @function getTypeUrl
     * @memberof Icon
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Icon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Icon";
    };

    return Icon;
})();

export const Position = $root.Position = (() => {

    /**
     * Properties of a Position.
     * @exports IPosition
     * @interface IPosition
     * @property {number|null} [frs] Position frs
     * @property {number|null} [pb] Position pb
     * @property {number|null} [home] Position home
     * @property {number|null} [card] Position card
     */

    /**
     * Constructs a new Position.
     * @exports Position
     * @classdesc Represents a Position.
     * @implements IPosition
     * @constructor
     * @param {IPosition=} [properties] Properties to set
     */
    function Position(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Position frs.
     * @member {number} frs
     * @memberof Position
     * @instance
     */
    Position.prototype.frs = 0;

    /**
     * Position pb.
     * @member {number} pb
     * @memberof Position
     * @instance
     */
    Position.prototype.pb = 0;

    /**
     * Position home.
     * @member {number} home
     * @memberof Position
     * @instance
     */
    Position.prototype.home = 0;

    /**
     * Position card.
     * @member {number} card
     * @memberof Position
     * @instance
     */
    Position.prototype.card = 0;

    /**
     * Creates a new Position instance using the specified properties.
     * @function create
     * @memberof Position
     * @static
     * @param {IPosition=} [properties] Properties to set
     * @returns {Position} Position instance
     */
    Position.create = function create(properties) {
        return new Position(properties);
    };

    /**
     * Encodes the specified Position message. Does not implicitly {@link Position.verify|verify} messages.
     * @function encode
     * @memberof Position
     * @static
     * @param {IPosition} message Position message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Position.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.frs != null && Object.hasOwnProperty.call(message, "frs"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.frs);
        if (message.pb != null && Object.hasOwnProperty.call(message, "pb"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pb);
        if (message.home != null && Object.hasOwnProperty.call(message, "home"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.home);
        if (message.card != null && Object.hasOwnProperty.call(message, "card"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.card);
        return writer;
    };

    /**
     * Encodes the specified Position message, length delimited. Does not implicitly {@link Position.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Position
     * @static
     * @param {IPosition} message Position message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Position.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Position message from the specified reader or buffer.
     * @function decode
     * @memberof Position
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Position} Position
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Position.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Position();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.frs = reader.int32();
                    break;
                }
            case 2: {
                    message.pb = reader.int32();
                    break;
                }
            case 3: {
                    message.home = reader.int32();
                    break;
                }
            case 4: {
                    message.card = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Position message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Position
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Position} Position
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Position.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Position message.
     * @function verify
     * @memberof Position
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Position.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.frs != null && message.hasOwnProperty("frs"))
            if (!$util.isInteger(message.frs))
                return "frs: integer expected";
        if (message.pb != null && message.hasOwnProperty("pb"))
            if (!$util.isInteger(message.pb))
                return "pb: integer expected";
        if (message.home != null && message.hasOwnProperty("home"))
            if (!$util.isInteger(message.home))
                return "home: integer expected";
        if (message.card != null && message.hasOwnProperty("card"))
            if (!$util.isInteger(message.card))
                return "card: integer expected";
        return null;
    };

    /**
     * Creates a Position message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Position
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Position} Position
     */
    Position.fromObject = function fromObject(object) {
        if (object instanceof $root.Position)
            return object;
        let message = new $root.Position();
        if (object.frs != null)
            message.frs = object.frs | 0;
        if (object.pb != null)
            message.pb = object.pb | 0;
        if (object.home != null)
            message.home = object.home | 0;
        if (object.card != null)
            message.card = object.card | 0;
        return message;
    };

    /**
     * Creates a plain object from a Position message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Position
     * @static
     * @param {Position} message Position
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Position.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.frs = 0;
            object.pb = 0;
            object.home = 0;
            object.card = 0;
        }
        if (message.frs != null && message.hasOwnProperty("frs"))
            object.frs = message.frs;
        if (message.pb != null && message.hasOwnProperty("pb"))
            object.pb = message.pb;
        if (message.home != null && message.hasOwnProperty("home"))
            object.home = message.home;
        if (message.card != null && message.hasOwnProperty("card"))
            object.card = message.card;
        return object;
    };

    /**
     * Converts this Position to JSON.
     * @function toJSON
     * @memberof Position
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Position.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Position
     * @function getTypeUrl
     * @memberof Position
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Position";
    };

    return Position;
})();

export const Terminal = $root.Terminal = (() => {

    /**
     * Properties of a Terminal.
     * @exports ITerminal
     * @interface ITerminal
     * @property {number|null} [pc] Terminal pc
     * @property {number|null} [wap] Terminal wap
     * @property {number|null} [client] Terminal client
     */

    /**
     * Constructs a new Terminal.
     * @exports Terminal
     * @classdesc Represents a Terminal.
     * @implements ITerminal
     * @constructor
     * @param {ITerminal=} [properties] Properties to set
     */
    function Terminal(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Terminal pc.
     * @member {number} pc
     * @memberof Terminal
     * @instance
     */
    Terminal.prototype.pc = 0;

    /**
     * Terminal wap.
     * @member {number} wap
     * @memberof Terminal
     * @instance
     */
    Terminal.prototype.wap = 0;

    /**
     * Terminal client.
     * @member {number} client
     * @memberof Terminal
     * @instance
     */
    Terminal.prototype.client = 0;

    /**
     * Creates a new Terminal instance using the specified properties.
     * @function create
     * @memberof Terminal
     * @static
     * @param {ITerminal=} [properties] Properties to set
     * @returns {Terminal} Terminal instance
     */
    Terminal.create = function create(properties) {
        return new Terminal(properties);
    };

    /**
     * Encodes the specified Terminal message. Does not implicitly {@link Terminal.verify|verify} messages.
     * @function encode
     * @memberof Terminal
     * @static
     * @param {ITerminal} message Terminal message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Terminal.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pc != null && Object.hasOwnProperty.call(message, "pc"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pc);
        if (message.wap != null && Object.hasOwnProperty.call(message, "wap"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.wap);
        if (message.client != null && Object.hasOwnProperty.call(message, "client"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.client);
        return writer;
    };

    /**
     * Encodes the specified Terminal message, length delimited. Does not implicitly {@link Terminal.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Terminal
     * @static
     * @param {ITerminal} message Terminal message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Terminal.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Terminal message from the specified reader or buffer.
     * @function decode
     * @memberof Terminal
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Terminal} Terminal
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Terminal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Terminal();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.pc = reader.int32();
                    break;
                }
            case 2: {
                    message.wap = reader.int32();
                    break;
                }
            case 3: {
                    message.client = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Terminal message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Terminal
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Terminal} Terminal
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Terminal.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Terminal message.
     * @function verify
     * @memberof Terminal
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Terminal.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pc != null && message.hasOwnProperty("pc"))
            if (!$util.isInteger(message.pc))
                return "pc: integer expected";
        if (message.wap != null && message.hasOwnProperty("wap"))
            if (!$util.isInteger(message.wap))
                return "wap: integer expected";
        if (message.client != null && message.hasOwnProperty("client"))
            if (!$util.isInteger(message.client))
                return "client: integer expected";
        return null;
    };

    /**
     * Creates a Terminal message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Terminal
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Terminal} Terminal
     */
    Terminal.fromObject = function fromObject(object) {
        if (object instanceof $root.Terminal)
            return object;
        let message = new $root.Terminal();
        if (object.pc != null)
            message.pc = object.pc | 0;
        if (object.wap != null)
            message.wap = object.wap | 0;
        if (object.client != null)
            message.client = object.client | 0;
        return message;
    };

    /**
     * Creates a plain object from a Terminal message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Terminal
     * @static
     * @param {Terminal} message Terminal
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Terminal.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.pc = 0;
            object.wap = 0;
            object.client = 0;
        }
        if (message.pc != null && message.hasOwnProperty("pc"))
            object.pc = message.pc;
        if (message.wap != null && message.hasOwnProperty("wap"))
            object.wap = message.wap;
        if (message.client != null && message.hasOwnProperty("client"))
            object.client = message.client;
        return object;
    };

    /**
     * Converts this Terminal to JSON.
     * @function toJSON
     * @memberof Terminal
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Terminal.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Terminal
     * @function getTypeUrl
     * @memberof Terminal
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Terminal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Terminal";
    };

    return Terminal;
})();

export const LikeForumInfo = $root.LikeForumInfo = (() => {

    /**
     * Properties of a LikeForumInfo.
     * @exports ILikeForumInfo
     * @interface ILikeForumInfo
     * @property {string|null} [forumName] LikeForumInfo forumName
     * @property {number|Long|null} [forumId] LikeForumInfo forumId
     */

    /**
     * Constructs a new LikeForumInfo.
     * @exports LikeForumInfo
     * @classdesc Represents a LikeForumInfo.
     * @implements ILikeForumInfo
     * @constructor
     * @param {ILikeForumInfo=} [properties] Properties to set
     */
    function LikeForumInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LikeForumInfo forumName.
     * @member {string} forumName
     * @memberof LikeForumInfo
     * @instance
     */
    LikeForumInfo.prototype.forumName = "";

    /**
     * LikeForumInfo forumId.
     * @member {number|Long} forumId
     * @memberof LikeForumInfo
     * @instance
     */
    LikeForumInfo.prototype.forumId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new LikeForumInfo instance using the specified properties.
     * @function create
     * @memberof LikeForumInfo
     * @static
     * @param {ILikeForumInfo=} [properties] Properties to set
     * @returns {LikeForumInfo} LikeForumInfo instance
     */
    LikeForumInfo.create = function create(properties) {
        return new LikeForumInfo(properties);
    };

    /**
     * Encodes the specified LikeForumInfo message. Does not implicitly {@link LikeForumInfo.verify|verify} messages.
     * @function encode
     * @memberof LikeForumInfo
     * @static
     * @param {ILikeForumInfo} message LikeForumInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LikeForumInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.forumName);
        if (message.forumId != null && Object.hasOwnProperty.call(message, "forumId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.forumId);
        return writer;
    };

    /**
     * Encodes the specified LikeForumInfo message, length delimited. Does not implicitly {@link LikeForumInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LikeForumInfo
     * @static
     * @param {ILikeForumInfo} message LikeForumInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LikeForumInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LikeForumInfo message from the specified reader or buffer.
     * @function decode
     * @memberof LikeForumInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LikeForumInfo} LikeForumInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LikeForumInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LikeForumInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.forumName = reader.string();
                    break;
                }
            case 2: {
                    message.forumId = reader.uint64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LikeForumInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LikeForumInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LikeForumInfo} LikeForumInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LikeForumInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LikeForumInfo message.
     * @function verify
     * @memberof LikeForumInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LikeForumInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.forumName != null && message.hasOwnProperty("forumName"))
            if (!$util.isString(message.forumName))
                return "forumName: string expected";
        if (message.forumId != null && message.hasOwnProperty("forumId"))
            if (!$util.isInteger(message.forumId) && !(message.forumId && $util.isInteger(message.forumId.low) && $util.isInteger(message.forumId.high)))
                return "forumId: integer|Long expected";
        return null;
    };

    /**
     * Creates a LikeForumInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LikeForumInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LikeForumInfo} LikeForumInfo
     */
    LikeForumInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.LikeForumInfo)
            return object;
        let message = new $root.LikeForumInfo();
        if (object.forumName != null)
            message.forumName = String(object.forumName);
        if (object.forumId != null)
            if ($util.Long)
                (message.forumId = $util.Long.fromValue(object.forumId)).unsigned = true;
            else if (typeof object.forumId === "string")
                message.forumId = parseInt(object.forumId, 10);
            else if (typeof object.forumId === "number")
                message.forumId = object.forumId;
            else if (typeof object.forumId === "object")
                message.forumId = new $util.LongBits(object.forumId.low >>> 0, object.forumId.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a LikeForumInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LikeForumInfo
     * @static
     * @param {LikeForumInfo} message LikeForumInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LikeForumInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.forumName = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.forumId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.forumId = options.longs === String ? "0" : 0;
        }
        if (message.forumName != null && message.hasOwnProperty("forumName"))
            object.forumName = message.forumName;
        if (message.forumId != null && message.hasOwnProperty("forumId"))
            if (typeof message.forumId === "number")
                object.forumId = options.longs === String ? String(message.forumId) : message.forumId;
            else
                object.forumId = options.longs === String ? $util.Long.prototype.toString.call(message.forumId) : options.longs === Number ? new $util.LongBits(message.forumId.low >>> 0, message.forumId.high >>> 0).toNumber(true) : message.forumId;
        return object;
    };

    /**
     * Converts this LikeForumInfo to JSON.
     * @function toJSON
     * @memberof LikeForumInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LikeForumInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for LikeForumInfo
     * @function getTypeUrl
     * @memberof LikeForumInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    LikeForumInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/LikeForumInfo";
    };

    return LikeForumInfo;
})();

export const LiveRoomInfo = $root.LiveRoomInfo = (() => {

    /**
     * Properties of a LiveRoomInfo.
     * @exports ILiveRoomInfo
     * @interface ILiveRoomInfo
     * @property {string|null} [btnTitle] LiveRoomInfo btnTitle
     * @property {number|null} [ownRoomCount] LiveRoomInfo ownRoomCount
     * @property {string|null} [jumpUrl] LiveRoomInfo jumpUrl
     */

    /**
     * Constructs a new LiveRoomInfo.
     * @exports LiveRoomInfo
     * @classdesc Represents a LiveRoomInfo.
     * @implements ILiveRoomInfo
     * @constructor
     * @param {ILiveRoomInfo=} [properties] Properties to set
     */
    function LiveRoomInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LiveRoomInfo btnTitle.
     * @member {string} btnTitle
     * @memberof LiveRoomInfo
     * @instance
     */
    LiveRoomInfo.prototype.btnTitle = "";

    /**
     * LiveRoomInfo ownRoomCount.
     * @member {number} ownRoomCount
     * @memberof LiveRoomInfo
     * @instance
     */
    LiveRoomInfo.prototype.ownRoomCount = 0;

    /**
     * LiveRoomInfo jumpUrl.
     * @member {string} jumpUrl
     * @memberof LiveRoomInfo
     * @instance
     */
    LiveRoomInfo.prototype.jumpUrl = "";

    /**
     * Creates a new LiveRoomInfo instance using the specified properties.
     * @function create
     * @memberof LiveRoomInfo
     * @static
     * @param {ILiveRoomInfo=} [properties] Properties to set
     * @returns {LiveRoomInfo} LiveRoomInfo instance
     */
    LiveRoomInfo.create = function create(properties) {
        return new LiveRoomInfo(properties);
    };

    /**
     * Encodes the specified LiveRoomInfo message. Does not implicitly {@link LiveRoomInfo.verify|verify} messages.
     * @function encode
     * @memberof LiveRoomInfo
     * @static
     * @param {ILiveRoomInfo} message LiveRoomInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LiveRoomInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.btnTitle != null && Object.hasOwnProperty.call(message, "btnTitle"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.btnTitle);
        if (message.ownRoomCount != null && Object.hasOwnProperty.call(message, "ownRoomCount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ownRoomCount);
        if (message.jumpUrl != null && Object.hasOwnProperty.call(message, "jumpUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.jumpUrl);
        return writer;
    };

    /**
     * Encodes the specified LiveRoomInfo message, length delimited. Does not implicitly {@link LiveRoomInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LiveRoomInfo
     * @static
     * @param {ILiveRoomInfo} message LiveRoomInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LiveRoomInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LiveRoomInfo message from the specified reader or buffer.
     * @function decode
     * @memberof LiveRoomInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LiveRoomInfo} LiveRoomInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LiveRoomInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LiveRoomInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.btnTitle = reader.string();
                    break;
                }
            case 2: {
                    message.ownRoomCount = reader.int32();
                    break;
                }
            case 3: {
                    message.jumpUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LiveRoomInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LiveRoomInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LiveRoomInfo} LiveRoomInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LiveRoomInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LiveRoomInfo message.
     * @function verify
     * @memberof LiveRoomInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LiveRoomInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.btnTitle != null && message.hasOwnProperty("btnTitle"))
            if (!$util.isString(message.btnTitle))
                return "btnTitle: string expected";
        if (message.ownRoomCount != null && message.hasOwnProperty("ownRoomCount"))
            if (!$util.isInteger(message.ownRoomCount))
                return "ownRoomCount: integer expected";
        if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
            if (!$util.isString(message.jumpUrl))
                return "jumpUrl: string expected";
        return null;
    };

    /**
     * Creates a LiveRoomInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LiveRoomInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LiveRoomInfo} LiveRoomInfo
     */
    LiveRoomInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.LiveRoomInfo)
            return object;
        let message = new $root.LiveRoomInfo();
        if (object.btnTitle != null)
            message.btnTitle = String(object.btnTitle);
        if (object.ownRoomCount != null)
            message.ownRoomCount = object.ownRoomCount | 0;
        if (object.jumpUrl != null)
            message.jumpUrl = String(object.jumpUrl);
        return message;
    };

    /**
     * Creates a plain object from a LiveRoomInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LiveRoomInfo
     * @static
     * @param {LiveRoomInfo} message LiveRoomInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LiveRoomInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.btnTitle = "";
            object.ownRoomCount = 0;
            object.jumpUrl = "";
        }
        if (message.btnTitle != null && message.hasOwnProperty("btnTitle"))
            object.btnTitle = message.btnTitle;
        if (message.ownRoomCount != null && message.hasOwnProperty("ownRoomCount"))
            object.ownRoomCount = message.ownRoomCount;
        if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
            object.jumpUrl = message.jumpUrl;
        return object;
    };

    /**
     * Converts this LiveRoomInfo to JSON.
     * @function toJSON
     * @memberof LiveRoomInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LiveRoomInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for LiveRoomInfo
     * @function getTypeUrl
     * @memberof LiveRoomInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    LiveRoomInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/LiveRoomInfo";
    };

    return LiveRoomInfo;
})();

export const MyGroupInfo = $root.MyGroupInfo = (() => {

    /**
     * Properties of a MyGroupInfo.
     * @exports IMyGroupInfo
     * @interface IMyGroupInfo
     * @property {number|Long|null} [groupId] MyGroupInfo groupId
     * @property {string|null} [groupName] MyGroupInfo groupName
     * @property {string|null} [portrait] MyGroupInfo portrait
     * @property {number|null} [memberNum] MyGroupInfo memberNum
     * @property {number|null} [maxMemberNum] MyGroupInfo maxMemberNum
     */

    /**
     * Constructs a new MyGroupInfo.
     * @exports MyGroupInfo
     * @classdesc Represents a MyGroupInfo.
     * @implements IMyGroupInfo
     * @constructor
     * @param {IMyGroupInfo=} [properties] Properties to set
     */
    function MyGroupInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MyGroupInfo groupId.
     * @member {number|Long} groupId
     * @memberof MyGroupInfo
     * @instance
     */
    MyGroupInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * MyGroupInfo groupName.
     * @member {string} groupName
     * @memberof MyGroupInfo
     * @instance
     */
    MyGroupInfo.prototype.groupName = "";

    /**
     * MyGroupInfo portrait.
     * @member {string} portrait
     * @memberof MyGroupInfo
     * @instance
     */
    MyGroupInfo.prototype.portrait = "";

    /**
     * MyGroupInfo memberNum.
     * @member {number} memberNum
     * @memberof MyGroupInfo
     * @instance
     */
    MyGroupInfo.prototype.memberNum = 0;

    /**
     * MyGroupInfo maxMemberNum.
     * @member {number} maxMemberNum
     * @memberof MyGroupInfo
     * @instance
     */
    MyGroupInfo.prototype.maxMemberNum = 0;

    /**
     * Creates a new MyGroupInfo instance using the specified properties.
     * @function create
     * @memberof MyGroupInfo
     * @static
     * @param {IMyGroupInfo=} [properties] Properties to set
     * @returns {MyGroupInfo} MyGroupInfo instance
     */
    MyGroupInfo.create = function create(properties) {
        return new MyGroupInfo(properties);
    };

    /**
     * Encodes the specified MyGroupInfo message. Does not implicitly {@link MyGroupInfo.verify|verify} messages.
     * @function encode
     * @memberof MyGroupInfo
     * @static
     * @param {IMyGroupInfo} message MyGroupInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MyGroupInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
        if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
        if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.portrait);
        if (message.memberNum != null && Object.hasOwnProperty.call(message, "memberNum"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.memberNum);
        if (message.maxMemberNum != null && Object.hasOwnProperty.call(message, "maxMemberNum"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maxMemberNum);
        return writer;
    };

    /**
     * Encodes the specified MyGroupInfo message, length delimited. Does not implicitly {@link MyGroupInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MyGroupInfo
     * @static
     * @param {IMyGroupInfo} message MyGroupInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MyGroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MyGroupInfo message from the specified reader or buffer.
     * @function decode
     * @memberof MyGroupInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MyGroupInfo} MyGroupInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MyGroupInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MyGroupInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.groupId = reader.uint64();
                    break;
                }
            case 2: {
                    message.groupName = reader.string();
                    break;
                }
            case 3: {
                    message.portrait = reader.string();
                    break;
                }
            case 4: {
                    message.memberNum = reader.uint32();
                    break;
                }
            case 5: {
                    message.maxMemberNum = reader.uint32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MyGroupInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MyGroupInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MyGroupInfo} MyGroupInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MyGroupInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MyGroupInfo message.
     * @function verify
     * @memberof MyGroupInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MyGroupInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.groupId != null && message.hasOwnProperty("groupId"))
            if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                return "groupId: integer|Long expected";
        if (message.groupName != null && message.hasOwnProperty("groupName"))
            if (!$util.isString(message.groupName))
                return "groupName: string expected";
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            if (!$util.isString(message.portrait))
                return "portrait: string expected";
        if (message.memberNum != null && message.hasOwnProperty("memberNum"))
            if (!$util.isInteger(message.memberNum))
                return "memberNum: integer expected";
        if (message.maxMemberNum != null && message.hasOwnProperty("maxMemberNum"))
            if (!$util.isInteger(message.maxMemberNum))
                return "maxMemberNum: integer expected";
        return null;
    };

    /**
     * Creates a MyGroupInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MyGroupInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MyGroupInfo} MyGroupInfo
     */
    MyGroupInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.MyGroupInfo)
            return object;
        let message = new $root.MyGroupInfo();
        if (object.groupId != null)
            if ($util.Long)
                (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
            else if (typeof object.groupId === "string")
                message.groupId = parseInt(object.groupId, 10);
            else if (typeof object.groupId === "number")
                message.groupId = object.groupId;
            else if (typeof object.groupId === "object")
                message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
        if (object.groupName != null)
            message.groupName = String(object.groupName);
        if (object.portrait != null)
            message.portrait = String(object.portrait);
        if (object.memberNum != null)
            message.memberNum = object.memberNum >>> 0;
        if (object.maxMemberNum != null)
            message.maxMemberNum = object.maxMemberNum >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a MyGroupInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MyGroupInfo
     * @static
     * @param {MyGroupInfo} message MyGroupInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MyGroupInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.groupId = options.longs === String ? "0" : 0;
            object.groupName = "";
            object.portrait = "";
            object.memberNum = 0;
            object.maxMemberNum = 0;
        }
        if (message.groupId != null && message.hasOwnProperty("groupId"))
            if (typeof message.groupId === "number")
                object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
            else
                object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
        if (message.groupName != null && message.hasOwnProperty("groupName"))
            object.groupName = message.groupName;
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            object.portrait = message.portrait;
        if (message.memberNum != null && message.hasOwnProperty("memberNum"))
            object.memberNum = message.memberNum;
        if (message.maxMemberNum != null && message.hasOwnProperty("maxMemberNum"))
            object.maxMemberNum = message.maxMemberNum;
        return object;
    };

    /**
     * Converts this MyGroupInfo to JSON.
     * @function toJSON
     * @memberof MyGroupInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MyGroupInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MyGroupInfo
     * @function getTypeUrl
     * @memberof MyGroupInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MyGroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/MyGroupInfo";
    };

    return MyGroupInfo;
})();

export const NewGodInfo = $root.NewGodInfo = (() => {

    /**
     * Properties of a NewGodInfo.
     * @exports INewGodInfo
     * @interface INewGodInfo
     * @property {number|null} [status] NewGodInfo status
     * @property {number|null} [fieldId] NewGodInfo fieldId
     * @property {string|null} [fieldName] NewGodInfo fieldName
     * @property {number|null} [type] NewGodInfo type
     * @property {string|null} [typeName] NewGodInfo typeName
     */

    /**
     * Constructs a new NewGodInfo.
     * @exports NewGodInfo
     * @classdesc Represents a NewGodInfo.
     * @implements INewGodInfo
     * @constructor
     * @param {INewGodInfo=} [properties] Properties to set
     */
    function NewGodInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NewGodInfo status.
     * @member {number} status
     * @memberof NewGodInfo
     * @instance
     */
    NewGodInfo.prototype.status = 0;

    /**
     * NewGodInfo fieldId.
     * @member {number} fieldId
     * @memberof NewGodInfo
     * @instance
     */
    NewGodInfo.prototype.fieldId = 0;

    /**
     * NewGodInfo fieldName.
     * @member {string} fieldName
     * @memberof NewGodInfo
     * @instance
     */
    NewGodInfo.prototype.fieldName = "";

    /**
     * NewGodInfo type.
     * @member {number} type
     * @memberof NewGodInfo
     * @instance
     */
    NewGodInfo.prototype.type = 0;

    /**
     * NewGodInfo typeName.
     * @member {string} typeName
     * @memberof NewGodInfo
     * @instance
     */
    NewGodInfo.prototype.typeName = "";

    /**
     * Creates a new NewGodInfo instance using the specified properties.
     * @function create
     * @memberof NewGodInfo
     * @static
     * @param {INewGodInfo=} [properties] Properties to set
     * @returns {NewGodInfo} NewGodInfo instance
     */
    NewGodInfo.create = function create(properties) {
        return new NewGodInfo(properties);
    };

    /**
     * Encodes the specified NewGodInfo message. Does not implicitly {@link NewGodInfo.verify|verify} messages.
     * @function encode
     * @memberof NewGodInfo
     * @static
     * @param {INewGodInfo} message NewGodInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NewGodInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
        if (message.fieldId != null && Object.hasOwnProperty.call(message, "fieldId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fieldId);
        if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.fieldName);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.type);
        if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.typeName);
        return writer;
    };

    /**
     * Encodes the specified NewGodInfo message, length delimited. Does not implicitly {@link NewGodInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NewGodInfo
     * @static
     * @param {INewGodInfo} message NewGodInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NewGodInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NewGodInfo message from the specified reader or buffer.
     * @function decode
     * @memberof NewGodInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NewGodInfo} NewGodInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NewGodInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NewGodInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.status = reader.int32();
                    break;
                }
            case 2: {
                    message.fieldId = reader.uint32();
                    break;
                }
            case 3: {
                    message.fieldName = reader.string();
                    break;
                }
            case 4: {
                    message.type = reader.uint32();
                    break;
                }
            case 5: {
                    message.typeName = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NewGodInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NewGodInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NewGodInfo} NewGodInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NewGodInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NewGodInfo message.
     * @function verify
     * @memberof NewGodInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NewGodInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        if (message.fieldId != null && message.hasOwnProperty("fieldId"))
            if (!$util.isInteger(message.fieldId))
                return "fieldId: integer expected";
        if (message.fieldName != null && message.hasOwnProperty("fieldName"))
            if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.typeName != null && message.hasOwnProperty("typeName"))
            if (!$util.isString(message.typeName))
                return "typeName: string expected";
        return null;
    };

    /**
     * Creates a NewGodInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NewGodInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NewGodInfo} NewGodInfo
     */
    NewGodInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.NewGodInfo)
            return object;
        let message = new $root.NewGodInfo();
        if (object.status != null)
            message.status = object.status | 0;
        if (object.fieldId != null)
            message.fieldId = object.fieldId >>> 0;
        if (object.fieldName != null)
            message.fieldName = String(object.fieldName);
        if (object.type != null)
            message.type = object.type >>> 0;
        if (object.typeName != null)
            message.typeName = String(object.typeName);
        return message;
    };

    /**
     * Creates a plain object from a NewGodInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NewGodInfo
     * @static
     * @param {NewGodInfo} message NewGodInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NewGodInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.status = 0;
            object.fieldId = 0;
            object.fieldName = "";
            object.type = 0;
            object.typeName = "";
        }
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        if (message.fieldId != null && message.hasOwnProperty("fieldId"))
            object.fieldId = message.fieldId;
        if (message.fieldName != null && message.hasOwnProperty("fieldName"))
            object.fieldName = message.fieldName;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.typeName != null && message.hasOwnProperty("typeName"))
            object.typeName = message.typeName;
        return object;
    };

    /**
     * Converts this NewGodInfo to JSON.
     * @function toJSON
     * @memberof NewGodInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NewGodInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for NewGodInfo
     * @function getTypeUrl
     * @memberof NewGodInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    NewGodInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/NewGodInfo";
    };

    return NewGodInfo;
})();

export const NewParrScores = $root.NewParrScores = (() => {

    /**
     * Properties of a NewParrScores.
     * @exports INewParrScores
     * @interface INewParrScores
     * @property {number|Long|null} [scoresTotal] NewParrScores scoresTotal
     * @property {number|null} [updateTime] NewParrScores updateTime
     * @property {number|Long|null} [iTotal] NewParrScores iTotal
     */

    /**
     * Constructs a new NewParrScores.
     * @exports NewParrScores
     * @classdesc Represents a NewParrScores.
     * @implements INewParrScores
     * @constructor
     * @param {INewParrScores=} [properties] Properties to set
     */
    function NewParrScores(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NewParrScores scoresTotal.
     * @member {number|Long} scoresTotal
     * @memberof NewParrScores
     * @instance
     */
    NewParrScores.prototype.scoresTotal = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NewParrScores updateTime.
     * @member {number} updateTime
     * @memberof NewParrScores
     * @instance
     */
    NewParrScores.prototype.updateTime = 0;

    /**
     * NewParrScores iTotal.
     * @member {number|Long} iTotal
     * @memberof NewParrScores
     * @instance
     */
    NewParrScores.prototype.iTotal = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new NewParrScores instance using the specified properties.
     * @function create
     * @memberof NewParrScores
     * @static
     * @param {INewParrScores=} [properties] Properties to set
     * @returns {NewParrScores} NewParrScores instance
     */
    NewParrScores.create = function create(properties) {
        return new NewParrScores(properties);
    };

    /**
     * Encodes the specified NewParrScores message. Does not implicitly {@link NewParrScores.verify|verify} messages.
     * @function encode
     * @memberof NewParrScores
     * @static
     * @param {INewParrScores} message NewParrScores message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NewParrScores.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.scoresTotal != null && Object.hasOwnProperty.call(message, "scoresTotal"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.scoresTotal);
        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.updateTime);
        if (message.iTotal != null && Object.hasOwnProperty.call(message, "iTotal"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.iTotal);
        return writer;
    };

    /**
     * Encodes the specified NewParrScores message, length delimited. Does not implicitly {@link NewParrScores.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NewParrScores
     * @static
     * @param {INewParrScores} message NewParrScores message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NewParrScores.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NewParrScores message from the specified reader or buffer.
     * @function decode
     * @memberof NewParrScores
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NewParrScores} NewParrScores
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NewParrScores.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NewParrScores();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.scoresTotal = reader.uint64();
                    break;
                }
            case 2: {
                    message.updateTime = reader.uint32();
                    break;
                }
            case 3: {
                    message.iTotal = reader.uint64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NewParrScores message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NewParrScores
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NewParrScores} NewParrScores
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NewParrScores.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NewParrScores message.
     * @function verify
     * @memberof NewParrScores
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NewParrScores.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.scoresTotal != null && message.hasOwnProperty("scoresTotal"))
            if (!$util.isInteger(message.scoresTotal) && !(message.scoresTotal && $util.isInteger(message.scoresTotal.low) && $util.isInteger(message.scoresTotal.high)))
                return "scoresTotal: integer|Long expected";
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            if (!$util.isInteger(message.updateTime))
                return "updateTime: integer expected";
        if (message.iTotal != null && message.hasOwnProperty("iTotal"))
            if (!$util.isInteger(message.iTotal) && !(message.iTotal && $util.isInteger(message.iTotal.low) && $util.isInteger(message.iTotal.high)))
                return "iTotal: integer|Long expected";
        return null;
    };

    /**
     * Creates a NewParrScores message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NewParrScores
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NewParrScores} NewParrScores
     */
    NewParrScores.fromObject = function fromObject(object) {
        if (object instanceof $root.NewParrScores)
            return object;
        let message = new $root.NewParrScores();
        if (object.scoresTotal != null)
            if ($util.Long)
                (message.scoresTotal = $util.Long.fromValue(object.scoresTotal)).unsigned = true;
            else if (typeof object.scoresTotal === "string")
                message.scoresTotal = parseInt(object.scoresTotal, 10);
            else if (typeof object.scoresTotal === "number")
                message.scoresTotal = object.scoresTotal;
            else if (typeof object.scoresTotal === "object")
                message.scoresTotal = new $util.LongBits(object.scoresTotal.low >>> 0, object.scoresTotal.high >>> 0).toNumber(true);
        if (object.updateTime != null)
            message.updateTime = object.updateTime >>> 0;
        if (object.iTotal != null)
            if ($util.Long)
                (message.iTotal = $util.Long.fromValue(object.iTotal)).unsigned = true;
            else if (typeof object.iTotal === "string")
                message.iTotal = parseInt(object.iTotal, 10);
            else if (typeof object.iTotal === "number")
                message.iTotal = object.iTotal;
            else if (typeof object.iTotal === "object")
                message.iTotal = new $util.LongBits(object.iTotal.low >>> 0, object.iTotal.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a NewParrScores message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NewParrScores
     * @static
     * @param {NewParrScores} message NewParrScores
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NewParrScores.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.scoresTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.scoresTotal = options.longs === String ? "0" : 0;
            object.updateTime = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.iTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.iTotal = options.longs === String ? "0" : 0;
        }
        if (message.scoresTotal != null && message.hasOwnProperty("scoresTotal"))
            if (typeof message.scoresTotal === "number")
                object.scoresTotal = options.longs === String ? String(message.scoresTotal) : message.scoresTotal;
            else
                object.scoresTotal = options.longs === String ? $util.Long.prototype.toString.call(message.scoresTotal) : options.longs === Number ? new $util.LongBits(message.scoresTotal.low >>> 0, message.scoresTotal.high >>> 0).toNumber(true) : message.scoresTotal;
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            object.updateTime = message.updateTime;
        if (message.iTotal != null && message.hasOwnProperty("iTotal"))
            if (typeof message.iTotal === "number")
                object.iTotal = options.longs === String ? String(message.iTotal) : message.iTotal;
            else
                object.iTotal = options.longs === String ? $util.Long.prototype.toString.call(message.iTotal) : options.longs === Number ? new $util.LongBits(message.iTotal.low >>> 0, message.iTotal.high >>> 0).toNumber(true) : message.iTotal;
        return object;
    };

    /**
     * Converts this NewParrScores to JSON.
     * @function toJSON
     * @memberof NewParrScores
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NewParrScores.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for NewParrScores
     * @function getTypeUrl
     * @memberof NewParrScores
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    NewParrScores.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/NewParrScores";
    };

    return NewParrScores;
})();

export const NewUser = $root.NewUser = (() => {

    /**
     * Properties of a NewUser.
     * @exports INewUser
     * @interface INewUser
     * @property {number|Long|null} [userId] NewUser userId
     * @property {string|null} [userName] NewUser userName
     * @property {number|null} [userSex] NewUser userSex
     * @property {number|null} [userStatus] NewUser userStatus
     * @property {number|null} [meizhiLevel] NewUser meizhiLevel
     * @property {number|null} [superboy] NewUser superboy
     * @property {string|null} [card] NewUser card
     * @property {IParrProps|null} [parrProps] NewUser parrProps
     * @property {IMparrProps|null} [mParrProps] NewUser mParrProps
     * @property {IWapRn|null} [wapRn] NewUser wapRn
     * @property {number|null} [isTenyear] NewUser isTenyear
     * @property {number|null} [isGroupOwner] NewUser isGroupOwner
     * @property {IParrScores|null} [parrScores] NewUser parrScores
     * @property {number|null} [userType] NewUser userType
     * @property {number|null} [useSig] NewUser useSig
     * @property {string|null} [paper] NewUser paper
     * @property {string|null} [bgId] NewUser bgId
     * @property {number|null} [isShengyou] NewUser isShengyou
     * @property {number|null} [isHardworking] NewUser isHardworking
     * @property {string|null} [billboard] NewUser billboard
     * @property {string|null} [portraitTime] NewUser portraitTime
     * @property {Array.<IProps>|null} [appraise] NewUser appraise
     * @property {string|null} [tbscoreRepeateFinishTime] NewUser tbscoreRepeateFinishTime
     * @property {number|null} [isMember] NewUser isMember
     * @property {number|null} [isPasser] NewUser isPasser
     * @property {number|null} [isQunSpring] NewUser isQunSpring
     * @property {Array.<INoticeMask>|null} [noticeMask] NewUser noticeMask
     * @property {Array.<IRpgoldicon>|null} [rpgoldicon] NewUser rpgoldicon
     * @property {string|null} [isDoudizhu] NewUser isDoudizhu
     * @property {string|null} [cdnError] NewUser cdnError
     * @property {Array.<ITbmallMonthIcon>|null} [tbmallMonthIcon] NewUser tbmallMonthIcon
     * @property {string|null} [isCoreuser] NewUser isCoreuser
     * @property {IGameAttr|null} [gameAttr] NewUser gameAttr
     * @property {string|null} [isInterestman] NewUser isInterestman
     * @property {IGlobal|null} [global] NewUser global
     * @property {string|null} [freeFlag] NewUser freeFlag
     */

    /**
     * Constructs a new NewUser.
     * @exports NewUser
     * @classdesc Represents a NewUser.
     * @implements INewUser
     * @constructor
     * @param {INewUser=} [properties] Properties to set
     */
    function NewUser(properties) {
        this.appraise = [];
        this.noticeMask = [];
        this.rpgoldicon = [];
        this.tbmallMonthIcon = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NewUser userId.
     * @member {number|Long} userId
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * NewUser userName.
     * @member {string} userName
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.userName = "";

    /**
     * NewUser userSex.
     * @member {number} userSex
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.userSex = 0;

    /**
     * NewUser userStatus.
     * @member {number} userStatus
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.userStatus = 0;

    /**
     * NewUser meizhiLevel.
     * @member {number} meizhiLevel
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.meizhiLevel = 0;

    /**
     * NewUser superboy.
     * @member {number} superboy
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.superboy = 0;

    /**
     * NewUser card.
     * @member {string} card
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.card = "";

    /**
     * NewUser parrProps.
     * @member {IParrProps|null|undefined} parrProps
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.parrProps = null;

    /**
     * NewUser mParrProps.
     * @member {IMparrProps|null|undefined} mParrProps
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.mParrProps = null;

    /**
     * NewUser wapRn.
     * @member {IWapRn|null|undefined} wapRn
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.wapRn = null;

    /**
     * NewUser isTenyear.
     * @member {number} isTenyear
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isTenyear = 0;

    /**
     * NewUser isGroupOwner.
     * @member {number} isGroupOwner
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isGroupOwner = 0;

    /**
     * NewUser parrScores.
     * @member {IParrScores|null|undefined} parrScores
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.parrScores = null;

    /**
     * NewUser userType.
     * @member {number} userType
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.userType = 0;

    /**
     * NewUser useSig.
     * @member {number} useSig
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.useSig = 0;

    /**
     * NewUser paper.
     * @member {string} paper
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.paper = "";

    /**
     * NewUser bgId.
     * @member {string} bgId
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.bgId = "";

    /**
     * NewUser isShengyou.
     * @member {number} isShengyou
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isShengyou = 0;

    /**
     * NewUser isHardworking.
     * @member {number} isHardworking
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isHardworking = 0;

    /**
     * NewUser billboard.
     * @member {string} billboard
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.billboard = "";

    /**
     * NewUser portraitTime.
     * @member {string} portraitTime
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.portraitTime = "";

    /**
     * NewUser appraise.
     * @member {Array.<IProps>} appraise
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.appraise = $util.emptyArray;

    /**
     * NewUser tbscoreRepeateFinishTime.
     * @member {string} tbscoreRepeateFinishTime
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.tbscoreRepeateFinishTime = "";

    /**
     * NewUser isMember.
     * @member {number} isMember
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isMember = 0;

    /**
     * NewUser isPasser.
     * @member {number} isPasser
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isPasser = 0;

    /**
     * NewUser isQunSpring.
     * @member {number} isQunSpring
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isQunSpring = 0;

    /**
     * NewUser noticeMask.
     * @member {Array.<INoticeMask>} noticeMask
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.noticeMask = $util.emptyArray;

    /**
     * NewUser rpgoldicon.
     * @member {Array.<IRpgoldicon>} rpgoldicon
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.rpgoldicon = $util.emptyArray;

    /**
     * NewUser isDoudizhu.
     * @member {string} isDoudizhu
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isDoudizhu = "";

    /**
     * NewUser cdnError.
     * @member {string} cdnError
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.cdnError = "";

    /**
     * NewUser tbmallMonthIcon.
     * @member {Array.<ITbmallMonthIcon>} tbmallMonthIcon
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.tbmallMonthIcon = $util.emptyArray;

    /**
     * NewUser isCoreuser.
     * @member {string} isCoreuser
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isCoreuser = "";

    /**
     * NewUser gameAttr.
     * @member {IGameAttr|null|undefined} gameAttr
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.gameAttr = null;

    /**
     * NewUser isInterestman.
     * @member {string} isInterestman
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.isInterestman = "";

    /**
     * NewUser global.
     * @member {IGlobal|null|undefined} global
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.global = null;

    /**
     * NewUser freeFlag.
     * @member {string} freeFlag
     * @memberof NewUser
     * @instance
     */
    NewUser.prototype.freeFlag = "";

    /**
     * Creates a new NewUser instance using the specified properties.
     * @function create
     * @memberof NewUser
     * @static
     * @param {INewUser=} [properties] Properties to set
     * @returns {NewUser} NewUser instance
     */
    NewUser.create = function create(properties) {
        return new NewUser(properties);
    };

    /**
     * Encodes the specified NewUser message. Does not implicitly {@link NewUser.verify|verify} messages.
     * @function encode
     * @memberof NewUser
     * @static
     * @param {INewUser} message NewUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NewUser.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.userId);
        if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.userName);
        if (message.userSex != null && Object.hasOwnProperty.call(message, "userSex"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userSex);
        if (message.userStatus != null && Object.hasOwnProperty.call(message, "userStatus"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.userStatus);
        if (message.meizhiLevel != null && Object.hasOwnProperty.call(message, "meizhiLevel"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.meizhiLevel);
        if (message.superboy != null && Object.hasOwnProperty.call(message, "superboy"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.superboy);
        if (message.card != null && Object.hasOwnProperty.call(message, "card"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.card);
        if (message.parrProps != null && Object.hasOwnProperty.call(message, "parrProps"))
            $root.ParrProps.encode(message.parrProps, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.mParrProps != null && Object.hasOwnProperty.call(message, "mParrProps"))
            $root.MparrProps.encode(message.mParrProps, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.wapRn != null && Object.hasOwnProperty.call(message, "wapRn"))
            $root.WapRn.encode(message.wapRn, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.isTenyear != null && Object.hasOwnProperty.call(message, "isTenyear"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.isTenyear);
        if (message.isGroupOwner != null && Object.hasOwnProperty.call(message, "isGroupOwner"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.isGroupOwner);
        if (message.parrScores != null && Object.hasOwnProperty.call(message, "parrScores"))
            $root.ParrScores.encode(message.parrScores, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.userType != null && Object.hasOwnProperty.call(message, "userType"))
            writer.uint32(/* id 14, wireType 0 =*/112).int32(message.userType);
        if (message.useSig != null && Object.hasOwnProperty.call(message, "useSig"))
            writer.uint32(/* id 15, wireType 0 =*/120).int32(message.useSig);
        if (message.paper != null && Object.hasOwnProperty.call(message, "paper"))
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.paper);
        if (message.bgId != null && Object.hasOwnProperty.call(message, "bgId"))
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.bgId);
        if (message.isShengyou != null && Object.hasOwnProperty.call(message, "isShengyou"))
            writer.uint32(/* id 18, wireType 0 =*/144).int32(message.isShengyou);
        if (message.isHardworking != null && Object.hasOwnProperty.call(message, "isHardworking"))
            writer.uint32(/* id 19, wireType 0 =*/152).int32(message.isHardworking);
        if (message.billboard != null && Object.hasOwnProperty.call(message, "billboard"))
            writer.uint32(/* id 20, wireType 2 =*/162).string(message.billboard);
        if (message.portraitTime != null && Object.hasOwnProperty.call(message, "portraitTime"))
            writer.uint32(/* id 21, wireType 2 =*/170).string(message.portraitTime);
        if (message.appraise != null && message.appraise.length)
            for (let i = 0; i < message.appraise.length; ++i)
                $root.Props.encode(message.appraise[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
        if (message.tbscoreRepeateFinishTime != null && Object.hasOwnProperty.call(message, "tbscoreRepeateFinishTime"))
            writer.uint32(/* id 23, wireType 2 =*/186).string(message.tbscoreRepeateFinishTime);
        if (message.isMember != null && Object.hasOwnProperty.call(message, "isMember"))
            writer.uint32(/* id 24, wireType 0 =*/192).int32(message.isMember);
        if (message.isPasser != null && Object.hasOwnProperty.call(message, "isPasser"))
            writer.uint32(/* id 25, wireType 0 =*/200).int32(message.isPasser);
        if (message.isQunSpring != null && Object.hasOwnProperty.call(message, "isQunSpring"))
            writer.uint32(/* id 26, wireType 0 =*/208).int32(message.isQunSpring);
        if (message.noticeMask != null && message.noticeMask.length)
            for (let i = 0; i < message.noticeMask.length; ++i)
                $root.NoticeMask.encode(message.noticeMask[i], writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
        if (message.rpgoldicon != null && message.rpgoldicon.length)
            for (let i = 0; i < message.rpgoldicon.length; ++i)
                $root.Rpgoldicon.encode(message.rpgoldicon[i], writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
        if (message.isDoudizhu != null && Object.hasOwnProperty.call(message, "isDoudizhu"))
            writer.uint32(/* id 29, wireType 2 =*/234).string(message.isDoudizhu);
        if (message.cdnError != null && Object.hasOwnProperty.call(message, "cdnError"))
            writer.uint32(/* id 30, wireType 2 =*/242).string(message.cdnError);
        if (message.tbmallMonthIcon != null && message.tbmallMonthIcon.length)
            for (let i = 0; i < message.tbmallMonthIcon.length; ++i)
                $root.TbmallMonthIcon.encode(message.tbmallMonthIcon[i], writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
        if (message.isCoreuser != null && Object.hasOwnProperty.call(message, "isCoreuser"))
            writer.uint32(/* id 32, wireType 2 =*/258).string(message.isCoreuser);
        if (message.gameAttr != null && Object.hasOwnProperty.call(message, "gameAttr"))
            $root.GameAttr.encode(message.gameAttr, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
        if (message.isInterestman != null && Object.hasOwnProperty.call(message, "isInterestman"))
            writer.uint32(/* id 34, wireType 2 =*/274).string(message.isInterestman);
        if (message.global != null && Object.hasOwnProperty.call(message, "global"))
            $root.Global.encode(message.global, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
        if (message.freeFlag != null && Object.hasOwnProperty.call(message, "freeFlag"))
            writer.uint32(/* id 36, wireType 2 =*/290).string(message.freeFlag);
        return writer;
    };

    /**
     * Encodes the specified NewUser message, length delimited. Does not implicitly {@link NewUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NewUser
     * @static
     * @param {INewUser} message NewUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NewUser.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NewUser message from the specified reader or buffer.
     * @function decode
     * @memberof NewUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NewUser} NewUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NewUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NewUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.userId = reader.int64();
                    break;
                }
            case 2: {
                    message.userName = reader.string();
                    break;
                }
            case 3: {
                    message.userSex = reader.int32();
                    break;
                }
            case 4: {
                    message.userStatus = reader.int32();
                    break;
                }
            case 5: {
                    message.meizhiLevel = reader.int32();
                    break;
                }
            case 6: {
                    message.superboy = reader.int32();
                    break;
                }
            case 7: {
                    message.card = reader.string();
                    break;
                }
            case 8: {
                    message.parrProps = $root.ParrProps.decode(reader, reader.uint32());
                    break;
                }
            case 9: {
                    message.mParrProps = $root.MparrProps.decode(reader, reader.uint32());
                    break;
                }
            case 10: {
                    message.wapRn = $root.WapRn.decode(reader, reader.uint32());
                    break;
                }
            case 11: {
                    message.isTenyear = reader.int32();
                    break;
                }
            case 12: {
                    message.isGroupOwner = reader.int32();
                    break;
                }
            case 13: {
                    message.parrScores = $root.ParrScores.decode(reader, reader.uint32());
                    break;
                }
            case 14: {
                    message.userType = reader.int32();
                    break;
                }
            case 15: {
                    message.useSig = reader.int32();
                    break;
                }
            case 16: {
                    message.paper = reader.string();
                    break;
                }
            case 17: {
                    message.bgId = reader.string();
                    break;
                }
            case 18: {
                    message.isShengyou = reader.int32();
                    break;
                }
            case 19: {
                    message.isHardworking = reader.int32();
                    break;
                }
            case 20: {
                    message.billboard = reader.string();
                    break;
                }
            case 21: {
                    message.portraitTime = reader.string();
                    break;
                }
            case 22: {
                    if (!(message.appraise && message.appraise.length))
                        message.appraise = [];
                    message.appraise.push($root.Props.decode(reader, reader.uint32()));
                    break;
                }
            case 23: {
                    message.tbscoreRepeateFinishTime = reader.string();
                    break;
                }
            case 24: {
                    message.isMember = reader.int32();
                    break;
                }
            case 25: {
                    message.isPasser = reader.int32();
                    break;
                }
            case 26: {
                    message.isQunSpring = reader.int32();
                    break;
                }
            case 27: {
                    if (!(message.noticeMask && message.noticeMask.length))
                        message.noticeMask = [];
                    message.noticeMask.push($root.NoticeMask.decode(reader, reader.uint32()));
                    break;
                }
            case 28: {
                    if (!(message.rpgoldicon && message.rpgoldicon.length))
                        message.rpgoldicon = [];
                    message.rpgoldicon.push($root.Rpgoldicon.decode(reader, reader.uint32()));
                    break;
                }
            case 29: {
                    message.isDoudizhu = reader.string();
                    break;
                }
            case 30: {
                    message.cdnError = reader.string();
                    break;
                }
            case 31: {
                    if (!(message.tbmallMonthIcon && message.tbmallMonthIcon.length))
                        message.tbmallMonthIcon = [];
                    message.tbmallMonthIcon.push($root.TbmallMonthIcon.decode(reader, reader.uint32()));
                    break;
                }
            case 32: {
                    message.isCoreuser = reader.string();
                    break;
                }
            case 33: {
                    message.gameAttr = $root.GameAttr.decode(reader, reader.uint32());
                    break;
                }
            case 34: {
                    message.isInterestman = reader.string();
                    break;
                }
            case 35: {
                    message.global = $root.Global.decode(reader, reader.uint32());
                    break;
                }
            case 36: {
                    message.freeFlag = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NewUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NewUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NewUser} NewUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NewUser.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NewUser message.
     * @function verify
     * @memberof NewUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NewUser.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                return "userId: integer|Long expected";
        if (message.userName != null && message.hasOwnProperty("userName"))
            if (!$util.isString(message.userName))
                return "userName: string expected";
        if (message.userSex != null && message.hasOwnProperty("userSex"))
            if (!$util.isInteger(message.userSex))
                return "userSex: integer expected";
        if (message.userStatus != null && message.hasOwnProperty("userStatus"))
            if (!$util.isInteger(message.userStatus))
                return "userStatus: integer expected";
        if (message.meizhiLevel != null && message.hasOwnProperty("meizhiLevel"))
            if (!$util.isInteger(message.meizhiLevel))
                return "meizhiLevel: integer expected";
        if (message.superboy != null && message.hasOwnProperty("superboy"))
            if (!$util.isInteger(message.superboy))
                return "superboy: integer expected";
        if (message.card != null && message.hasOwnProperty("card"))
            if (!$util.isString(message.card))
                return "card: string expected";
        if (message.parrProps != null && message.hasOwnProperty("parrProps")) {
            let error = $root.ParrProps.verify(message.parrProps);
            if (error)
                return "parrProps." + error;
        }
        if (message.mParrProps != null && message.hasOwnProperty("mParrProps")) {
            let error = $root.MparrProps.verify(message.mParrProps);
            if (error)
                return "mParrProps." + error;
        }
        if (message.wapRn != null && message.hasOwnProperty("wapRn")) {
            let error = $root.WapRn.verify(message.wapRn);
            if (error)
                return "wapRn." + error;
        }
        if (message.isTenyear != null && message.hasOwnProperty("isTenyear"))
            if (!$util.isInteger(message.isTenyear))
                return "isTenyear: integer expected";
        if (message.isGroupOwner != null && message.hasOwnProperty("isGroupOwner"))
            if (!$util.isInteger(message.isGroupOwner))
                return "isGroupOwner: integer expected";
        if (message.parrScores != null && message.hasOwnProperty("parrScores")) {
            let error = $root.ParrScores.verify(message.parrScores);
            if (error)
                return "parrScores." + error;
        }
        if (message.userType != null && message.hasOwnProperty("userType"))
            if (!$util.isInteger(message.userType))
                return "userType: integer expected";
        if (message.useSig != null && message.hasOwnProperty("useSig"))
            if (!$util.isInteger(message.useSig))
                return "useSig: integer expected";
        if (message.paper != null && message.hasOwnProperty("paper"))
            if (!$util.isString(message.paper))
                return "paper: string expected";
        if (message.bgId != null && message.hasOwnProperty("bgId"))
            if (!$util.isString(message.bgId))
                return "bgId: string expected";
        if (message.isShengyou != null && message.hasOwnProperty("isShengyou"))
            if (!$util.isInteger(message.isShengyou))
                return "isShengyou: integer expected";
        if (message.isHardworking != null && message.hasOwnProperty("isHardworking"))
            if (!$util.isInteger(message.isHardworking))
                return "isHardworking: integer expected";
        if (message.billboard != null && message.hasOwnProperty("billboard"))
            if (!$util.isString(message.billboard))
                return "billboard: string expected";
        if (message.portraitTime != null && message.hasOwnProperty("portraitTime"))
            if (!$util.isString(message.portraitTime))
                return "portraitTime: string expected";
        if (message.appraise != null && message.hasOwnProperty("appraise")) {
            if (!Array.isArray(message.appraise))
                return "appraise: array expected";
            for (let i = 0; i < message.appraise.length; ++i) {
                let error = $root.Props.verify(message.appraise[i]);
                if (error)
                    return "appraise." + error;
            }
        }
        if (message.tbscoreRepeateFinishTime != null && message.hasOwnProperty("tbscoreRepeateFinishTime"))
            if (!$util.isString(message.tbscoreRepeateFinishTime))
                return "tbscoreRepeateFinishTime: string expected";
        if (message.isMember != null && message.hasOwnProperty("isMember"))
            if (!$util.isInteger(message.isMember))
                return "isMember: integer expected";
        if (message.isPasser != null && message.hasOwnProperty("isPasser"))
            if (!$util.isInteger(message.isPasser))
                return "isPasser: integer expected";
        if (message.isQunSpring != null && message.hasOwnProperty("isQunSpring"))
            if (!$util.isInteger(message.isQunSpring))
                return "isQunSpring: integer expected";
        if (message.noticeMask != null && message.hasOwnProperty("noticeMask")) {
            if (!Array.isArray(message.noticeMask))
                return "noticeMask: array expected";
            for (let i = 0; i < message.noticeMask.length; ++i) {
                let error = $root.NoticeMask.verify(message.noticeMask[i]);
                if (error)
                    return "noticeMask." + error;
            }
        }
        if (message.rpgoldicon != null && message.hasOwnProperty("rpgoldicon")) {
            if (!Array.isArray(message.rpgoldicon))
                return "rpgoldicon: array expected";
            for (let i = 0; i < message.rpgoldicon.length; ++i) {
                let error = $root.Rpgoldicon.verify(message.rpgoldicon[i]);
                if (error)
                    return "rpgoldicon." + error;
            }
        }
        if (message.isDoudizhu != null && message.hasOwnProperty("isDoudizhu"))
            if (!$util.isString(message.isDoudizhu))
                return "isDoudizhu: string expected";
        if (message.cdnError != null && message.hasOwnProperty("cdnError"))
            if (!$util.isString(message.cdnError))
                return "cdnError: string expected";
        if (message.tbmallMonthIcon != null && message.hasOwnProperty("tbmallMonthIcon")) {
            if (!Array.isArray(message.tbmallMonthIcon))
                return "tbmallMonthIcon: array expected";
            for (let i = 0; i < message.tbmallMonthIcon.length; ++i) {
                let error = $root.TbmallMonthIcon.verify(message.tbmallMonthIcon[i]);
                if (error)
                    return "tbmallMonthIcon." + error;
            }
        }
        if (message.isCoreuser != null && message.hasOwnProperty("isCoreuser"))
            if (!$util.isString(message.isCoreuser))
                return "isCoreuser: string expected";
        if (message.gameAttr != null && message.hasOwnProperty("gameAttr")) {
            let error = $root.GameAttr.verify(message.gameAttr);
            if (error)
                return "gameAttr." + error;
        }
        if (message.isInterestman != null && message.hasOwnProperty("isInterestman"))
            if (!$util.isString(message.isInterestman))
                return "isInterestman: string expected";
        if (message.global != null && message.hasOwnProperty("global")) {
            let error = $root.Global.verify(message.global);
            if (error)
                return "global." + error;
        }
        if (message.freeFlag != null && message.hasOwnProperty("freeFlag"))
            if (!$util.isString(message.freeFlag))
                return "freeFlag: string expected";
        return null;
    };

    /**
     * Creates a NewUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NewUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NewUser} NewUser
     */
    NewUser.fromObject = function fromObject(object) {
        if (object instanceof $root.NewUser)
            return object;
        let message = new $root.NewUser();
        if (object.userId != null)
            if ($util.Long)
                (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
            else if (typeof object.userId === "string")
                message.userId = parseInt(object.userId, 10);
            else if (typeof object.userId === "number")
                message.userId = object.userId;
            else if (typeof object.userId === "object")
                message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
        if (object.userName != null)
            message.userName = String(object.userName);
        if (object.userSex != null)
            message.userSex = object.userSex | 0;
        if (object.userStatus != null)
            message.userStatus = object.userStatus | 0;
        if (object.meizhiLevel != null)
            message.meizhiLevel = object.meizhiLevel | 0;
        if (object.superboy != null)
            message.superboy = object.superboy | 0;
        if (object.card != null)
            message.card = String(object.card);
        if (object.parrProps != null) {
            if (typeof object.parrProps !== "object")
                throw TypeError(".NewUser.parrProps: object expected");
            message.parrProps = $root.ParrProps.fromObject(object.parrProps);
        }
        if (object.mParrProps != null) {
            if (typeof object.mParrProps !== "object")
                throw TypeError(".NewUser.mParrProps: object expected");
            message.mParrProps = $root.MparrProps.fromObject(object.mParrProps);
        }
        if (object.wapRn != null) {
            if (typeof object.wapRn !== "object")
                throw TypeError(".NewUser.wapRn: object expected");
            message.wapRn = $root.WapRn.fromObject(object.wapRn);
        }
        if (object.isTenyear != null)
            message.isTenyear = object.isTenyear | 0;
        if (object.isGroupOwner != null)
            message.isGroupOwner = object.isGroupOwner | 0;
        if (object.parrScores != null) {
            if (typeof object.parrScores !== "object")
                throw TypeError(".NewUser.parrScores: object expected");
            message.parrScores = $root.ParrScores.fromObject(object.parrScores);
        }
        if (object.userType != null)
            message.userType = object.userType | 0;
        if (object.useSig != null)
            message.useSig = object.useSig | 0;
        if (object.paper != null)
            message.paper = String(object.paper);
        if (object.bgId != null)
            message.bgId = String(object.bgId);
        if (object.isShengyou != null)
            message.isShengyou = object.isShengyou | 0;
        if (object.isHardworking != null)
            message.isHardworking = object.isHardworking | 0;
        if (object.billboard != null)
            message.billboard = String(object.billboard);
        if (object.portraitTime != null)
            message.portraitTime = String(object.portraitTime);
        if (object.appraise) {
            if (!Array.isArray(object.appraise))
                throw TypeError(".NewUser.appraise: array expected");
            message.appraise = [];
            for (let i = 0; i < object.appraise.length; ++i) {
                if (typeof object.appraise[i] !== "object")
                    throw TypeError(".NewUser.appraise: object expected");
                message.appraise[i] = $root.Props.fromObject(object.appraise[i]);
            }
        }
        if (object.tbscoreRepeateFinishTime != null)
            message.tbscoreRepeateFinishTime = String(object.tbscoreRepeateFinishTime);
        if (object.isMember != null)
            message.isMember = object.isMember | 0;
        if (object.isPasser != null)
            message.isPasser = object.isPasser | 0;
        if (object.isQunSpring != null)
            message.isQunSpring = object.isQunSpring | 0;
        if (object.noticeMask) {
            if (!Array.isArray(object.noticeMask))
                throw TypeError(".NewUser.noticeMask: array expected");
            message.noticeMask = [];
            for (let i = 0; i < object.noticeMask.length; ++i) {
                if (typeof object.noticeMask[i] !== "object")
                    throw TypeError(".NewUser.noticeMask: object expected");
                message.noticeMask[i] = $root.NoticeMask.fromObject(object.noticeMask[i]);
            }
        }
        if (object.rpgoldicon) {
            if (!Array.isArray(object.rpgoldicon))
                throw TypeError(".NewUser.rpgoldicon: array expected");
            message.rpgoldicon = [];
            for (let i = 0; i < object.rpgoldicon.length; ++i) {
                if (typeof object.rpgoldicon[i] !== "object")
                    throw TypeError(".NewUser.rpgoldicon: object expected");
                message.rpgoldicon[i] = $root.Rpgoldicon.fromObject(object.rpgoldicon[i]);
            }
        }
        if (object.isDoudizhu != null)
            message.isDoudizhu = String(object.isDoudizhu);
        if (object.cdnError != null)
            message.cdnError = String(object.cdnError);
        if (object.tbmallMonthIcon) {
            if (!Array.isArray(object.tbmallMonthIcon))
                throw TypeError(".NewUser.tbmallMonthIcon: array expected");
            message.tbmallMonthIcon = [];
            for (let i = 0; i < object.tbmallMonthIcon.length; ++i) {
                if (typeof object.tbmallMonthIcon[i] !== "object")
                    throw TypeError(".NewUser.tbmallMonthIcon: object expected");
                message.tbmallMonthIcon[i] = $root.TbmallMonthIcon.fromObject(object.tbmallMonthIcon[i]);
            }
        }
        if (object.isCoreuser != null)
            message.isCoreuser = String(object.isCoreuser);
        if (object.gameAttr != null) {
            if (typeof object.gameAttr !== "object")
                throw TypeError(".NewUser.gameAttr: object expected");
            message.gameAttr = $root.GameAttr.fromObject(object.gameAttr);
        }
        if (object.isInterestman != null)
            message.isInterestman = String(object.isInterestman);
        if (object.global != null) {
            if (typeof object.global !== "object")
                throw TypeError(".NewUser.global: object expected");
            message.global = $root.Global.fromObject(object.global);
        }
        if (object.freeFlag != null)
            message.freeFlag = String(object.freeFlag);
        return message;
    };

    /**
     * Creates a plain object from a NewUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NewUser
     * @static
     * @param {NewUser} message NewUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NewUser.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.appraise = [];
            object.noticeMask = [];
            object.rpgoldicon = [];
            object.tbmallMonthIcon = [];
        }
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.userId = options.longs === String ? "0" : 0;
            object.userName = "";
            object.userSex = 0;
            object.userStatus = 0;
            object.meizhiLevel = 0;
            object.superboy = 0;
            object.card = "";
            object.parrProps = null;
            object.mParrProps = null;
            object.wapRn = null;
            object.isTenyear = 0;
            object.isGroupOwner = 0;
            object.parrScores = null;
            object.userType = 0;
            object.useSig = 0;
            object.paper = "";
            object.bgId = "";
            object.isShengyou = 0;
            object.isHardworking = 0;
            object.billboard = "";
            object.portraitTime = "";
            object.tbscoreRepeateFinishTime = "";
            object.isMember = 0;
            object.isPasser = 0;
            object.isQunSpring = 0;
            object.isDoudizhu = "";
            object.cdnError = "";
            object.isCoreuser = "";
            object.gameAttr = null;
            object.isInterestman = "";
            object.global = null;
            object.freeFlag = "";
        }
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (typeof message.userId === "number")
                object.userId = options.longs === String ? String(message.userId) : message.userId;
            else
                object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
        if (message.userName != null && message.hasOwnProperty("userName"))
            object.userName = message.userName;
        if (message.userSex != null && message.hasOwnProperty("userSex"))
            object.userSex = message.userSex;
        if (message.userStatus != null && message.hasOwnProperty("userStatus"))
            object.userStatus = message.userStatus;
        if (message.meizhiLevel != null && message.hasOwnProperty("meizhiLevel"))
            object.meizhiLevel = message.meizhiLevel;
        if (message.superboy != null && message.hasOwnProperty("superboy"))
            object.superboy = message.superboy;
        if (message.card != null && message.hasOwnProperty("card"))
            object.card = message.card;
        if (message.parrProps != null && message.hasOwnProperty("parrProps"))
            object.parrProps = $root.ParrProps.toObject(message.parrProps, options);
        if (message.mParrProps != null && message.hasOwnProperty("mParrProps"))
            object.mParrProps = $root.MparrProps.toObject(message.mParrProps, options);
        if (message.wapRn != null && message.hasOwnProperty("wapRn"))
            object.wapRn = $root.WapRn.toObject(message.wapRn, options);
        if (message.isTenyear != null && message.hasOwnProperty("isTenyear"))
            object.isTenyear = message.isTenyear;
        if (message.isGroupOwner != null && message.hasOwnProperty("isGroupOwner"))
            object.isGroupOwner = message.isGroupOwner;
        if (message.parrScores != null && message.hasOwnProperty("parrScores"))
            object.parrScores = $root.ParrScores.toObject(message.parrScores, options);
        if (message.userType != null && message.hasOwnProperty("userType"))
            object.userType = message.userType;
        if (message.useSig != null && message.hasOwnProperty("useSig"))
            object.useSig = message.useSig;
        if (message.paper != null && message.hasOwnProperty("paper"))
            object.paper = message.paper;
        if (message.bgId != null && message.hasOwnProperty("bgId"))
            object.bgId = message.bgId;
        if (message.isShengyou != null && message.hasOwnProperty("isShengyou"))
            object.isShengyou = message.isShengyou;
        if (message.isHardworking != null && message.hasOwnProperty("isHardworking"))
            object.isHardworking = message.isHardworking;
        if (message.billboard != null && message.hasOwnProperty("billboard"))
            object.billboard = message.billboard;
        if (message.portraitTime != null && message.hasOwnProperty("portraitTime"))
            object.portraitTime = message.portraitTime;
        if (message.appraise && message.appraise.length) {
            object.appraise = [];
            for (let j = 0; j < message.appraise.length; ++j)
                object.appraise[j] = $root.Props.toObject(message.appraise[j], options);
        }
        if (message.tbscoreRepeateFinishTime != null && message.hasOwnProperty("tbscoreRepeateFinishTime"))
            object.tbscoreRepeateFinishTime = message.tbscoreRepeateFinishTime;
        if (message.isMember != null && message.hasOwnProperty("isMember"))
            object.isMember = message.isMember;
        if (message.isPasser != null && message.hasOwnProperty("isPasser"))
            object.isPasser = message.isPasser;
        if (message.isQunSpring != null && message.hasOwnProperty("isQunSpring"))
            object.isQunSpring = message.isQunSpring;
        if (message.noticeMask && message.noticeMask.length) {
            object.noticeMask = [];
            for (let j = 0; j < message.noticeMask.length; ++j)
                object.noticeMask[j] = $root.NoticeMask.toObject(message.noticeMask[j], options);
        }
        if (message.rpgoldicon && message.rpgoldicon.length) {
            object.rpgoldicon = [];
            for (let j = 0; j < message.rpgoldicon.length; ++j)
                object.rpgoldicon[j] = $root.Rpgoldicon.toObject(message.rpgoldicon[j], options);
        }
        if (message.isDoudizhu != null && message.hasOwnProperty("isDoudizhu"))
            object.isDoudizhu = message.isDoudizhu;
        if (message.cdnError != null && message.hasOwnProperty("cdnError"))
            object.cdnError = message.cdnError;
        if (message.tbmallMonthIcon && message.tbmallMonthIcon.length) {
            object.tbmallMonthIcon = [];
            for (let j = 0; j < message.tbmallMonthIcon.length; ++j)
                object.tbmallMonthIcon[j] = $root.TbmallMonthIcon.toObject(message.tbmallMonthIcon[j], options);
        }
        if (message.isCoreuser != null && message.hasOwnProperty("isCoreuser"))
            object.isCoreuser = message.isCoreuser;
        if (message.gameAttr != null && message.hasOwnProperty("gameAttr"))
            object.gameAttr = $root.GameAttr.toObject(message.gameAttr, options);
        if (message.isInterestman != null && message.hasOwnProperty("isInterestman"))
            object.isInterestman = message.isInterestman;
        if (message.global != null && message.hasOwnProperty("global"))
            object.global = $root.Global.toObject(message.global, options);
        if (message.freeFlag != null && message.hasOwnProperty("freeFlag"))
            object.freeFlag = message.freeFlag;
        return object;
    };

    /**
     * Converts this NewUser to JSON.
     * @function toJSON
     * @memberof NewUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NewUser.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for NewUser
     * @function getTypeUrl
     * @memberof NewUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    NewUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/NewUser";
    };

    return NewUser;
})();

export const GameAttr = $root.GameAttr = (() => {

    /**
     * Properties of a GameAttr.
     * @exports IGameAttr
     * @interface IGameAttr
     * @property {string|null} [userId] GameAttr userId
     * @property {ISignatureInfo|null} [signatureInfo] GameAttr signatureInfo
     * @property {string|null} [isOpen] GameAttr isOpen
     */

    /**
     * Constructs a new GameAttr.
     * @exports GameAttr
     * @classdesc Represents a GameAttr.
     * @implements IGameAttr
     * @constructor
     * @param {IGameAttr=} [properties] Properties to set
     */
    function GameAttr(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GameAttr userId.
     * @member {string} userId
     * @memberof GameAttr
     * @instance
     */
    GameAttr.prototype.userId = "";

    /**
     * GameAttr signatureInfo.
     * @member {ISignatureInfo|null|undefined} signatureInfo
     * @memberof GameAttr
     * @instance
     */
    GameAttr.prototype.signatureInfo = null;

    /**
     * GameAttr isOpen.
     * @member {string} isOpen
     * @memberof GameAttr
     * @instance
     */
    GameAttr.prototype.isOpen = "";

    /**
     * Creates a new GameAttr instance using the specified properties.
     * @function create
     * @memberof GameAttr
     * @static
     * @param {IGameAttr=} [properties] Properties to set
     * @returns {GameAttr} GameAttr instance
     */
    GameAttr.create = function create(properties) {
        return new GameAttr(properties);
    };

    /**
     * Encodes the specified GameAttr message. Does not implicitly {@link GameAttr.verify|verify} messages.
     * @function encode
     * @memberof GameAttr
     * @static
     * @param {IGameAttr} message GameAttr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GameAttr.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
        if (message.signatureInfo != null && Object.hasOwnProperty.call(message, "signatureInfo"))
            $root.SignatureInfo.encode(message.signatureInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.isOpen != null && Object.hasOwnProperty.call(message, "isOpen"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.isOpen);
        return writer;
    };

    /**
     * Encodes the specified GameAttr message, length delimited. Does not implicitly {@link GameAttr.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GameAttr
     * @static
     * @param {IGameAttr} message GameAttr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GameAttr.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GameAttr message from the specified reader or buffer.
     * @function decode
     * @memberof GameAttr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GameAttr} GameAttr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GameAttr.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GameAttr();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.userId = reader.string();
                    break;
                }
            case 2: {
                    message.signatureInfo = $root.SignatureInfo.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.isOpen = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GameAttr message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GameAttr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GameAttr} GameAttr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GameAttr.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GameAttr message.
     * @function verify
     * @memberof GameAttr
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GameAttr.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (!$util.isString(message.userId))
                return "userId: string expected";
        if (message.signatureInfo != null && message.hasOwnProperty("signatureInfo")) {
            let error = $root.SignatureInfo.verify(message.signatureInfo);
            if (error)
                return "signatureInfo." + error;
        }
        if (message.isOpen != null && message.hasOwnProperty("isOpen"))
            if (!$util.isString(message.isOpen))
                return "isOpen: string expected";
        return null;
    };

    /**
     * Creates a GameAttr message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GameAttr
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GameAttr} GameAttr
     */
    GameAttr.fromObject = function fromObject(object) {
        if (object instanceof $root.GameAttr)
            return object;
        let message = new $root.GameAttr();
        if (object.userId != null)
            message.userId = String(object.userId);
        if (object.signatureInfo != null) {
            if (typeof object.signatureInfo !== "object")
                throw TypeError(".GameAttr.signatureInfo: object expected");
            message.signatureInfo = $root.SignatureInfo.fromObject(object.signatureInfo);
        }
        if (object.isOpen != null)
            message.isOpen = String(object.isOpen);
        return message;
    };

    /**
     * Creates a plain object from a GameAttr message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GameAttr
     * @static
     * @param {GameAttr} message GameAttr
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GameAttr.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.userId = "";
            object.signatureInfo = null;
            object.isOpen = "";
        }
        if (message.userId != null && message.hasOwnProperty("userId"))
            object.userId = message.userId;
        if (message.signatureInfo != null && message.hasOwnProperty("signatureInfo"))
            object.signatureInfo = $root.SignatureInfo.toObject(message.signatureInfo, options);
        if (message.isOpen != null && message.hasOwnProperty("isOpen"))
            object.isOpen = message.isOpen;
        return object;
    };

    /**
     * Converts this GameAttr to JSON.
     * @function toJSON
     * @memberof GameAttr
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GameAttr.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GameAttr
     * @function getTypeUrl
     * @memberof GameAttr
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GameAttr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/GameAttr";
    };

    return GameAttr;
})();

export const SignatureInfo = $root.SignatureInfo = (() => {

    /**
     * Properties of a SignatureInfo.
     * @exports ISignatureInfo
     * @interface ISignatureInfo
     * @property {IEquipment|null} [equipment] SignatureInfo equipment
     * @property {string|null} [gameId] SignatureInfo gameId
     * @property {string|null} [gameName] SignatureInfo gameName
     * @property {string|null} [player] SignatureInfo player
     * @property {IAvatar|null} [avatar] SignatureInfo avatar
     * @property {string|null} [power] SignatureInfo power
     * @property {string|null} [server] SignatureInfo server
     */

    /**
     * Constructs a new SignatureInfo.
     * @exports SignatureInfo
     * @classdesc Represents a SignatureInfo.
     * @implements ISignatureInfo
     * @constructor
     * @param {ISignatureInfo=} [properties] Properties to set
     */
    function SignatureInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SignatureInfo equipment.
     * @member {IEquipment|null|undefined} equipment
     * @memberof SignatureInfo
     * @instance
     */
    SignatureInfo.prototype.equipment = null;

    /**
     * SignatureInfo gameId.
     * @member {string} gameId
     * @memberof SignatureInfo
     * @instance
     */
    SignatureInfo.prototype.gameId = "";

    /**
     * SignatureInfo gameName.
     * @member {string} gameName
     * @memberof SignatureInfo
     * @instance
     */
    SignatureInfo.prototype.gameName = "";

    /**
     * SignatureInfo player.
     * @member {string} player
     * @memberof SignatureInfo
     * @instance
     */
    SignatureInfo.prototype.player = "";

    /**
     * SignatureInfo avatar.
     * @member {IAvatar|null|undefined} avatar
     * @memberof SignatureInfo
     * @instance
     */
    SignatureInfo.prototype.avatar = null;

    /**
     * SignatureInfo power.
     * @member {string} power
     * @memberof SignatureInfo
     * @instance
     */
    SignatureInfo.prototype.power = "";

    /**
     * SignatureInfo server.
     * @member {string} server
     * @memberof SignatureInfo
     * @instance
     */
    SignatureInfo.prototype.server = "";

    /**
     * Creates a new SignatureInfo instance using the specified properties.
     * @function create
     * @memberof SignatureInfo
     * @static
     * @param {ISignatureInfo=} [properties] Properties to set
     * @returns {SignatureInfo} SignatureInfo instance
     */
    SignatureInfo.create = function create(properties) {
        return new SignatureInfo(properties);
    };

    /**
     * Encodes the specified SignatureInfo message. Does not implicitly {@link SignatureInfo.verify|verify} messages.
     * @function encode
     * @memberof SignatureInfo
     * @static
     * @param {ISignatureInfo} message SignatureInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignatureInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.equipment != null && Object.hasOwnProperty.call(message, "equipment"))
            $root.Equipment.encode(message.equipment, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameId);
        if (message.gameName != null && Object.hasOwnProperty.call(message, "gameName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.gameName);
        if (message.player != null && Object.hasOwnProperty.call(message, "player"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.player);
        if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
            $root.Avatar.encode(message.avatar, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.power != null && Object.hasOwnProperty.call(message, "power"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.power);
        if (message.server != null && Object.hasOwnProperty.call(message, "server"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.server);
        return writer;
    };

    /**
     * Encodes the specified SignatureInfo message, length delimited. Does not implicitly {@link SignatureInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SignatureInfo
     * @static
     * @param {ISignatureInfo} message SignatureInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignatureInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SignatureInfo message from the specified reader or buffer.
     * @function decode
     * @memberof SignatureInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SignatureInfo} SignatureInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignatureInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SignatureInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.equipment = $root.Equipment.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.gameId = reader.string();
                    break;
                }
            case 3: {
                    message.gameName = reader.string();
                    break;
                }
            case 4: {
                    message.player = reader.string();
                    break;
                }
            case 5: {
                    message.avatar = $root.Avatar.decode(reader, reader.uint32());
                    break;
                }
            case 6: {
                    message.power = reader.string();
                    break;
                }
            case 7: {
                    message.server = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SignatureInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SignatureInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SignatureInfo} SignatureInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignatureInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SignatureInfo message.
     * @function verify
     * @memberof SignatureInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SignatureInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.equipment != null && message.hasOwnProperty("equipment")) {
            let error = $root.Equipment.verify(message.equipment);
            if (error)
                return "equipment." + error;
        }
        if (message.gameId != null && message.hasOwnProperty("gameId"))
            if (!$util.isString(message.gameId))
                return "gameId: string expected";
        if (message.gameName != null && message.hasOwnProperty("gameName"))
            if (!$util.isString(message.gameName))
                return "gameName: string expected";
        if (message.player != null && message.hasOwnProperty("player"))
            if (!$util.isString(message.player))
                return "player: string expected";
        if (message.avatar != null && message.hasOwnProperty("avatar")) {
            let error = $root.Avatar.verify(message.avatar);
            if (error)
                return "avatar." + error;
        }
        if (message.power != null && message.hasOwnProperty("power"))
            if (!$util.isString(message.power))
                return "power: string expected";
        if (message.server != null && message.hasOwnProperty("server"))
            if (!$util.isString(message.server))
                return "server: string expected";
        return null;
    };

    /**
     * Creates a SignatureInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SignatureInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SignatureInfo} SignatureInfo
     */
    SignatureInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.SignatureInfo)
            return object;
        let message = new $root.SignatureInfo();
        if (object.equipment != null) {
            if (typeof object.equipment !== "object")
                throw TypeError(".SignatureInfo.equipment: object expected");
            message.equipment = $root.Equipment.fromObject(object.equipment);
        }
        if (object.gameId != null)
            message.gameId = String(object.gameId);
        if (object.gameName != null)
            message.gameName = String(object.gameName);
        if (object.player != null)
            message.player = String(object.player);
        if (object.avatar != null) {
            if (typeof object.avatar !== "object")
                throw TypeError(".SignatureInfo.avatar: object expected");
            message.avatar = $root.Avatar.fromObject(object.avatar);
        }
        if (object.power != null)
            message.power = String(object.power);
        if (object.server != null)
            message.server = String(object.server);
        return message;
    };

    /**
     * Creates a plain object from a SignatureInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SignatureInfo
     * @static
     * @param {SignatureInfo} message SignatureInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SignatureInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.equipment = null;
            object.gameId = "";
            object.gameName = "";
            object.player = "";
            object.avatar = null;
            object.power = "";
            object.server = "";
        }
        if (message.equipment != null && message.hasOwnProperty("equipment"))
            object.equipment = $root.Equipment.toObject(message.equipment, options);
        if (message.gameId != null && message.hasOwnProperty("gameId"))
            object.gameId = message.gameId;
        if (message.gameName != null && message.hasOwnProperty("gameName"))
            object.gameName = message.gameName;
        if (message.player != null && message.hasOwnProperty("player"))
            object.player = message.player;
        if (message.avatar != null && message.hasOwnProperty("avatar"))
            object.avatar = $root.Avatar.toObject(message.avatar, options);
        if (message.power != null && message.hasOwnProperty("power"))
            object.power = message.power;
        if (message.server != null && message.hasOwnProperty("server"))
            object.server = message.server;
        return object;
    };

    /**
     * Converts this SignatureInfo to JSON.
     * @function toJSON
     * @memberof SignatureInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SignatureInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SignatureInfo
     * @function getTypeUrl
     * @memberof SignatureInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SignatureInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SignatureInfo";
    };

    return SignatureInfo;
})();

export const Avatar = $root.Avatar = (() => {

    /**
     * Properties of an Avatar.
     * @exports IAvatar
     * @interface IAvatar
     * @property {string|null} [pic] Avatar pic
     * @property {string|null} [pos] Avatar pos
     */

    /**
     * Constructs a new Avatar.
     * @exports Avatar
     * @classdesc Represents an Avatar.
     * @implements IAvatar
     * @constructor
     * @param {IAvatar=} [properties] Properties to set
     */
    function Avatar(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Avatar pic.
     * @member {string} pic
     * @memberof Avatar
     * @instance
     */
    Avatar.prototype.pic = "";

    /**
     * Avatar pos.
     * @member {string} pos
     * @memberof Avatar
     * @instance
     */
    Avatar.prototype.pos = "";

    /**
     * Creates a new Avatar instance using the specified properties.
     * @function create
     * @memberof Avatar
     * @static
     * @param {IAvatar=} [properties] Properties to set
     * @returns {Avatar} Avatar instance
     */
    Avatar.create = function create(properties) {
        return new Avatar(properties);
    };

    /**
     * Encodes the specified Avatar message. Does not implicitly {@link Avatar.verify|verify} messages.
     * @function encode
     * @memberof Avatar
     * @static
     * @param {IAvatar} message Avatar message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Avatar.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pic != null && Object.hasOwnProperty.call(message, "pic"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.pic);
        if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.pos);
        return writer;
    };

    /**
     * Encodes the specified Avatar message, length delimited. Does not implicitly {@link Avatar.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Avatar
     * @static
     * @param {IAvatar} message Avatar message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Avatar.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Avatar message from the specified reader or buffer.
     * @function decode
     * @memberof Avatar
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Avatar} Avatar
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Avatar.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Avatar();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.pic = reader.string();
                    break;
                }
            case 2: {
                    message.pos = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Avatar message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Avatar
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Avatar} Avatar
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Avatar.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Avatar message.
     * @function verify
     * @memberof Avatar
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Avatar.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pic != null && message.hasOwnProperty("pic"))
            if (!$util.isString(message.pic))
                return "pic: string expected";
        if (message.pos != null && message.hasOwnProperty("pos"))
            if (!$util.isString(message.pos))
                return "pos: string expected";
        return null;
    };

    /**
     * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Avatar
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Avatar} Avatar
     */
    Avatar.fromObject = function fromObject(object) {
        if (object instanceof $root.Avatar)
            return object;
        let message = new $root.Avatar();
        if (object.pic != null)
            message.pic = String(object.pic);
        if (object.pos != null)
            message.pos = String(object.pos);
        return message;
    };

    /**
     * Creates a plain object from an Avatar message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Avatar
     * @static
     * @param {Avatar} message Avatar
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Avatar.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.pic = "";
            object.pos = "";
        }
        if (message.pic != null && message.hasOwnProperty("pic"))
            object.pic = message.pic;
        if (message.pos != null && message.hasOwnProperty("pos"))
            object.pos = message.pos;
        return object;
    };

    /**
     * Converts this Avatar to JSON.
     * @function toJSON
     * @memberof Avatar
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Avatar.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Avatar
     * @function getTypeUrl
     * @memberof Avatar
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Avatar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Avatar";
    };

    return Avatar;
})();

export const Equipment = $root.Equipment = (() => {

    /**
     * Properties of an Equipment.
     * @exports IEquipment
     * @interface IEquipment
     * @property {string|null} [name] Equipment name
     * @property {string|null} [portrait] Equipment portrait
     */

    /**
     * Constructs a new Equipment.
     * @exports Equipment
     * @classdesc Represents an Equipment.
     * @implements IEquipment
     * @constructor
     * @param {IEquipment=} [properties] Properties to set
     */
    function Equipment(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Equipment name.
     * @member {string} name
     * @memberof Equipment
     * @instance
     */
    Equipment.prototype.name = "";

    /**
     * Equipment portrait.
     * @member {string} portrait
     * @memberof Equipment
     * @instance
     */
    Equipment.prototype.portrait = "";

    /**
     * Creates a new Equipment instance using the specified properties.
     * @function create
     * @memberof Equipment
     * @static
     * @param {IEquipment=} [properties] Properties to set
     * @returns {Equipment} Equipment instance
     */
    Equipment.create = function create(properties) {
        return new Equipment(properties);
    };

    /**
     * Encodes the specified Equipment message. Does not implicitly {@link Equipment.verify|verify} messages.
     * @function encode
     * @memberof Equipment
     * @static
     * @param {IEquipment} message Equipment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Equipment.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.portrait);
        return writer;
    };

    /**
     * Encodes the specified Equipment message, length delimited. Does not implicitly {@link Equipment.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Equipment
     * @static
     * @param {IEquipment} message Equipment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Equipment.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Equipment message from the specified reader or buffer.
     * @function decode
     * @memberof Equipment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Equipment} Equipment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Equipment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Equipment();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.name = reader.string();
                    break;
                }
            case 2: {
                    message.portrait = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Equipment message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Equipment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Equipment} Equipment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Equipment.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Equipment message.
     * @function verify
     * @memberof Equipment
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Equipment.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            if (!$util.isString(message.portrait))
                return "portrait: string expected";
        return null;
    };

    /**
     * Creates an Equipment message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Equipment
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Equipment} Equipment
     */
    Equipment.fromObject = function fromObject(object) {
        if (object instanceof $root.Equipment)
            return object;
        let message = new $root.Equipment();
        if (object.name != null)
            message.name = String(object.name);
        if (object.portrait != null)
            message.portrait = String(object.portrait);
        return message;
    };

    /**
     * Creates a plain object from an Equipment message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Equipment
     * @static
     * @param {Equipment} message Equipment
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Equipment.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.portrait = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            object.portrait = message.portrait;
        return object;
    };

    /**
     * Converts this Equipment to JSON.
     * @function toJSON
     * @memberof Equipment
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Equipment.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Equipment
     * @function getTypeUrl
     * @memberof Equipment
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Equipment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Equipment";
    };

    return Equipment;
})();

export const Global = $root.Global = (() => {

    /**
     * Properties of a Global.
     * @exports IGlobal
     * @interface IGlobal
     * @property {string|null} [tbmallNewprops] Global tbmallNewprops
     */

    /**
     * Constructs a new Global.
     * @exports Global
     * @classdesc Represents a Global.
     * @implements IGlobal
     * @constructor
     * @param {IGlobal=} [properties] Properties to set
     */
    function Global(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Global tbmallNewprops.
     * @member {string} tbmallNewprops
     * @memberof Global
     * @instance
     */
    Global.prototype.tbmallNewprops = "";

    /**
     * Creates a new Global instance using the specified properties.
     * @function create
     * @memberof Global
     * @static
     * @param {IGlobal=} [properties] Properties to set
     * @returns {Global} Global instance
     */
    Global.create = function create(properties) {
        return new Global(properties);
    };

    /**
     * Encodes the specified Global message. Does not implicitly {@link Global.verify|verify} messages.
     * @function encode
     * @memberof Global
     * @static
     * @param {IGlobal} message Global message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Global.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.tbmallNewprops != null && Object.hasOwnProperty.call(message, "tbmallNewprops"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tbmallNewprops);
        return writer;
    };

    /**
     * Encodes the specified Global message, length delimited. Does not implicitly {@link Global.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Global
     * @static
     * @param {IGlobal} message Global message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Global.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Global message from the specified reader or buffer.
     * @function decode
     * @memberof Global
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Global} Global
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Global.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Global();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.tbmallNewprops = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Global message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Global
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Global} Global
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Global.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Global message.
     * @function verify
     * @memberof Global
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Global.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.tbmallNewprops != null && message.hasOwnProperty("tbmallNewprops"))
            if (!$util.isString(message.tbmallNewprops))
                return "tbmallNewprops: string expected";
        return null;
    };

    /**
     * Creates a Global message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Global
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Global} Global
     */
    Global.fromObject = function fromObject(object) {
        if (object instanceof $root.Global)
            return object;
        let message = new $root.Global();
        if (object.tbmallNewprops != null)
            message.tbmallNewprops = String(object.tbmallNewprops);
        return message;
    };

    /**
     * Creates a plain object from a Global message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Global
     * @static
     * @param {Global} message Global
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Global.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.tbmallNewprops = "";
        if (message.tbmallNewprops != null && message.hasOwnProperty("tbmallNewprops"))
            object.tbmallNewprops = message.tbmallNewprops;
        return object;
    };

    /**
     * Converts this Global to JSON.
     * @function toJSON
     * @memberof Global
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Global.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Global
     * @function getTypeUrl
     * @memberof Global
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Global.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Global";
    };

    return Global;
})();

export const MparrProps = $root.MparrProps = (() => {

    /**
     * Properties of a MparrProps.
     * @exports IMparrProps
     * @interface IMparrProps
     * @property {IAvatarFrame|null} [avatarframe] MparrProps avatarframe
     * @property {IPortrait|null} [portrait] MparrProps portrait
     * @property {ILevel|null} [level] MparrProps level
     * @property {Array.<IProps>|null} [props] MparrProps props
     */

    /**
     * Constructs a new MparrProps.
     * @exports MparrProps
     * @classdesc Represents a MparrProps.
     * @implements IMparrProps
     * @constructor
     * @param {IMparrProps=} [properties] Properties to set
     */
    function MparrProps(properties) {
        this.props = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MparrProps avatarframe.
     * @member {IAvatarFrame|null|undefined} avatarframe
     * @memberof MparrProps
     * @instance
     */
    MparrProps.prototype.avatarframe = null;

    /**
     * MparrProps portrait.
     * @member {IPortrait|null|undefined} portrait
     * @memberof MparrProps
     * @instance
     */
    MparrProps.prototype.portrait = null;

    /**
     * MparrProps level.
     * @member {ILevel|null|undefined} level
     * @memberof MparrProps
     * @instance
     */
    MparrProps.prototype.level = null;

    /**
     * MparrProps props.
     * @member {Array.<IProps>} props
     * @memberof MparrProps
     * @instance
     */
    MparrProps.prototype.props = $util.emptyArray;

    /**
     * Creates a new MparrProps instance using the specified properties.
     * @function create
     * @memberof MparrProps
     * @static
     * @param {IMparrProps=} [properties] Properties to set
     * @returns {MparrProps} MparrProps instance
     */
    MparrProps.create = function create(properties) {
        return new MparrProps(properties);
    };

    /**
     * Encodes the specified MparrProps message. Does not implicitly {@link MparrProps.verify|verify} messages.
     * @function encode
     * @memberof MparrProps
     * @static
     * @param {IMparrProps} message MparrProps message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MparrProps.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.avatarframe != null && Object.hasOwnProperty.call(message, "avatarframe"))
            $root.AvatarFrame.encode(message.avatarframe, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
            $root.Portrait.encode(message.portrait, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
            $root.Level.encode(message.level, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.props != null && message.props.length)
            for (let i = 0; i < message.props.length; ++i)
                $root.Props.encode(message.props[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MparrProps message, length delimited. Does not implicitly {@link MparrProps.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MparrProps
     * @static
     * @param {IMparrProps} message MparrProps message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MparrProps.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MparrProps message from the specified reader or buffer.
     * @function decode
     * @memberof MparrProps
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MparrProps} MparrProps
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MparrProps.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MparrProps();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.avatarframe = $root.AvatarFrame.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.portrait = $root.Portrait.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.level = $root.Level.decode(reader, reader.uint32());
                    break;
                }
            case 4: {
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.Props.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MparrProps message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MparrProps
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MparrProps} MparrProps
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MparrProps.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MparrProps message.
     * @function verify
     * @memberof MparrProps
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MparrProps.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.avatarframe != null && message.hasOwnProperty("avatarframe")) {
            let error = $root.AvatarFrame.verify(message.avatarframe);
            if (error)
                return "avatarframe." + error;
        }
        if (message.portrait != null && message.hasOwnProperty("portrait")) {
            let error = $root.Portrait.verify(message.portrait);
            if (error)
                return "portrait." + error;
        }
        if (message.level != null && message.hasOwnProperty("level")) {
            let error = $root.Level.verify(message.level);
            if (error)
                return "level." + error;
        }
        if (message.props != null && message.hasOwnProperty("props")) {
            if (!Array.isArray(message.props))
                return "props: array expected";
            for (let i = 0; i < message.props.length; ++i) {
                let error = $root.Props.verify(message.props[i]);
                if (error)
                    return "props." + error;
            }
        }
        return null;
    };

    /**
     * Creates a MparrProps message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MparrProps
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MparrProps} MparrProps
     */
    MparrProps.fromObject = function fromObject(object) {
        if (object instanceof $root.MparrProps)
            return object;
        let message = new $root.MparrProps();
        if (object.avatarframe != null) {
            if (typeof object.avatarframe !== "object")
                throw TypeError(".MparrProps.avatarframe: object expected");
            message.avatarframe = $root.AvatarFrame.fromObject(object.avatarframe);
        }
        if (object.portrait != null) {
            if (typeof object.portrait !== "object")
                throw TypeError(".MparrProps.portrait: object expected");
            message.portrait = $root.Portrait.fromObject(object.portrait);
        }
        if (object.level != null) {
            if (typeof object.level !== "object")
                throw TypeError(".MparrProps.level: object expected");
            message.level = $root.Level.fromObject(object.level);
        }
        if (object.props) {
            if (!Array.isArray(object.props))
                throw TypeError(".MparrProps.props: array expected");
            message.props = [];
            for (let i = 0; i < object.props.length; ++i) {
                if (typeof object.props[i] !== "object")
                    throw TypeError(".MparrProps.props: object expected");
                message.props[i] = $root.Props.fromObject(object.props[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a MparrProps message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MparrProps
     * @static
     * @param {MparrProps} message MparrProps
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MparrProps.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.props = [];
        if (options.defaults) {
            object.avatarframe = null;
            object.portrait = null;
            object.level = null;
        }
        if (message.avatarframe != null && message.hasOwnProperty("avatarframe"))
            object.avatarframe = $root.AvatarFrame.toObject(message.avatarframe, options);
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            object.portrait = $root.Portrait.toObject(message.portrait, options);
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = $root.Level.toObject(message.level, options);
        if (message.props && message.props.length) {
            object.props = [];
            for (let j = 0; j < message.props.length; ++j)
                object.props[j] = $root.Props.toObject(message.props[j], options);
        }
        return object;
    };

    /**
     * Converts this MparrProps to JSON.
     * @function toJSON
     * @memberof MparrProps
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MparrProps.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MparrProps
     * @function getTypeUrl
     * @memberof MparrProps
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MparrProps.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/MparrProps";
    };

    return MparrProps;
})();

export const AvatarFrame = $root.AvatarFrame = (() => {

    /**
     * Properties of an AvatarFrame.
     * @exports IAvatarFrame
     * @interface IAvatarFrame
     * @property {number|null} [propsId] AvatarFrame propsId
     * @property {number|null} [endTime] AvatarFrame endTime
     */

    /**
     * Constructs a new AvatarFrame.
     * @exports AvatarFrame
     * @classdesc Represents an AvatarFrame.
     * @implements IAvatarFrame
     * @constructor
     * @param {IAvatarFrame=} [properties] Properties to set
     */
    function AvatarFrame(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AvatarFrame propsId.
     * @member {number} propsId
     * @memberof AvatarFrame
     * @instance
     */
    AvatarFrame.prototype.propsId = 0;

    /**
     * AvatarFrame endTime.
     * @member {number} endTime
     * @memberof AvatarFrame
     * @instance
     */
    AvatarFrame.prototype.endTime = 0;

    /**
     * Creates a new AvatarFrame instance using the specified properties.
     * @function create
     * @memberof AvatarFrame
     * @static
     * @param {IAvatarFrame=} [properties] Properties to set
     * @returns {AvatarFrame} AvatarFrame instance
     */
    AvatarFrame.create = function create(properties) {
        return new AvatarFrame(properties);
    };

    /**
     * Encodes the specified AvatarFrame message. Does not implicitly {@link AvatarFrame.verify|verify} messages.
     * @function encode
     * @memberof AvatarFrame
     * @static
     * @param {IAvatarFrame} message AvatarFrame message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvatarFrame.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propsId);
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endTime);
        return writer;
    };

    /**
     * Encodes the specified AvatarFrame message, length delimited. Does not implicitly {@link AvatarFrame.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AvatarFrame
     * @static
     * @param {IAvatarFrame} message AvatarFrame message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvatarFrame.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AvatarFrame message from the specified reader or buffer.
     * @function decode
     * @memberof AvatarFrame
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AvatarFrame} AvatarFrame
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvatarFrame.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AvatarFrame();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.propsId = reader.int32();
                    break;
                }
            case 2: {
                    message.endTime = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AvatarFrame message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AvatarFrame
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AvatarFrame} AvatarFrame
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvatarFrame.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AvatarFrame message.
     * @function verify
     * @memberof AvatarFrame
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AvatarFrame.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isInteger(message.propsId))
                return "propsId: integer expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime))
                return "endTime: integer expected";
        return null;
    };

    /**
     * Creates an AvatarFrame message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AvatarFrame
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AvatarFrame} AvatarFrame
     */
    AvatarFrame.fromObject = function fromObject(object) {
        if (object instanceof $root.AvatarFrame)
            return object;
        let message = new $root.AvatarFrame();
        if (object.propsId != null)
            message.propsId = object.propsId | 0;
        if (object.endTime != null)
            message.endTime = object.endTime | 0;
        return message;
    };

    /**
     * Creates a plain object from an AvatarFrame message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AvatarFrame
     * @static
     * @param {AvatarFrame} message AvatarFrame
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AvatarFrame.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.propsId = 0;
            object.endTime = 0;
        }
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            object.propsId = message.propsId;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            object.endTime = message.endTime;
        return object;
    };

    /**
     * Converts this AvatarFrame to JSON.
     * @function toJSON
     * @memberof AvatarFrame
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AvatarFrame.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AvatarFrame
     * @function getTypeUrl
     * @memberof AvatarFrame
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AvatarFrame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AvatarFrame";
    };

    return AvatarFrame;
})();

export const Level = $root.Level = (() => {

    /**
     * Properties of a Level.
     * @exports ILevel
     * @interface ILevel
     * @property {number|null} [propsId] Level propsId
     * @property {string|null} [propsType] Level propsType
     * @property {string|null} [propsCategory] Level propsCategory
     * @property {number|null} [endTime] Level endTime
     * @property {number|null} [leftNum] Level leftNum
     * @property {number|null} [updateTime] Level updateTime
     * @property {string|null} [usedStatus] Level usedStatus
     * @property {string|null} [openStatus] Level openStatus
     * @property {string|null} [expiringNotify] Level expiringNotify
     * @property {string|null} [expiredNotify] Level expiredNotify
     * @property {string|null} [maxFreeScore] Level maxFreeScore
     * @property {string|null} [picUrl] Level picUrl
     */

    /**
     * Constructs a new Level.
     * @exports Level
     * @classdesc Represents a Level.
     * @implements ILevel
     * @constructor
     * @param {ILevel=} [properties] Properties to set
     */
    function Level(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Level propsId.
     * @member {number} propsId
     * @memberof Level
     * @instance
     */
    Level.prototype.propsId = 0;

    /**
     * Level propsType.
     * @member {string} propsType
     * @memberof Level
     * @instance
     */
    Level.prototype.propsType = "";

    /**
     * Level propsCategory.
     * @member {string} propsCategory
     * @memberof Level
     * @instance
     */
    Level.prototype.propsCategory = "";

    /**
     * Level endTime.
     * @member {number} endTime
     * @memberof Level
     * @instance
     */
    Level.prototype.endTime = 0;

    /**
     * Level leftNum.
     * @member {number} leftNum
     * @memberof Level
     * @instance
     */
    Level.prototype.leftNum = 0;

    /**
     * Level updateTime.
     * @member {number} updateTime
     * @memberof Level
     * @instance
     */
    Level.prototype.updateTime = 0;

    /**
     * Level usedStatus.
     * @member {string} usedStatus
     * @memberof Level
     * @instance
     */
    Level.prototype.usedStatus = "";

    /**
     * Level openStatus.
     * @member {string} openStatus
     * @memberof Level
     * @instance
     */
    Level.prototype.openStatus = "";

    /**
     * Level expiringNotify.
     * @member {string} expiringNotify
     * @memberof Level
     * @instance
     */
    Level.prototype.expiringNotify = "";

    /**
     * Level expiredNotify.
     * @member {string} expiredNotify
     * @memberof Level
     * @instance
     */
    Level.prototype.expiredNotify = "";

    /**
     * Level maxFreeScore.
     * @member {string} maxFreeScore
     * @memberof Level
     * @instance
     */
    Level.prototype.maxFreeScore = "";

    /**
     * Level picUrl.
     * @member {string} picUrl
     * @memberof Level
     * @instance
     */
    Level.prototype.picUrl = "";

    /**
     * Creates a new Level instance using the specified properties.
     * @function create
     * @memberof Level
     * @static
     * @param {ILevel=} [properties] Properties to set
     * @returns {Level} Level instance
     */
    Level.create = function create(properties) {
        return new Level(properties);
    };

    /**
     * Encodes the specified Level message. Does not implicitly {@link Level.verify|verify} messages.
     * @function encode
     * @memberof Level
     * @static
     * @param {ILevel} message Level message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Level.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propsId);
        if (message.propsType != null && Object.hasOwnProperty.call(message, "propsType"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.propsType);
        if (message.propsCategory != null && Object.hasOwnProperty.call(message, "propsCategory"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.propsCategory);
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.endTime);
        if (message.leftNum != null && Object.hasOwnProperty.call(message, "leftNum"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.leftNum);
        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.updateTime);
        if (message.usedStatus != null && Object.hasOwnProperty.call(message, "usedStatus"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.usedStatus);
        if (message.openStatus != null && Object.hasOwnProperty.call(message, "openStatus"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.openStatus);
        if (message.expiringNotify != null && Object.hasOwnProperty.call(message, "expiringNotify"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.expiringNotify);
        if (message.expiredNotify != null && Object.hasOwnProperty.call(message, "expiredNotify"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.expiredNotify);
        if (message.maxFreeScore != null && Object.hasOwnProperty.call(message, "maxFreeScore"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.maxFreeScore);
        if (message.picUrl != null && Object.hasOwnProperty.call(message, "picUrl"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.picUrl);
        return writer;
    };

    /**
     * Encodes the specified Level message, length delimited. Does not implicitly {@link Level.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Level
     * @static
     * @param {ILevel} message Level message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Level.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Level message from the specified reader or buffer.
     * @function decode
     * @memberof Level
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Level} Level
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Level.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Level();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.propsId = reader.int32();
                    break;
                }
            case 2: {
                    message.propsType = reader.string();
                    break;
                }
            case 3: {
                    message.propsCategory = reader.string();
                    break;
                }
            case 4: {
                    message.endTime = reader.int32();
                    break;
                }
            case 5: {
                    message.leftNum = reader.int32();
                    break;
                }
            case 6: {
                    message.updateTime = reader.int32();
                    break;
                }
            case 7: {
                    message.usedStatus = reader.string();
                    break;
                }
            case 8: {
                    message.openStatus = reader.string();
                    break;
                }
            case 9: {
                    message.expiringNotify = reader.string();
                    break;
                }
            case 10: {
                    message.expiredNotify = reader.string();
                    break;
                }
            case 11: {
                    message.maxFreeScore = reader.string();
                    break;
                }
            case 12: {
                    message.picUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Level message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Level
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Level} Level
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Level.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Level message.
     * @function verify
     * @memberof Level
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Level.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isInteger(message.propsId))
                return "propsId: integer expected";
        if (message.propsType != null && message.hasOwnProperty("propsType"))
            if (!$util.isString(message.propsType))
                return "propsType: string expected";
        if (message.propsCategory != null && message.hasOwnProperty("propsCategory"))
            if (!$util.isString(message.propsCategory))
                return "propsCategory: string expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime))
                return "endTime: integer expected";
        if (message.leftNum != null && message.hasOwnProperty("leftNum"))
            if (!$util.isInteger(message.leftNum))
                return "leftNum: integer expected";
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            if (!$util.isInteger(message.updateTime))
                return "updateTime: integer expected";
        if (message.usedStatus != null && message.hasOwnProperty("usedStatus"))
            if (!$util.isString(message.usedStatus))
                return "usedStatus: string expected";
        if (message.openStatus != null && message.hasOwnProperty("openStatus"))
            if (!$util.isString(message.openStatus))
                return "openStatus: string expected";
        if (message.expiringNotify != null && message.hasOwnProperty("expiringNotify"))
            if (!$util.isString(message.expiringNotify))
                return "expiringNotify: string expected";
        if (message.expiredNotify != null && message.hasOwnProperty("expiredNotify"))
            if (!$util.isString(message.expiredNotify))
                return "expiredNotify: string expected";
        if (message.maxFreeScore != null && message.hasOwnProperty("maxFreeScore"))
            if (!$util.isString(message.maxFreeScore))
                return "maxFreeScore: string expected";
        if (message.picUrl != null && message.hasOwnProperty("picUrl"))
            if (!$util.isString(message.picUrl))
                return "picUrl: string expected";
        return null;
    };

    /**
     * Creates a Level message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Level
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Level} Level
     */
    Level.fromObject = function fromObject(object) {
        if (object instanceof $root.Level)
            return object;
        let message = new $root.Level();
        if (object.propsId != null)
            message.propsId = object.propsId | 0;
        if (object.propsType != null)
            message.propsType = String(object.propsType);
        if (object.propsCategory != null)
            message.propsCategory = String(object.propsCategory);
        if (object.endTime != null)
            message.endTime = object.endTime | 0;
        if (object.leftNum != null)
            message.leftNum = object.leftNum | 0;
        if (object.updateTime != null)
            message.updateTime = object.updateTime | 0;
        if (object.usedStatus != null)
            message.usedStatus = String(object.usedStatus);
        if (object.openStatus != null)
            message.openStatus = String(object.openStatus);
        if (object.expiringNotify != null)
            message.expiringNotify = String(object.expiringNotify);
        if (object.expiredNotify != null)
            message.expiredNotify = String(object.expiredNotify);
        if (object.maxFreeScore != null)
            message.maxFreeScore = String(object.maxFreeScore);
        if (object.picUrl != null)
            message.picUrl = String(object.picUrl);
        return message;
    };

    /**
     * Creates a plain object from a Level message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Level
     * @static
     * @param {Level} message Level
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Level.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.propsId = 0;
            object.propsType = "";
            object.propsCategory = "";
            object.endTime = 0;
            object.leftNum = 0;
            object.updateTime = 0;
            object.usedStatus = "";
            object.openStatus = "";
            object.expiringNotify = "";
            object.expiredNotify = "";
            object.maxFreeScore = "";
            object.picUrl = "";
        }
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            object.propsId = message.propsId;
        if (message.propsType != null && message.hasOwnProperty("propsType"))
            object.propsType = message.propsType;
        if (message.propsCategory != null && message.hasOwnProperty("propsCategory"))
            object.propsCategory = message.propsCategory;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            object.endTime = message.endTime;
        if (message.leftNum != null && message.hasOwnProperty("leftNum"))
            object.leftNum = message.leftNum;
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            object.updateTime = message.updateTime;
        if (message.usedStatus != null && message.hasOwnProperty("usedStatus"))
            object.usedStatus = message.usedStatus;
        if (message.openStatus != null && message.hasOwnProperty("openStatus"))
            object.openStatus = message.openStatus;
        if (message.expiringNotify != null && message.hasOwnProperty("expiringNotify"))
            object.expiringNotify = message.expiringNotify;
        if (message.expiredNotify != null && message.hasOwnProperty("expiredNotify"))
            object.expiredNotify = message.expiredNotify;
        if (message.maxFreeScore != null && message.hasOwnProperty("maxFreeScore"))
            object.maxFreeScore = message.maxFreeScore;
        if (message.picUrl != null && message.hasOwnProperty("picUrl"))
            object.picUrl = message.picUrl;
        return object;
    };

    /**
     * Converts this Level to JSON.
     * @function toJSON
     * @memberof Level
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Level.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Level
     * @function getTypeUrl
     * @memberof Level
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Level.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Level";
    };

    return Level;
})();

export const Portrait = $root.Portrait = (() => {

    /**
     * Properties of a Portrait.
     * @exports IPortrait
     * @interface IPortrait
     * @property {number|null} [propsId] Portrait propsId
     * @property {number|null} [endTime] Portrait endTime
     * @property {string|null} [url] Portrait url
     */

    /**
     * Constructs a new Portrait.
     * @exports Portrait
     * @classdesc Represents a Portrait.
     * @implements IPortrait
     * @constructor
     * @param {IPortrait=} [properties] Properties to set
     */
    function Portrait(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Portrait propsId.
     * @member {number} propsId
     * @memberof Portrait
     * @instance
     */
    Portrait.prototype.propsId = 0;

    /**
     * Portrait endTime.
     * @member {number} endTime
     * @memberof Portrait
     * @instance
     */
    Portrait.prototype.endTime = 0;

    /**
     * Portrait url.
     * @member {string} url
     * @memberof Portrait
     * @instance
     */
    Portrait.prototype.url = "";

    /**
     * Creates a new Portrait instance using the specified properties.
     * @function create
     * @memberof Portrait
     * @static
     * @param {IPortrait=} [properties] Properties to set
     * @returns {Portrait} Portrait instance
     */
    Portrait.create = function create(properties) {
        return new Portrait(properties);
    };

    /**
     * Encodes the specified Portrait message. Does not implicitly {@link Portrait.verify|verify} messages.
     * @function encode
     * @memberof Portrait
     * @static
     * @param {IPortrait} message Portrait message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Portrait.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propsId);
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endTime);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
        return writer;
    };

    /**
     * Encodes the specified Portrait message, length delimited. Does not implicitly {@link Portrait.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Portrait
     * @static
     * @param {IPortrait} message Portrait message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Portrait.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Portrait message from the specified reader or buffer.
     * @function decode
     * @memberof Portrait
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Portrait} Portrait
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Portrait.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Portrait();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.propsId = reader.int32();
                    break;
                }
            case 2: {
                    message.endTime = reader.int32();
                    break;
                }
            case 3: {
                    message.url = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Portrait message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Portrait
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Portrait} Portrait
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Portrait.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Portrait message.
     * @function verify
     * @memberof Portrait
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Portrait.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isInteger(message.propsId))
                return "propsId: integer expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime))
                return "endTime: integer expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        return null;
    };

    /**
     * Creates a Portrait message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Portrait
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Portrait} Portrait
     */
    Portrait.fromObject = function fromObject(object) {
        if (object instanceof $root.Portrait)
            return object;
        let message = new $root.Portrait();
        if (object.propsId != null)
            message.propsId = object.propsId | 0;
        if (object.endTime != null)
            message.endTime = object.endTime | 0;
        if (object.url != null)
            message.url = String(object.url);
        return message;
    };

    /**
     * Creates a plain object from a Portrait message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Portrait
     * @static
     * @param {Portrait} message Portrait
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Portrait.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.propsId = 0;
            object.endTime = 0;
            object.url = "";
        }
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            object.propsId = message.propsId;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            object.endTime = message.endTime;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        return object;
    };

    /**
     * Converts this Portrait to JSON.
     * @function toJSON
     * @memberof Portrait
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Portrait.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Portrait
     * @function getTypeUrl
     * @memberof Portrait
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Portrait.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Portrait";
    };

    return Portrait;
})();

export const Props = $root.Props = (() => {

    /**
     * Properties of a Props.
     * @exports IProps
     * @interface IProps
     * @property {number|null} [propsId] Props propsId
     * @property {string|null} [propsType] Props propsType
     * @property {string|null} [propsCategory] Props propsCategory
     * @property {number|null} [leftNum] Props leftNum
     * @property {string|null} [usedStatus] Props usedStatus
     * @property {number|null} [num] Props num
     * @property {string|null} [endTime] Props endTime
     * @property {string|null} [notice] Props notice
     * @property {number|null} [updateTime] Props updateTime
     * @property {string|null} [openStatus] Props openStatus
     * @property {string|null} [expiringNotify] Props expiringNotify
     * @property {string|null} [expiredNotify] Props expiredNotify
     * @property {string|null} [title] Props title
     * @property {Array.<string>|null} [_word] Props _word
     * @property {Array.<string>|null} [pattern] Props pattern
     */

    /**
     * Constructs a new Props.
     * @exports Props
     * @classdesc Represents a Props.
     * @implements IProps
     * @constructor
     * @param {IProps=} [properties] Properties to set
     */
    function Props(properties) {
        this._word = [];
        this.pattern = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Props propsId.
     * @member {number} propsId
     * @memberof Props
     * @instance
     */
    Props.prototype.propsId = 0;

    /**
     * Props propsType.
     * @member {string} propsType
     * @memberof Props
     * @instance
     */
    Props.prototype.propsType = "";

    /**
     * Props propsCategory.
     * @member {string} propsCategory
     * @memberof Props
     * @instance
     */
    Props.prototype.propsCategory = "";

    /**
     * Props leftNum.
     * @member {number} leftNum
     * @memberof Props
     * @instance
     */
    Props.prototype.leftNum = 0;

    /**
     * Props usedStatus.
     * @member {string} usedStatus
     * @memberof Props
     * @instance
     */
    Props.prototype.usedStatus = "";

    /**
     * Props num.
     * @member {number} num
     * @memberof Props
     * @instance
     */
    Props.prototype.num = 0;

    /**
     * Props endTime.
     * @member {string} endTime
     * @memberof Props
     * @instance
     */
    Props.prototype.endTime = "";

    /**
     * Props notice.
     * @member {string} notice
     * @memberof Props
     * @instance
     */
    Props.prototype.notice = "";

    /**
     * Props updateTime.
     * @member {number} updateTime
     * @memberof Props
     * @instance
     */
    Props.prototype.updateTime = 0;

    /**
     * Props openStatus.
     * @member {string} openStatus
     * @memberof Props
     * @instance
     */
    Props.prototype.openStatus = "";

    /**
     * Props expiringNotify.
     * @member {string} expiringNotify
     * @memberof Props
     * @instance
     */
    Props.prototype.expiringNotify = "";

    /**
     * Props expiredNotify.
     * @member {string} expiredNotify
     * @memberof Props
     * @instance
     */
    Props.prototype.expiredNotify = "";

    /**
     * Props title.
     * @member {string} title
     * @memberof Props
     * @instance
     */
    Props.prototype.title = "";

    /**
     * Props _word.
     * @member {Array.<string>} _word
     * @memberof Props
     * @instance
     */
    Props.prototype._word = $util.emptyArray;

    /**
     * Props pattern.
     * @member {Array.<string>} pattern
     * @memberof Props
     * @instance
     */
    Props.prototype.pattern = $util.emptyArray;

    /**
     * Creates a new Props instance using the specified properties.
     * @function create
     * @memberof Props
     * @static
     * @param {IProps=} [properties] Properties to set
     * @returns {Props} Props instance
     */
    Props.create = function create(properties) {
        return new Props(properties);
    };

    /**
     * Encodes the specified Props message. Does not implicitly {@link Props.verify|verify} messages.
     * @function encode
     * @memberof Props
     * @static
     * @param {IProps} message Props message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Props.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propsId);
        if (message.propsType != null && Object.hasOwnProperty.call(message, "propsType"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.propsType);
        if (message.propsCategory != null && Object.hasOwnProperty.call(message, "propsCategory"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.propsCategory);
        if (message.leftNum != null && Object.hasOwnProperty.call(message, "leftNum"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.leftNum);
        if (message.usedStatus != null && Object.hasOwnProperty.call(message, "usedStatus"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.usedStatus);
        if (message.num != null && Object.hasOwnProperty.call(message, "num"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.num);
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.endTime);
        if (message.notice != null && Object.hasOwnProperty.call(message, "notice"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.notice);
        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.updateTime);
        if (message.openStatus != null && Object.hasOwnProperty.call(message, "openStatus"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.openStatus);
        if (message.expiringNotify != null && Object.hasOwnProperty.call(message, "expiringNotify"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.expiringNotify);
        if (message.expiredNotify != null && Object.hasOwnProperty.call(message, "expiredNotify"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.expiredNotify);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.title);
        if (message._word != null && message._word.length)
            for (let i = 0; i < message._word.length; ++i)
                writer.uint32(/* id 14, wireType 2 =*/114).string(message._word[i]);
        if (message.pattern != null && message.pattern.length)
            for (let i = 0; i < message.pattern.length; ++i)
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.pattern[i]);
        return writer;
    };

    /**
     * Encodes the specified Props message, length delimited. Does not implicitly {@link Props.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Props
     * @static
     * @param {IProps} message Props message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Props.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Props message from the specified reader or buffer.
     * @function decode
     * @memberof Props
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Props} Props
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Props.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Props();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.propsId = reader.int32();
                    break;
                }
            case 2: {
                    message.propsType = reader.string();
                    break;
                }
            case 3: {
                    message.propsCategory = reader.string();
                    break;
                }
            case 4: {
                    message.leftNum = reader.int32();
                    break;
                }
            case 5: {
                    message.usedStatus = reader.string();
                    break;
                }
            case 6: {
                    message.num = reader.int32();
                    break;
                }
            case 7: {
                    message.endTime = reader.string();
                    break;
                }
            case 8: {
                    message.notice = reader.string();
                    break;
                }
            case 9: {
                    message.updateTime = reader.int32();
                    break;
                }
            case 10: {
                    message.openStatus = reader.string();
                    break;
                }
            case 11: {
                    message.expiringNotify = reader.string();
                    break;
                }
            case 12: {
                    message.expiredNotify = reader.string();
                    break;
                }
            case 13: {
                    message.title = reader.string();
                    break;
                }
            case 14: {
                    if (!(message._word && message._word.length))
                        message._word = [];
                    message._word.push(reader.string());
                    break;
                }
            case 15: {
                    if (!(message.pattern && message.pattern.length))
                        message.pattern = [];
                    message.pattern.push(reader.string());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Props message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Props
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Props} Props
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Props.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Props message.
     * @function verify
     * @memberof Props
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Props.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isInteger(message.propsId))
                return "propsId: integer expected";
        if (message.propsType != null && message.hasOwnProperty("propsType"))
            if (!$util.isString(message.propsType))
                return "propsType: string expected";
        if (message.propsCategory != null && message.hasOwnProperty("propsCategory"))
            if (!$util.isString(message.propsCategory))
                return "propsCategory: string expected";
        if (message.leftNum != null && message.hasOwnProperty("leftNum"))
            if (!$util.isInteger(message.leftNum))
                return "leftNum: integer expected";
        if (message.usedStatus != null && message.hasOwnProperty("usedStatus"))
            if (!$util.isString(message.usedStatus))
                return "usedStatus: string expected";
        if (message.num != null && message.hasOwnProperty("num"))
            if (!$util.isInteger(message.num))
                return "num: integer expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
        if (message.notice != null && message.hasOwnProperty("notice"))
            if (!$util.isString(message.notice))
                return "notice: string expected";
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            if (!$util.isInteger(message.updateTime))
                return "updateTime: integer expected";
        if (message.openStatus != null && message.hasOwnProperty("openStatus"))
            if (!$util.isString(message.openStatus))
                return "openStatus: string expected";
        if (message.expiringNotify != null && message.hasOwnProperty("expiringNotify"))
            if (!$util.isString(message.expiringNotify))
                return "expiringNotify: string expected";
        if (message.expiredNotify != null && message.hasOwnProperty("expiredNotify"))
            if (!$util.isString(message.expiredNotify))
                return "expiredNotify: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message._word != null && message.hasOwnProperty("_word")) {
            if (!Array.isArray(message._word))
                return "_word: array expected";
            for (let i = 0; i < message._word.length; ++i)
                if (!$util.isString(message._word[i]))
                    return "_word: string[] expected";
        }
        if (message.pattern != null && message.hasOwnProperty("pattern")) {
            if (!Array.isArray(message.pattern))
                return "pattern: array expected";
            for (let i = 0; i < message.pattern.length; ++i)
                if (!$util.isString(message.pattern[i]))
                    return "pattern: string[] expected";
        }
        return null;
    };

    /**
     * Creates a Props message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Props
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Props} Props
     */
    Props.fromObject = function fromObject(object) {
        if (object instanceof $root.Props)
            return object;
        let message = new $root.Props();
        if (object.propsId != null)
            message.propsId = object.propsId | 0;
        if (object.propsType != null)
            message.propsType = String(object.propsType);
        if (object.propsCategory != null)
            message.propsCategory = String(object.propsCategory);
        if (object.leftNum != null)
            message.leftNum = object.leftNum | 0;
        if (object.usedStatus != null)
            message.usedStatus = String(object.usedStatus);
        if (object.num != null)
            message.num = object.num | 0;
        if (object.endTime != null)
            message.endTime = String(object.endTime);
        if (object.notice != null)
            message.notice = String(object.notice);
        if (object.updateTime != null)
            message.updateTime = object.updateTime | 0;
        if (object.openStatus != null)
            message.openStatus = String(object.openStatus);
        if (object.expiringNotify != null)
            message.expiringNotify = String(object.expiringNotify);
        if (object.expiredNotify != null)
            message.expiredNotify = String(object.expiredNotify);
        if (object.title != null)
            message.title = String(object.title);
        if (object._word) {
            if (!Array.isArray(object._word))
                throw TypeError(".Props._word: array expected");
            message._word = [];
            for (let i = 0; i < object._word.length; ++i)
                message._word[i] = String(object._word[i]);
        }
        if (object.pattern) {
            if (!Array.isArray(object.pattern))
                throw TypeError(".Props.pattern: array expected");
            message.pattern = [];
            for (let i = 0; i < object.pattern.length; ++i)
                message.pattern[i] = String(object.pattern[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a Props message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Props
     * @static
     * @param {Props} message Props
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Props.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object._word = [];
            object.pattern = [];
        }
        if (options.defaults) {
            object.propsId = 0;
            object.propsType = "";
            object.propsCategory = "";
            object.leftNum = 0;
            object.usedStatus = "";
            object.num = 0;
            object.endTime = "";
            object.notice = "";
            object.updateTime = 0;
            object.openStatus = "";
            object.expiringNotify = "";
            object.expiredNotify = "";
            object.title = "";
        }
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            object.propsId = message.propsId;
        if (message.propsType != null && message.hasOwnProperty("propsType"))
            object.propsType = message.propsType;
        if (message.propsCategory != null && message.hasOwnProperty("propsCategory"))
            object.propsCategory = message.propsCategory;
        if (message.leftNum != null && message.hasOwnProperty("leftNum"))
            object.leftNum = message.leftNum;
        if (message.usedStatus != null && message.hasOwnProperty("usedStatus"))
            object.usedStatus = message.usedStatus;
        if (message.num != null && message.hasOwnProperty("num"))
            object.num = message.num;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            object.endTime = message.endTime;
        if (message.notice != null && message.hasOwnProperty("notice"))
            object.notice = message.notice;
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            object.updateTime = message.updateTime;
        if (message.openStatus != null && message.hasOwnProperty("openStatus"))
            object.openStatus = message.openStatus;
        if (message.expiringNotify != null && message.hasOwnProperty("expiringNotify"))
            object.expiringNotify = message.expiringNotify;
        if (message.expiredNotify != null && message.hasOwnProperty("expiredNotify"))
            object.expiredNotify = message.expiredNotify;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message._word && message._word.length) {
            object._word = [];
            for (let j = 0; j < message._word.length; ++j)
                object._word[j] = message._word[j];
        }
        if (message.pattern && message.pattern.length) {
            object.pattern = [];
            for (let j = 0; j < message.pattern.length; ++j)
                object.pattern[j] = message.pattern[j];
        }
        return object;
    };

    /**
     * Converts this Props to JSON.
     * @function toJSON
     * @memberof Props
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Props.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Props
     * @function getTypeUrl
     * @memberof Props
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Props.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Props";
    };

    return Props;
})();

export const NoticeMask = $root.NoticeMask = (() => {

    /**
     * Properties of a NoticeMask.
     * @exports INoticeMask
     * @interface INoticeMask
     * @property {number|null} [attrType] NoticeMask attrType
     * @property {string|null} [attrValue] NoticeMask attrValue
     */

    /**
     * Constructs a new NoticeMask.
     * @exports NoticeMask
     * @classdesc Represents a NoticeMask.
     * @implements INoticeMask
     * @constructor
     * @param {INoticeMask=} [properties] Properties to set
     */
    function NoticeMask(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NoticeMask attrType.
     * @member {number} attrType
     * @memberof NoticeMask
     * @instance
     */
    NoticeMask.prototype.attrType = 0;

    /**
     * NoticeMask attrValue.
     * @member {string} attrValue
     * @memberof NoticeMask
     * @instance
     */
    NoticeMask.prototype.attrValue = "";

    /**
     * Creates a new NoticeMask instance using the specified properties.
     * @function create
     * @memberof NoticeMask
     * @static
     * @param {INoticeMask=} [properties] Properties to set
     * @returns {NoticeMask} NoticeMask instance
     */
    NoticeMask.create = function create(properties) {
        return new NoticeMask(properties);
    };

    /**
     * Encodes the specified NoticeMask message. Does not implicitly {@link NoticeMask.verify|verify} messages.
     * @function encode
     * @memberof NoticeMask
     * @static
     * @param {INoticeMask} message NoticeMask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NoticeMask.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.attrType != null && Object.hasOwnProperty.call(message, "attrType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.attrType);
        if (message.attrValue != null && Object.hasOwnProperty.call(message, "attrValue"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.attrValue);
        return writer;
    };

    /**
     * Encodes the specified NoticeMask message, length delimited. Does not implicitly {@link NoticeMask.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NoticeMask
     * @static
     * @param {INoticeMask} message NoticeMask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NoticeMask.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NoticeMask message from the specified reader or buffer.
     * @function decode
     * @memberof NoticeMask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NoticeMask} NoticeMask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NoticeMask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NoticeMask();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.attrType = reader.int32();
                    break;
                }
            case 2: {
                    message.attrValue = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NoticeMask message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NoticeMask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NoticeMask} NoticeMask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NoticeMask.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NoticeMask message.
     * @function verify
     * @memberof NoticeMask
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NoticeMask.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.attrType != null && message.hasOwnProperty("attrType"))
            if (!$util.isInteger(message.attrType))
                return "attrType: integer expected";
        if (message.attrValue != null && message.hasOwnProperty("attrValue"))
            if (!$util.isString(message.attrValue))
                return "attrValue: string expected";
        return null;
    };

    /**
     * Creates a NoticeMask message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NoticeMask
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NoticeMask} NoticeMask
     */
    NoticeMask.fromObject = function fromObject(object) {
        if (object instanceof $root.NoticeMask)
            return object;
        let message = new $root.NoticeMask();
        if (object.attrType != null)
            message.attrType = object.attrType | 0;
        if (object.attrValue != null)
            message.attrValue = String(object.attrValue);
        return message;
    };

    /**
     * Creates a plain object from a NoticeMask message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NoticeMask
     * @static
     * @param {NoticeMask} message NoticeMask
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NoticeMask.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.attrType = 0;
            object.attrValue = "";
        }
        if (message.attrType != null && message.hasOwnProperty("attrType"))
            object.attrType = message.attrType;
        if (message.attrValue != null && message.hasOwnProperty("attrValue"))
            object.attrValue = message.attrValue;
        return object;
    };

    /**
     * Converts this NoticeMask to JSON.
     * @function toJSON
     * @memberof NoticeMask
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NoticeMask.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for NoticeMask
     * @function getTypeUrl
     * @memberof NoticeMask
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    NoticeMask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/NoticeMask";
    };

    return NoticeMask;
})();

export const ParrProps = $root.ParrProps = (() => {

    /**
     * Properties of a ParrProps.
     * @exports IParrProps
     * @interface IParrProps
     * @property {number|null} [portraitTime] ParrProps portraitTime
     * @property {ILevel|null} [level] ParrProps level
     * @property {Array.<IProps>|null} [props] ParrProps props
     */

    /**
     * Constructs a new ParrProps.
     * @exports ParrProps
     * @classdesc Represents a ParrProps.
     * @implements IParrProps
     * @constructor
     * @param {IParrProps=} [properties] Properties to set
     */
    function ParrProps(properties) {
        this.props = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ParrProps portraitTime.
     * @member {number} portraitTime
     * @memberof ParrProps
     * @instance
     */
    ParrProps.prototype.portraitTime = 0;

    /**
     * ParrProps level.
     * @member {ILevel|null|undefined} level
     * @memberof ParrProps
     * @instance
     */
    ParrProps.prototype.level = null;

    /**
     * ParrProps props.
     * @member {Array.<IProps>} props
     * @memberof ParrProps
     * @instance
     */
    ParrProps.prototype.props = $util.emptyArray;

    /**
     * Creates a new ParrProps instance using the specified properties.
     * @function create
     * @memberof ParrProps
     * @static
     * @param {IParrProps=} [properties] Properties to set
     * @returns {ParrProps} ParrProps instance
     */
    ParrProps.create = function create(properties) {
        return new ParrProps(properties);
    };

    /**
     * Encodes the specified ParrProps message. Does not implicitly {@link ParrProps.verify|verify} messages.
     * @function encode
     * @memberof ParrProps
     * @static
     * @param {IParrProps} message ParrProps message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParrProps.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.portraitTime != null && Object.hasOwnProperty.call(message, "portraitTime"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.portraitTime);
        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
            $root.Level.encode(message.level, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.props != null && message.props.length)
            for (let i = 0; i < message.props.length; ++i)
                $root.Props.encode(message.props[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ParrProps message, length delimited. Does not implicitly {@link ParrProps.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ParrProps
     * @static
     * @param {IParrProps} message ParrProps message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParrProps.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ParrProps message from the specified reader or buffer.
     * @function decode
     * @memberof ParrProps
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ParrProps} ParrProps
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParrProps.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ParrProps();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.portraitTime = reader.int32();
                    break;
                }
            case 2: {
                    message.level = $root.Level.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.Props.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ParrProps message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ParrProps
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ParrProps} ParrProps
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParrProps.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ParrProps message.
     * @function verify
     * @memberof ParrProps
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ParrProps.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.portraitTime != null && message.hasOwnProperty("portraitTime"))
            if (!$util.isInteger(message.portraitTime))
                return "portraitTime: integer expected";
        if (message.level != null && message.hasOwnProperty("level")) {
            let error = $root.Level.verify(message.level);
            if (error)
                return "level." + error;
        }
        if (message.props != null && message.hasOwnProperty("props")) {
            if (!Array.isArray(message.props))
                return "props: array expected";
            for (let i = 0; i < message.props.length; ++i) {
                let error = $root.Props.verify(message.props[i]);
                if (error)
                    return "props." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ParrProps message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ParrProps
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ParrProps} ParrProps
     */
    ParrProps.fromObject = function fromObject(object) {
        if (object instanceof $root.ParrProps)
            return object;
        let message = new $root.ParrProps();
        if (object.portraitTime != null)
            message.portraitTime = object.portraitTime | 0;
        if (object.level != null) {
            if (typeof object.level !== "object")
                throw TypeError(".ParrProps.level: object expected");
            message.level = $root.Level.fromObject(object.level);
        }
        if (object.props) {
            if (!Array.isArray(object.props))
                throw TypeError(".ParrProps.props: array expected");
            message.props = [];
            for (let i = 0; i < object.props.length; ++i) {
                if (typeof object.props[i] !== "object")
                    throw TypeError(".ParrProps.props: object expected");
                message.props[i] = $root.Props.fromObject(object.props[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ParrProps message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ParrProps
     * @static
     * @param {ParrProps} message ParrProps
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ParrProps.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.props = [];
        if (options.defaults) {
            object.portraitTime = 0;
            object.level = null;
        }
        if (message.portraitTime != null && message.hasOwnProperty("portraitTime"))
            object.portraitTime = message.portraitTime;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = $root.Level.toObject(message.level, options);
        if (message.props && message.props.length) {
            object.props = [];
            for (let j = 0; j < message.props.length; ++j)
                object.props[j] = $root.Props.toObject(message.props[j], options);
        }
        return object;
    };

    /**
     * Converts this ParrProps to JSON.
     * @function toJSON
     * @memberof ParrProps
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ParrProps.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ParrProps
     * @function getTypeUrl
     * @memberof ParrProps
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ParrProps.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ParrProps";
    };

    return ParrProps;
})();

export const ParrScores = $root.ParrScores = (() => {

    /**
     * Properties of a ParrScores.
     * @exports IParrScores
     * @interface IParrScores
     * @property {number|null} [scoresTotal] ParrScores scoresTotal
     * @property {number|null} [scoresFetch] ParrScores scoresFetch
     * @property {number|null} [scoresMoney] ParrScores scoresMoney
     * @property {number|null} [scoresOther] ParrScores scoresOther
     * @property {number|null} [updateTime] ParrScores updateTime
     * @property {number|null} [level] ParrScores level
     * @property {number|null} [limit] ParrScores limit
     * @property {number|Long|null} [iTotal] ParrScores iTotal
     * @property {number|Long|null} [iMoney] ParrScores iMoney
     * @property {number|Long|null} [iOther] ParrScores iOther
     */

    /**
     * Constructs a new ParrScores.
     * @exports ParrScores
     * @classdesc Represents a ParrScores.
     * @implements IParrScores
     * @constructor
     * @param {IParrScores=} [properties] Properties to set
     */
    function ParrScores(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ParrScores scoresTotal.
     * @member {number} scoresTotal
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.scoresTotal = 0;

    /**
     * ParrScores scoresFetch.
     * @member {number} scoresFetch
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.scoresFetch = 0;

    /**
     * ParrScores scoresMoney.
     * @member {number} scoresMoney
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.scoresMoney = 0;

    /**
     * ParrScores scoresOther.
     * @member {number} scoresOther
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.scoresOther = 0;

    /**
     * ParrScores updateTime.
     * @member {number} updateTime
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.updateTime = 0;

    /**
     * ParrScores level.
     * @member {number} level
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.level = 0;

    /**
     * ParrScores limit.
     * @member {number} limit
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.limit = 0;

    /**
     * ParrScores iTotal.
     * @member {number|Long} iTotal
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.iTotal = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ParrScores iMoney.
     * @member {number|Long} iMoney
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.iMoney = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ParrScores iOther.
     * @member {number|Long} iOther
     * @memberof ParrScores
     * @instance
     */
    ParrScores.prototype.iOther = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new ParrScores instance using the specified properties.
     * @function create
     * @memberof ParrScores
     * @static
     * @param {IParrScores=} [properties] Properties to set
     * @returns {ParrScores} ParrScores instance
     */
    ParrScores.create = function create(properties) {
        return new ParrScores(properties);
    };

    /**
     * Encodes the specified ParrScores message. Does not implicitly {@link ParrScores.verify|verify} messages.
     * @function encode
     * @memberof ParrScores
     * @static
     * @param {IParrScores} message ParrScores message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParrScores.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.scoresTotal != null && Object.hasOwnProperty.call(message, "scoresTotal"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scoresTotal);
        if (message.scoresFetch != null && Object.hasOwnProperty.call(message, "scoresFetch"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.scoresFetch);
        if (message.scoresMoney != null && Object.hasOwnProperty.call(message, "scoresMoney"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.scoresMoney);
        if (message.scoresOther != null && Object.hasOwnProperty.call(message, "scoresOther"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.scoresOther);
        if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.updateTime);
        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.level);
        if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.limit);
        if (message.iTotal != null && Object.hasOwnProperty.call(message, "iTotal"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.iTotal);
        if (message.iMoney != null && Object.hasOwnProperty.call(message, "iMoney"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.iMoney);
        if (message.iOther != null && Object.hasOwnProperty.call(message, "iOther"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.iOther);
        return writer;
    };

    /**
     * Encodes the specified ParrScores message, length delimited. Does not implicitly {@link ParrScores.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ParrScores
     * @static
     * @param {IParrScores} message ParrScores message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParrScores.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ParrScores message from the specified reader or buffer.
     * @function decode
     * @memberof ParrScores
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ParrScores} ParrScores
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParrScores.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ParrScores();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.scoresTotal = reader.int32();
                    break;
                }
            case 2: {
                    message.scoresFetch = reader.int32();
                    break;
                }
            case 3: {
                    message.scoresMoney = reader.int32();
                    break;
                }
            case 4: {
                    message.scoresOther = reader.int32();
                    break;
                }
            case 5: {
                    message.updateTime = reader.int32();
                    break;
                }
            case 6: {
                    message.level = reader.int32();
                    break;
                }
            case 7: {
                    message.limit = reader.int32();
                    break;
                }
            case 8: {
                    message.iTotal = reader.uint64();
                    break;
                }
            case 9: {
                    message.iMoney = reader.uint64();
                    break;
                }
            case 10: {
                    message.iOther = reader.uint64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ParrScores message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ParrScores
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ParrScores} ParrScores
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParrScores.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ParrScores message.
     * @function verify
     * @memberof ParrScores
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ParrScores.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.scoresTotal != null && message.hasOwnProperty("scoresTotal"))
            if (!$util.isInteger(message.scoresTotal))
                return "scoresTotal: integer expected";
        if (message.scoresFetch != null && message.hasOwnProperty("scoresFetch"))
            if (!$util.isInteger(message.scoresFetch))
                return "scoresFetch: integer expected";
        if (message.scoresMoney != null && message.hasOwnProperty("scoresMoney"))
            if (!$util.isInteger(message.scoresMoney))
                return "scoresMoney: integer expected";
        if (message.scoresOther != null && message.hasOwnProperty("scoresOther"))
            if (!$util.isInteger(message.scoresOther))
                return "scoresOther: integer expected";
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            if (!$util.isInteger(message.updateTime))
                return "updateTime: integer expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.limit != null && message.hasOwnProperty("limit"))
            if (!$util.isInteger(message.limit))
                return "limit: integer expected";
        if (message.iTotal != null && message.hasOwnProperty("iTotal"))
            if (!$util.isInteger(message.iTotal) && !(message.iTotal && $util.isInteger(message.iTotal.low) && $util.isInteger(message.iTotal.high)))
                return "iTotal: integer|Long expected";
        if (message.iMoney != null && message.hasOwnProperty("iMoney"))
            if (!$util.isInteger(message.iMoney) && !(message.iMoney && $util.isInteger(message.iMoney.low) && $util.isInteger(message.iMoney.high)))
                return "iMoney: integer|Long expected";
        if (message.iOther != null && message.hasOwnProperty("iOther"))
            if (!$util.isInteger(message.iOther) && !(message.iOther && $util.isInteger(message.iOther.low) && $util.isInteger(message.iOther.high)))
                return "iOther: integer|Long expected";
        return null;
    };

    /**
     * Creates a ParrScores message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ParrScores
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ParrScores} ParrScores
     */
    ParrScores.fromObject = function fromObject(object) {
        if (object instanceof $root.ParrScores)
            return object;
        let message = new $root.ParrScores();
        if (object.scoresTotal != null)
            message.scoresTotal = object.scoresTotal | 0;
        if (object.scoresFetch != null)
            message.scoresFetch = object.scoresFetch | 0;
        if (object.scoresMoney != null)
            message.scoresMoney = object.scoresMoney | 0;
        if (object.scoresOther != null)
            message.scoresOther = object.scoresOther | 0;
        if (object.updateTime != null)
            message.updateTime = object.updateTime | 0;
        if (object.level != null)
            message.level = object.level | 0;
        if (object.limit != null)
            message.limit = object.limit | 0;
        if (object.iTotal != null)
            if ($util.Long)
                (message.iTotal = $util.Long.fromValue(object.iTotal)).unsigned = true;
            else if (typeof object.iTotal === "string")
                message.iTotal = parseInt(object.iTotal, 10);
            else if (typeof object.iTotal === "number")
                message.iTotal = object.iTotal;
            else if (typeof object.iTotal === "object")
                message.iTotal = new $util.LongBits(object.iTotal.low >>> 0, object.iTotal.high >>> 0).toNumber(true);
        if (object.iMoney != null)
            if ($util.Long)
                (message.iMoney = $util.Long.fromValue(object.iMoney)).unsigned = true;
            else if (typeof object.iMoney === "string")
                message.iMoney = parseInt(object.iMoney, 10);
            else if (typeof object.iMoney === "number")
                message.iMoney = object.iMoney;
            else if (typeof object.iMoney === "object")
                message.iMoney = new $util.LongBits(object.iMoney.low >>> 0, object.iMoney.high >>> 0).toNumber(true);
        if (object.iOther != null)
            if ($util.Long)
                (message.iOther = $util.Long.fromValue(object.iOther)).unsigned = true;
            else if (typeof object.iOther === "string")
                message.iOther = parseInt(object.iOther, 10);
            else if (typeof object.iOther === "number")
                message.iOther = object.iOther;
            else if (typeof object.iOther === "object")
                message.iOther = new $util.LongBits(object.iOther.low >>> 0, object.iOther.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a ParrScores message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ParrScores
     * @static
     * @param {ParrScores} message ParrScores
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ParrScores.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.scoresTotal = 0;
            object.scoresFetch = 0;
            object.scoresMoney = 0;
            object.scoresOther = 0;
            object.updateTime = 0;
            object.level = 0;
            object.limit = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.iTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.iTotal = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.iMoney = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.iMoney = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.iOther = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.iOther = options.longs === String ? "0" : 0;
        }
        if (message.scoresTotal != null && message.hasOwnProperty("scoresTotal"))
            object.scoresTotal = message.scoresTotal;
        if (message.scoresFetch != null && message.hasOwnProperty("scoresFetch"))
            object.scoresFetch = message.scoresFetch;
        if (message.scoresMoney != null && message.hasOwnProperty("scoresMoney"))
            object.scoresMoney = message.scoresMoney;
        if (message.scoresOther != null && message.hasOwnProperty("scoresOther"))
            object.scoresOther = message.scoresOther;
        if (message.updateTime != null && message.hasOwnProperty("updateTime"))
            object.updateTime = message.updateTime;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.limit != null && message.hasOwnProperty("limit"))
            object.limit = message.limit;
        if (message.iTotal != null && message.hasOwnProperty("iTotal"))
            if (typeof message.iTotal === "number")
                object.iTotal = options.longs === String ? String(message.iTotal) : message.iTotal;
            else
                object.iTotal = options.longs === String ? $util.Long.prototype.toString.call(message.iTotal) : options.longs === Number ? new $util.LongBits(message.iTotal.low >>> 0, message.iTotal.high >>> 0).toNumber(true) : message.iTotal;
        if (message.iMoney != null && message.hasOwnProperty("iMoney"))
            if (typeof message.iMoney === "number")
                object.iMoney = options.longs === String ? String(message.iMoney) : message.iMoney;
            else
                object.iMoney = options.longs === String ? $util.Long.prototype.toString.call(message.iMoney) : options.longs === Number ? new $util.LongBits(message.iMoney.low >>> 0, message.iMoney.high >>> 0).toNumber(true) : message.iMoney;
        if (message.iOther != null && message.hasOwnProperty("iOther"))
            if (typeof message.iOther === "number")
                object.iOther = options.longs === String ? String(message.iOther) : message.iOther;
            else
                object.iOther = options.longs === String ? $util.Long.prototype.toString.call(message.iOther) : options.longs === Number ? new $util.LongBits(message.iOther.low >>> 0, message.iOther.high >>> 0).toNumber(true) : message.iOther;
        return object;
    };

    /**
     * Converts this ParrScores to JSON.
     * @function toJSON
     * @memberof ParrScores
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ParrScores.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ParrScores
     * @function getTypeUrl
     * @memberof ParrScores
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ParrScores.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ParrScores";
    };

    return ParrScores;
})();

export const Rpgoldicon = $root.Rpgoldicon = (() => {

    /**
     * Properties of a Rpgoldicon.
     * @exports IRpgoldicon
     * @interface IRpgoldicon
     * @property {string|null} [key] Rpgoldicon key
     * @property {string|null} [value] Rpgoldicon value
     */

    /**
     * Constructs a new Rpgoldicon.
     * @exports Rpgoldicon
     * @classdesc Represents a Rpgoldicon.
     * @implements IRpgoldicon
     * @constructor
     * @param {IRpgoldicon=} [properties] Properties to set
     */
    function Rpgoldicon(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Rpgoldicon key.
     * @member {string} key
     * @memberof Rpgoldicon
     * @instance
     */
    Rpgoldicon.prototype.key = "";

    /**
     * Rpgoldicon value.
     * @member {string} value
     * @memberof Rpgoldicon
     * @instance
     */
    Rpgoldicon.prototype.value = "";

    /**
     * Creates a new Rpgoldicon instance using the specified properties.
     * @function create
     * @memberof Rpgoldicon
     * @static
     * @param {IRpgoldicon=} [properties] Properties to set
     * @returns {Rpgoldicon} Rpgoldicon instance
     */
    Rpgoldicon.create = function create(properties) {
        return new Rpgoldicon(properties);
    };

    /**
     * Encodes the specified Rpgoldicon message. Does not implicitly {@link Rpgoldicon.verify|verify} messages.
     * @function encode
     * @memberof Rpgoldicon
     * @static
     * @param {IRpgoldicon} message Rpgoldicon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rpgoldicon.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
        return writer;
    };

    /**
     * Encodes the specified Rpgoldicon message, length delimited. Does not implicitly {@link Rpgoldicon.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Rpgoldicon
     * @static
     * @param {IRpgoldicon} message Rpgoldicon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rpgoldicon.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Rpgoldicon message from the specified reader or buffer.
     * @function decode
     * @memberof Rpgoldicon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Rpgoldicon} Rpgoldicon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rpgoldicon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Rpgoldicon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.key = reader.string();
                    break;
                }
            case 2: {
                    message.value = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Rpgoldicon message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Rpgoldicon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Rpgoldicon} Rpgoldicon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rpgoldicon.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Rpgoldicon message.
     * @function verify
     * @memberof Rpgoldicon
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Rpgoldicon.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!$util.isString(message.key))
                return "key: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value))
                return "value: string expected";
        return null;
    };

    /**
     * Creates a Rpgoldicon message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Rpgoldicon
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Rpgoldicon} Rpgoldicon
     */
    Rpgoldicon.fromObject = function fromObject(object) {
        if (object instanceof $root.Rpgoldicon)
            return object;
        let message = new $root.Rpgoldicon();
        if (object.key != null)
            message.key = String(object.key);
        if (object.value != null)
            message.value = String(object.value);
        return message;
    };

    /**
     * Creates a plain object from a Rpgoldicon message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Rpgoldicon
     * @static
     * @param {Rpgoldicon} message Rpgoldicon
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Rpgoldicon.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.key = "";
            object.value = "";
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = message.key;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this Rpgoldicon to JSON.
     * @function toJSON
     * @memberof Rpgoldicon
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Rpgoldicon.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Rpgoldicon
     * @function getTypeUrl
     * @memberof Rpgoldicon
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Rpgoldicon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Rpgoldicon";
    };

    return Rpgoldicon;
})();

export const TbmallMonthIcon = $root.TbmallMonthIcon = (() => {

    /**
     * Properties of a TbmallMonthIcon.
     * @exports ITbmallMonthIcon
     * @interface ITbmallMonthIcon
     * @property {string|null} [mon] TbmallMonthIcon mon
     * @property {string|null} [icon] TbmallMonthIcon icon
     */

    /**
     * Constructs a new TbmallMonthIcon.
     * @exports TbmallMonthIcon
     * @classdesc Represents a TbmallMonthIcon.
     * @implements ITbmallMonthIcon
     * @constructor
     * @param {ITbmallMonthIcon=} [properties] Properties to set
     */
    function TbmallMonthIcon(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TbmallMonthIcon mon.
     * @member {string} mon
     * @memberof TbmallMonthIcon
     * @instance
     */
    TbmallMonthIcon.prototype.mon = "";

    /**
     * TbmallMonthIcon icon.
     * @member {string} icon
     * @memberof TbmallMonthIcon
     * @instance
     */
    TbmallMonthIcon.prototype.icon = "";

    /**
     * Creates a new TbmallMonthIcon instance using the specified properties.
     * @function create
     * @memberof TbmallMonthIcon
     * @static
     * @param {ITbmallMonthIcon=} [properties] Properties to set
     * @returns {TbmallMonthIcon} TbmallMonthIcon instance
     */
    TbmallMonthIcon.create = function create(properties) {
        return new TbmallMonthIcon(properties);
    };

    /**
     * Encodes the specified TbmallMonthIcon message. Does not implicitly {@link TbmallMonthIcon.verify|verify} messages.
     * @function encode
     * @memberof TbmallMonthIcon
     * @static
     * @param {ITbmallMonthIcon} message TbmallMonthIcon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TbmallMonthIcon.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mon != null && Object.hasOwnProperty.call(message, "mon"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.mon);
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.icon);
        return writer;
    };

    /**
     * Encodes the specified TbmallMonthIcon message, length delimited. Does not implicitly {@link TbmallMonthIcon.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TbmallMonthIcon
     * @static
     * @param {ITbmallMonthIcon} message TbmallMonthIcon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TbmallMonthIcon.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TbmallMonthIcon message from the specified reader or buffer.
     * @function decode
     * @memberof TbmallMonthIcon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TbmallMonthIcon} TbmallMonthIcon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TbmallMonthIcon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TbmallMonthIcon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.mon = reader.string();
                    break;
                }
            case 2: {
                    message.icon = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TbmallMonthIcon message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TbmallMonthIcon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TbmallMonthIcon} TbmallMonthIcon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TbmallMonthIcon.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TbmallMonthIcon message.
     * @function verify
     * @memberof TbmallMonthIcon
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TbmallMonthIcon.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mon != null && message.hasOwnProperty("mon"))
            if (!$util.isString(message.mon))
                return "mon: string expected";
        if (message.icon != null && message.hasOwnProperty("icon"))
            if (!$util.isString(message.icon))
                return "icon: string expected";
        return null;
    };

    /**
     * Creates a TbmallMonthIcon message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TbmallMonthIcon
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TbmallMonthIcon} TbmallMonthIcon
     */
    TbmallMonthIcon.fromObject = function fromObject(object) {
        if (object instanceof $root.TbmallMonthIcon)
            return object;
        let message = new $root.TbmallMonthIcon();
        if (object.mon != null)
            message.mon = String(object.mon);
        if (object.icon != null)
            message.icon = String(object.icon);
        return message;
    };

    /**
     * Creates a plain object from a TbmallMonthIcon message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TbmallMonthIcon
     * @static
     * @param {TbmallMonthIcon} message TbmallMonthIcon
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TbmallMonthIcon.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.mon = "";
            object.icon = "";
        }
        if (message.mon != null && message.hasOwnProperty("mon"))
            object.mon = message.mon;
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = message.icon;
        return object;
    };

    /**
     * Converts this TbmallMonthIcon to JSON.
     * @function toJSON
     * @memberof TbmallMonthIcon
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TbmallMonthIcon.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TbmallMonthIcon
     * @function getTypeUrl
     * @memberof TbmallMonthIcon
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TbmallMonthIcon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TbmallMonthIcon";
    };

    return TbmallMonthIcon;
})();

export const WapRn = $root.WapRn = (() => {

    /**
     * Properties of a WapRn.
     * @exports IWapRn
     * @interface IWapRn
     * @property {number|null} [frsrn] WapRn frsrn
     * @property {number|null} [pbrn] WapRn pbrn
     */

    /**
     * Constructs a new WapRn.
     * @exports WapRn
     * @classdesc Represents a WapRn.
     * @implements IWapRn
     * @constructor
     * @param {IWapRn=} [properties] Properties to set
     */
    function WapRn(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WapRn frsrn.
     * @member {number} frsrn
     * @memberof WapRn
     * @instance
     */
    WapRn.prototype.frsrn = 0;

    /**
     * WapRn pbrn.
     * @member {number} pbrn
     * @memberof WapRn
     * @instance
     */
    WapRn.prototype.pbrn = 0;

    /**
     * Creates a new WapRn instance using the specified properties.
     * @function create
     * @memberof WapRn
     * @static
     * @param {IWapRn=} [properties] Properties to set
     * @returns {WapRn} WapRn instance
     */
    WapRn.create = function create(properties) {
        return new WapRn(properties);
    };

    /**
     * Encodes the specified WapRn message. Does not implicitly {@link WapRn.verify|verify} messages.
     * @function encode
     * @memberof WapRn
     * @static
     * @param {IWapRn} message WapRn message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WapRn.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.frsrn != null && Object.hasOwnProperty.call(message, "frsrn"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.frsrn);
        if (message.pbrn != null && Object.hasOwnProperty.call(message, "pbrn"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pbrn);
        return writer;
    };

    /**
     * Encodes the specified WapRn message, length delimited. Does not implicitly {@link WapRn.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WapRn
     * @static
     * @param {IWapRn} message WapRn message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WapRn.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WapRn message from the specified reader or buffer.
     * @function decode
     * @memberof WapRn
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WapRn} WapRn
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WapRn.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WapRn();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.frsrn = reader.int32();
                    break;
                }
            case 2: {
                    message.pbrn = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WapRn message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WapRn
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WapRn} WapRn
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WapRn.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WapRn message.
     * @function verify
     * @memberof WapRn
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WapRn.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.frsrn != null && message.hasOwnProperty("frsrn"))
            if (!$util.isInteger(message.frsrn))
                return "frsrn: integer expected";
        if (message.pbrn != null && message.hasOwnProperty("pbrn"))
            if (!$util.isInteger(message.pbrn))
                return "pbrn: integer expected";
        return null;
    };

    /**
     * Creates a WapRn message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WapRn
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WapRn} WapRn
     */
    WapRn.fromObject = function fromObject(object) {
        if (object instanceof $root.WapRn)
            return object;
        let message = new $root.WapRn();
        if (object.frsrn != null)
            message.frsrn = object.frsrn | 0;
        if (object.pbrn != null)
            message.pbrn = object.pbrn | 0;
        return message;
    };

    /**
     * Creates a plain object from a WapRn message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WapRn
     * @static
     * @param {WapRn} message WapRn
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WapRn.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.frsrn = 0;
            object.pbrn = 0;
        }
        if (message.frsrn != null && message.hasOwnProperty("frsrn"))
            object.frsrn = message.frsrn;
        if (message.pbrn != null && message.hasOwnProperty("pbrn"))
            object.pbrn = message.pbrn;
        return object;
    };

    /**
     * Converts this WapRn to JSON.
     * @function toJSON
     * @memberof WapRn
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WapRn.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for WapRn
     * @function getTypeUrl
     * @memberof WapRn
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    WapRn.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/WapRn";
    };

    return WapRn;
})();

export const NovelFansInfo = $root.NovelFansInfo = (() => {

    /**
     * Properties of a NovelFansInfo.
     * @exports INovelFansInfo
     * @interface INovelFansInfo
     * @property {number|null} [level] NovelFansInfo level
     * @property {string|null} [levelName] NovelFansInfo levelName
     * @property {string|null} [levelIcon] NovelFansInfo levelIcon
     */

    /**
     * Constructs a new NovelFansInfo.
     * @exports NovelFansInfo
     * @classdesc Represents a NovelFansInfo.
     * @implements INovelFansInfo
     * @constructor
     * @param {INovelFansInfo=} [properties] Properties to set
     */
    function NovelFansInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NovelFansInfo level.
     * @member {number} level
     * @memberof NovelFansInfo
     * @instance
     */
    NovelFansInfo.prototype.level = 0;

    /**
     * NovelFansInfo levelName.
     * @member {string} levelName
     * @memberof NovelFansInfo
     * @instance
     */
    NovelFansInfo.prototype.levelName = "";

    /**
     * NovelFansInfo levelIcon.
     * @member {string} levelIcon
     * @memberof NovelFansInfo
     * @instance
     */
    NovelFansInfo.prototype.levelIcon = "";

    /**
     * Creates a new NovelFansInfo instance using the specified properties.
     * @function create
     * @memberof NovelFansInfo
     * @static
     * @param {INovelFansInfo=} [properties] Properties to set
     * @returns {NovelFansInfo} NovelFansInfo instance
     */
    NovelFansInfo.create = function create(properties) {
        return new NovelFansInfo(properties);
    };

    /**
     * Encodes the specified NovelFansInfo message. Does not implicitly {@link NovelFansInfo.verify|verify} messages.
     * @function encode
     * @memberof NovelFansInfo
     * @static
     * @param {INovelFansInfo} message NovelFansInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NovelFansInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
        if (message.levelName != null && Object.hasOwnProperty.call(message, "levelName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.levelName);
        if (message.levelIcon != null && Object.hasOwnProperty.call(message, "levelIcon"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.levelIcon);
        return writer;
    };

    /**
     * Encodes the specified NovelFansInfo message, length delimited. Does not implicitly {@link NovelFansInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NovelFansInfo
     * @static
     * @param {INovelFansInfo} message NovelFansInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NovelFansInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NovelFansInfo message from the specified reader or buffer.
     * @function decode
     * @memberof NovelFansInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NovelFansInfo} NovelFansInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NovelFansInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NovelFansInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.level = reader.int32();
                    break;
                }
            case 2: {
                    message.levelName = reader.string();
                    break;
                }
            case 3: {
                    message.levelIcon = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NovelFansInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NovelFansInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NovelFansInfo} NovelFansInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NovelFansInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NovelFansInfo message.
     * @function verify
     * @memberof NovelFansInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NovelFansInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.levelName != null && message.hasOwnProperty("levelName"))
            if (!$util.isString(message.levelName))
                return "levelName: string expected";
        if (message.levelIcon != null && message.hasOwnProperty("levelIcon"))
            if (!$util.isString(message.levelIcon))
                return "levelIcon: string expected";
        return null;
    };

    /**
     * Creates a NovelFansInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NovelFansInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NovelFansInfo} NovelFansInfo
     */
    NovelFansInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.NovelFansInfo)
            return object;
        let message = new $root.NovelFansInfo();
        if (object.level != null)
            message.level = object.level | 0;
        if (object.levelName != null)
            message.levelName = String(object.levelName);
        if (object.levelIcon != null)
            message.levelIcon = String(object.levelIcon);
        return message;
    };

    /**
     * Creates a plain object from a NovelFansInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NovelFansInfo
     * @static
     * @param {NovelFansInfo} message NovelFansInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NovelFansInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.level = 0;
            object.levelName = "";
            object.levelIcon = "";
        }
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.levelName != null && message.hasOwnProperty("levelName"))
            object.levelName = message.levelName;
        if (message.levelIcon != null && message.hasOwnProperty("levelIcon"))
            object.levelIcon = message.levelIcon;
        return object;
    };

    /**
     * Converts this NovelFansInfo to JSON.
     * @function toJSON
     * @memberof NovelFansInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NovelFansInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for NovelFansInfo
     * @function getTypeUrl
     * @memberof NovelFansInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    NovelFansInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/NovelFansInfo";
    };

    return NovelFansInfo;
})();

export const PayMemberInfo = $root.PayMemberInfo = (() => {

    /**
     * Properties of a PayMemberInfo.
     * @exports IPayMemberInfo
     * @interface IPayMemberInfo
     * @property {number|null} [propsId] PayMemberInfo propsId
     * @property {number|null} [endTime] PayMemberInfo endTime
     * @property {string|null} [url] PayMemberInfo url
     * @property {string|null} [expireRemind] PayMemberInfo expireRemind
     * @property {string|null} [picUrl] PayMemberInfo picUrl
     */

    /**
     * Constructs a new PayMemberInfo.
     * @exports PayMemberInfo
     * @classdesc Represents a PayMemberInfo.
     * @implements IPayMemberInfo
     * @constructor
     * @param {IPayMemberInfo=} [properties] Properties to set
     */
    function PayMemberInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PayMemberInfo propsId.
     * @member {number} propsId
     * @memberof PayMemberInfo
     * @instance
     */
    PayMemberInfo.prototype.propsId = 0;

    /**
     * PayMemberInfo endTime.
     * @member {number} endTime
     * @memberof PayMemberInfo
     * @instance
     */
    PayMemberInfo.prototype.endTime = 0;

    /**
     * PayMemberInfo url.
     * @member {string} url
     * @memberof PayMemberInfo
     * @instance
     */
    PayMemberInfo.prototype.url = "";

    /**
     * PayMemberInfo expireRemind.
     * @member {string} expireRemind
     * @memberof PayMemberInfo
     * @instance
     */
    PayMemberInfo.prototype.expireRemind = "";

    /**
     * PayMemberInfo picUrl.
     * @member {string} picUrl
     * @memberof PayMemberInfo
     * @instance
     */
    PayMemberInfo.prototype.picUrl = "";

    /**
     * Creates a new PayMemberInfo instance using the specified properties.
     * @function create
     * @memberof PayMemberInfo
     * @static
     * @param {IPayMemberInfo=} [properties] Properties to set
     * @returns {PayMemberInfo} PayMemberInfo instance
     */
    PayMemberInfo.create = function create(properties) {
        return new PayMemberInfo(properties);
    };

    /**
     * Encodes the specified PayMemberInfo message. Does not implicitly {@link PayMemberInfo.verify|verify} messages.
     * @function encode
     * @memberof PayMemberInfo
     * @static
     * @param {IPayMemberInfo} message PayMemberInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PayMemberInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propsId);
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endTime);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
        if (message.expireRemind != null && Object.hasOwnProperty.call(message, "expireRemind"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.expireRemind);
        if (message.picUrl != null && Object.hasOwnProperty.call(message, "picUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.picUrl);
        return writer;
    };

    /**
     * Encodes the specified PayMemberInfo message, length delimited. Does not implicitly {@link PayMemberInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PayMemberInfo
     * @static
     * @param {IPayMemberInfo} message PayMemberInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PayMemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PayMemberInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PayMemberInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PayMemberInfo} PayMemberInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PayMemberInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PayMemberInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.propsId = reader.int32();
                    break;
                }
            case 2: {
                    message.endTime = reader.int32();
                    break;
                }
            case 3: {
                    message.url = reader.string();
                    break;
                }
            case 4: {
                    message.expireRemind = reader.string();
                    break;
                }
            case 5: {
                    message.picUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PayMemberInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PayMemberInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PayMemberInfo} PayMemberInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PayMemberInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PayMemberInfo message.
     * @function verify
     * @memberof PayMemberInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PayMemberInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isInteger(message.propsId))
                return "propsId: integer expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime))
                return "endTime: integer expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.expireRemind != null && message.hasOwnProperty("expireRemind"))
            if (!$util.isString(message.expireRemind))
                return "expireRemind: string expected";
        if (message.picUrl != null && message.hasOwnProperty("picUrl"))
            if (!$util.isString(message.picUrl))
                return "picUrl: string expected";
        return null;
    };

    /**
     * Creates a PayMemberInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PayMemberInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PayMemberInfo} PayMemberInfo
     */
    PayMemberInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.PayMemberInfo)
            return object;
        let message = new $root.PayMemberInfo();
        if (object.propsId != null)
            message.propsId = object.propsId | 0;
        if (object.endTime != null)
            message.endTime = object.endTime | 0;
        if (object.url != null)
            message.url = String(object.url);
        if (object.expireRemind != null)
            message.expireRemind = String(object.expireRemind);
        if (object.picUrl != null)
            message.picUrl = String(object.picUrl);
        return message;
    };

    /**
     * Creates a plain object from a PayMemberInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PayMemberInfo
     * @static
     * @param {PayMemberInfo} message PayMemberInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PayMemberInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.propsId = 0;
            object.endTime = 0;
            object.url = "";
            object.expireRemind = "";
            object.picUrl = "";
        }
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            object.propsId = message.propsId;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            object.endTime = message.endTime;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.expireRemind != null && message.hasOwnProperty("expireRemind"))
            object.expireRemind = message.expireRemind;
        if (message.picUrl != null && message.hasOwnProperty("picUrl"))
            object.picUrl = message.picUrl;
        return object;
    };

    /**
     * Converts this PayMemberInfo to JSON.
     * @function toJSON
     * @memberof PayMemberInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PayMemberInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PayMemberInfo
     * @function getTypeUrl
     * @memberof PayMemberInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PayMemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PayMemberInfo";
    };

    return PayMemberInfo;
})();

export const Pendant = $root.Pendant = (() => {

    /**
     * Properties of a Pendant.
     * @exports IPendant
     * @interface IPendant
     * @property {number|Long|null} [propsId] Pendant propsId
     * @property {string|null} [imgUrl] Pendant imgUrl
     * @property {string|null} [dynamicUrl] Pendant dynamicUrl
     * @property {string|null} [jumpUrl] Pendant jumpUrl
     */

    /**
     * Constructs a new Pendant.
     * @exports Pendant
     * @classdesc Represents a Pendant.
     * @implements IPendant
     * @constructor
     * @param {IPendant=} [properties] Properties to set
     */
    function Pendant(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Pendant propsId.
     * @member {number|Long} propsId
     * @memberof Pendant
     * @instance
     */
    Pendant.prototype.propsId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Pendant imgUrl.
     * @member {string} imgUrl
     * @memberof Pendant
     * @instance
     */
    Pendant.prototype.imgUrl = "";

    /**
     * Pendant dynamicUrl.
     * @member {string} dynamicUrl
     * @memberof Pendant
     * @instance
     */
    Pendant.prototype.dynamicUrl = "";

    /**
     * Pendant jumpUrl.
     * @member {string} jumpUrl
     * @memberof Pendant
     * @instance
     */
    Pendant.prototype.jumpUrl = "";

    /**
     * Creates a new Pendant instance using the specified properties.
     * @function create
     * @memberof Pendant
     * @static
     * @param {IPendant=} [properties] Properties to set
     * @returns {Pendant} Pendant instance
     */
    Pendant.create = function create(properties) {
        return new Pendant(properties);
    };

    /**
     * Encodes the specified Pendant message. Does not implicitly {@link Pendant.verify|verify} messages.
     * @function encode
     * @memberof Pendant
     * @static
     * @param {IPendant} message Pendant message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Pendant.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.propsId);
        if (message.imgUrl != null && Object.hasOwnProperty.call(message, "imgUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.imgUrl);
        if (message.dynamicUrl != null && Object.hasOwnProperty.call(message, "dynamicUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dynamicUrl);
        if (message.jumpUrl != null && Object.hasOwnProperty.call(message, "jumpUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.jumpUrl);
        return writer;
    };

    /**
     * Encodes the specified Pendant message, length delimited. Does not implicitly {@link Pendant.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Pendant
     * @static
     * @param {IPendant} message Pendant message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Pendant.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Pendant message from the specified reader or buffer.
     * @function decode
     * @memberof Pendant
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Pendant} Pendant
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Pendant.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Pendant();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.propsId = reader.uint64();
                    break;
                }
            case 2: {
                    message.imgUrl = reader.string();
                    break;
                }
            case 3: {
                    message.dynamicUrl = reader.string();
                    break;
                }
            case 4: {
                    message.jumpUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Pendant message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Pendant
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Pendant} Pendant
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Pendant.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Pendant message.
     * @function verify
     * @memberof Pendant
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Pendant.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isInteger(message.propsId) && !(message.propsId && $util.isInteger(message.propsId.low) && $util.isInteger(message.propsId.high)))
                return "propsId: integer|Long expected";
        if (message.imgUrl != null && message.hasOwnProperty("imgUrl"))
            if (!$util.isString(message.imgUrl))
                return "imgUrl: string expected";
        if (message.dynamicUrl != null && message.hasOwnProperty("dynamicUrl"))
            if (!$util.isString(message.dynamicUrl))
                return "dynamicUrl: string expected";
        if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
            if (!$util.isString(message.jumpUrl))
                return "jumpUrl: string expected";
        return null;
    };

    /**
     * Creates a Pendant message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Pendant
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Pendant} Pendant
     */
    Pendant.fromObject = function fromObject(object) {
        if (object instanceof $root.Pendant)
            return object;
        let message = new $root.Pendant();
        if (object.propsId != null)
            if ($util.Long)
                (message.propsId = $util.Long.fromValue(object.propsId)).unsigned = true;
            else if (typeof object.propsId === "string")
                message.propsId = parseInt(object.propsId, 10);
            else if (typeof object.propsId === "number")
                message.propsId = object.propsId;
            else if (typeof object.propsId === "object")
                message.propsId = new $util.LongBits(object.propsId.low >>> 0, object.propsId.high >>> 0).toNumber(true);
        if (object.imgUrl != null)
            message.imgUrl = String(object.imgUrl);
        if (object.dynamicUrl != null)
            message.dynamicUrl = String(object.dynamicUrl);
        if (object.jumpUrl != null)
            message.jumpUrl = String(object.jumpUrl);
        return message;
    };

    /**
     * Creates a plain object from a Pendant message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Pendant
     * @static
     * @param {Pendant} message Pendant
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Pendant.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.propsId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.propsId = options.longs === String ? "0" : 0;
            object.imgUrl = "";
            object.dynamicUrl = "";
            object.jumpUrl = "";
        }
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (typeof message.propsId === "number")
                object.propsId = options.longs === String ? String(message.propsId) : message.propsId;
            else
                object.propsId = options.longs === String ? $util.Long.prototype.toString.call(message.propsId) : options.longs === Number ? new $util.LongBits(message.propsId.low >>> 0, message.propsId.high >>> 0).toNumber(true) : message.propsId;
        if (message.imgUrl != null && message.hasOwnProperty("imgUrl"))
            object.imgUrl = message.imgUrl;
        if (message.dynamicUrl != null && message.hasOwnProperty("dynamicUrl"))
            object.dynamicUrl = message.dynamicUrl;
        if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
            object.jumpUrl = message.jumpUrl;
        return object;
    };

    /**
     * Converts this Pendant to JSON.
     * @function toJSON
     * @memberof Pendant
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Pendant.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Pendant
     * @function getTypeUrl
     * @memberof Pendant
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Pendant.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Pendant";
    };

    return Pendant;
})();

export const PrivSets = $root.PrivSets = (() => {

    /**
     * Properties of a PrivSets.
     * @exports IPrivSets
     * @interface IPrivSets
     * @property {number|null} [location] PrivSets location
     * @property {number|null} [like] PrivSets like
     * @property {number|null} [group] PrivSets group
     * @property {number|null} [post] PrivSets post
     * @property {number|null} [friend] PrivSets friend
     * @property {number|null} [live] PrivSets live
     * @property {number|null} [reply] PrivSets reply
     * @property {number|null} [bazhuShowInside] PrivSets bazhuShowInside
     * @property {number|null} [bazhuShowOutside] PrivSets bazhuShowOutside
     */

    /**
     * Constructs a new PrivSets.
     * @exports PrivSets
     * @classdesc Represents a PrivSets.
     * @implements IPrivSets
     * @constructor
     * @param {IPrivSets=} [properties] Properties to set
     */
    function PrivSets(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PrivSets location.
     * @member {number} location
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.location = 0;

    /**
     * PrivSets like.
     * @member {number} like
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.like = 0;

    /**
     * PrivSets group.
     * @member {number} group
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.group = 0;

    /**
     * PrivSets post.
     * @member {number} post
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.post = 0;

    /**
     * PrivSets friend.
     * @member {number} friend
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.friend = 0;

    /**
     * PrivSets live.
     * @member {number} live
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.live = 0;

    /**
     * PrivSets reply.
     * @member {number} reply
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.reply = 0;

    /**
     * PrivSets bazhuShowInside.
     * @member {number} bazhuShowInside
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.bazhuShowInside = 0;

    /**
     * PrivSets bazhuShowOutside.
     * @member {number} bazhuShowOutside
     * @memberof PrivSets
     * @instance
     */
    PrivSets.prototype.bazhuShowOutside = 0;

    /**
     * Creates a new PrivSets instance using the specified properties.
     * @function create
     * @memberof PrivSets
     * @static
     * @param {IPrivSets=} [properties] Properties to set
     * @returns {PrivSets} PrivSets instance
     */
    PrivSets.create = function create(properties) {
        return new PrivSets(properties);
    };

    /**
     * Encodes the specified PrivSets message. Does not implicitly {@link PrivSets.verify|verify} messages.
     * @function encode
     * @memberof PrivSets
     * @static
     * @param {IPrivSets} message PrivSets message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrivSets.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.location != null && Object.hasOwnProperty.call(message, "location"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.location);
        if (message.like != null && Object.hasOwnProperty.call(message, "like"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.like);
        if (message.group != null && Object.hasOwnProperty.call(message, "group"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.group);
        if (message.post != null && Object.hasOwnProperty.call(message, "post"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.post);
        if (message.friend != null && Object.hasOwnProperty.call(message, "friend"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.friend);
        if (message.live != null && Object.hasOwnProperty.call(message, "live"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.live);
        if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.reply);
        if (message.bazhuShowInside != null && Object.hasOwnProperty.call(message, "bazhuShowInside"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.bazhuShowInside);
        if (message.bazhuShowOutside != null && Object.hasOwnProperty.call(message, "bazhuShowOutside"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.bazhuShowOutside);
        return writer;
    };

    /**
     * Encodes the specified PrivSets message, length delimited. Does not implicitly {@link PrivSets.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PrivSets
     * @static
     * @param {IPrivSets} message PrivSets message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrivSets.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PrivSets message from the specified reader or buffer.
     * @function decode
     * @memberof PrivSets
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PrivSets} PrivSets
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrivSets.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PrivSets();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.location = reader.int32();
                    break;
                }
            case 2: {
                    message.like = reader.int32();
                    break;
                }
            case 3: {
                    message.group = reader.int32();
                    break;
                }
            case 4: {
                    message.post = reader.int32();
                    break;
                }
            case 5: {
                    message.friend = reader.int32();
                    break;
                }
            case 6: {
                    message.live = reader.int32();
                    break;
                }
            case 7: {
                    message.reply = reader.int32();
                    break;
                }
            case 8: {
                    message.bazhuShowInside = reader.int32();
                    break;
                }
            case 9: {
                    message.bazhuShowOutside = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PrivSets message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PrivSets
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PrivSets} PrivSets
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrivSets.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PrivSets message.
     * @function verify
     * @memberof PrivSets
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PrivSets.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.location != null && message.hasOwnProperty("location"))
            if (!$util.isInteger(message.location))
                return "location: integer expected";
        if (message.like != null && message.hasOwnProperty("like"))
            if (!$util.isInteger(message.like))
                return "like: integer expected";
        if (message.group != null && message.hasOwnProperty("group"))
            if (!$util.isInteger(message.group))
                return "group: integer expected";
        if (message.post != null && message.hasOwnProperty("post"))
            if (!$util.isInteger(message.post))
                return "post: integer expected";
        if (message.friend != null && message.hasOwnProperty("friend"))
            if (!$util.isInteger(message.friend))
                return "friend: integer expected";
        if (message.live != null && message.hasOwnProperty("live"))
            if (!$util.isInteger(message.live))
                return "live: integer expected";
        if (message.reply != null && message.hasOwnProperty("reply"))
            if (!$util.isInteger(message.reply))
                return "reply: integer expected";
        if (message.bazhuShowInside != null && message.hasOwnProperty("bazhuShowInside"))
            if (!$util.isInteger(message.bazhuShowInside))
                return "bazhuShowInside: integer expected";
        if (message.bazhuShowOutside != null && message.hasOwnProperty("bazhuShowOutside"))
            if (!$util.isInteger(message.bazhuShowOutside))
                return "bazhuShowOutside: integer expected";
        return null;
    };

    /**
     * Creates a PrivSets message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PrivSets
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PrivSets} PrivSets
     */
    PrivSets.fromObject = function fromObject(object) {
        if (object instanceof $root.PrivSets)
            return object;
        let message = new $root.PrivSets();
        if (object.location != null)
            message.location = object.location | 0;
        if (object.like != null)
            message.like = object.like | 0;
        if (object.group != null)
            message.group = object.group | 0;
        if (object.post != null)
            message.post = object.post | 0;
        if (object.friend != null)
            message.friend = object.friend | 0;
        if (object.live != null)
            message.live = object.live | 0;
        if (object.reply != null)
            message.reply = object.reply | 0;
        if (object.bazhuShowInside != null)
            message.bazhuShowInside = object.bazhuShowInside | 0;
        if (object.bazhuShowOutside != null)
            message.bazhuShowOutside = object.bazhuShowOutside | 0;
        return message;
    };

    /**
     * Creates a plain object from a PrivSets message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PrivSets
     * @static
     * @param {PrivSets} message PrivSets
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PrivSets.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.location = 0;
            object.like = 0;
            object.group = 0;
            object.post = 0;
            object.friend = 0;
            object.live = 0;
            object.reply = 0;
            object.bazhuShowInside = 0;
            object.bazhuShowOutside = 0;
        }
        if (message.location != null && message.hasOwnProperty("location"))
            object.location = message.location;
        if (message.like != null && message.hasOwnProperty("like"))
            object.like = message.like;
        if (message.group != null && message.hasOwnProperty("group"))
            object.group = message.group;
        if (message.post != null && message.hasOwnProperty("post"))
            object.post = message.post;
        if (message.friend != null && message.hasOwnProperty("friend"))
            object.friend = message.friend;
        if (message.live != null && message.hasOwnProperty("live"))
            object.live = message.live;
        if (message.reply != null && message.hasOwnProperty("reply"))
            object.reply = message.reply;
        if (message.bazhuShowInside != null && message.hasOwnProperty("bazhuShowInside"))
            object.bazhuShowInside = message.bazhuShowInside;
        if (message.bazhuShowOutside != null && message.hasOwnProperty("bazhuShowOutside"))
            object.bazhuShowOutside = message.bazhuShowOutside;
        return object;
    };

    /**
     * Converts this PrivSets to JSON.
     * @function toJSON
     * @memberof PrivSets
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PrivSets.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PrivSets
     * @function getTypeUrl
     * @memberof PrivSets
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PrivSets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PrivSets";
    };

    return PrivSets;
})();

export const ShakeAdSwitch = $root.ShakeAdSwitch = (() => {

    /**
     * Properties of a ShakeAdSwitch.
     * @exports IShakeAdSwitch
     * @interface IShakeAdSwitch
     * @property {number|null} [isShow] ShakeAdSwitch isShow
     * @property {string|null} [title] ShakeAdSwitch title
     * @property {string|null} [desc] ShakeAdSwitch desc
     */

    /**
     * Constructs a new ShakeAdSwitch.
     * @exports ShakeAdSwitch
     * @classdesc Represents a ShakeAdSwitch.
     * @implements IShakeAdSwitch
     * @constructor
     * @param {IShakeAdSwitch=} [properties] Properties to set
     */
    function ShakeAdSwitch(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ShakeAdSwitch isShow.
     * @member {number} isShow
     * @memberof ShakeAdSwitch
     * @instance
     */
    ShakeAdSwitch.prototype.isShow = 0;

    /**
     * ShakeAdSwitch title.
     * @member {string} title
     * @memberof ShakeAdSwitch
     * @instance
     */
    ShakeAdSwitch.prototype.title = "";

    /**
     * ShakeAdSwitch desc.
     * @member {string} desc
     * @memberof ShakeAdSwitch
     * @instance
     */
    ShakeAdSwitch.prototype.desc = "";

    /**
     * Creates a new ShakeAdSwitch instance using the specified properties.
     * @function create
     * @memberof ShakeAdSwitch
     * @static
     * @param {IShakeAdSwitch=} [properties] Properties to set
     * @returns {ShakeAdSwitch} ShakeAdSwitch instance
     */
    ShakeAdSwitch.create = function create(properties) {
        return new ShakeAdSwitch(properties);
    };

    /**
     * Encodes the specified ShakeAdSwitch message. Does not implicitly {@link ShakeAdSwitch.verify|verify} messages.
     * @function encode
     * @memberof ShakeAdSwitch
     * @static
     * @param {IShakeAdSwitch} message ShakeAdSwitch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShakeAdSwitch.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isShow != null && Object.hasOwnProperty.call(message, "isShow"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isShow);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
        if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.desc);
        return writer;
    };

    /**
     * Encodes the specified ShakeAdSwitch message, length delimited. Does not implicitly {@link ShakeAdSwitch.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ShakeAdSwitch
     * @static
     * @param {IShakeAdSwitch} message ShakeAdSwitch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShakeAdSwitch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ShakeAdSwitch message from the specified reader or buffer.
     * @function decode
     * @memberof ShakeAdSwitch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ShakeAdSwitch} ShakeAdSwitch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShakeAdSwitch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ShakeAdSwitch();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isShow = reader.int32();
                    break;
                }
            case 2: {
                    message.title = reader.string();
                    break;
                }
            case 3: {
                    message.desc = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ShakeAdSwitch message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ShakeAdSwitch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ShakeAdSwitch} ShakeAdSwitch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShakeAdSwitch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ShakeAdSwitch message.
     * @function verify
     * @memberof ShakeAdSwitch
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ShakeAdSwitch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isShow != null && message.hasOwnProperty("isShow"))
            if (!$util.isInteger(message.isShow))
                return "isShow: integer expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.desc != null && message.hasOwnProperty("desc"))
            if (!$util.isString(message.desc))
                return "desc: string expected";
        return null;
    };

    /**
     * Creates a ShakeAdSwitch message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ShakeAdSwitch
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ShakeAdSwitch} ShakeAdSwitch
     */
    ShakeAdSwitch.fromObject = function fromObject(object) {
        if (object instanceof $root.ShakeAdSwitch)
            return object;
        let message = new $root.ShakeAdSwitch();
        if (object.isShow != null)
            message.isShow = object.isShow | 0;
        if (object.title != null)
            message.title = String(object.title);
        if (object.desc != null)
            message.desc = String(object.desc);
        return message;
    };

    /**
     * Creates a plain object from a ShakeAdSwitch message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ShakeAdSwitch
     * @static
     * @param {ShakeAdSwitch} message ShakeAdSwitch
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ShakeAdSwitch.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.isShow = 0;
            object.title = "";
            object.desc = "";
        }
        if (message.isShow != null && message.hasOwnProperty("isShow"))
            object.isShow = message.isShow;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.desc != null && message.hasOwnProperty("desc"))
            object.desc = message.desc;
        return object;
    };

    /**
     * Converts this ShakeAdSwitch to JSON.
     * @function toJSON
     * @memberof ShakeAdSwitch
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ShakeAdSwitch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ShakeAdSwitch
     * @function getTypeUrl
     * @memberof ShakeAdSwitch
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ShakeAdSwitch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ShakeAdSwitch";
    };

    return ShakeAdSwitch;
})();

export const SimpleUser = $root.SimpleUser = (() => {

    /**
     * Properties of a SimpleUser.
     * @exports ISimpleUser
     * @interface ISimpleUser
     * @property {number|Long|null} [userId] SimpleUser userId
     * @property {number|null} [userStatus] SimpleUser userStatus
     * @property {string|null} [secureemail] SimpleUser secureemail
     * @property {string|null} [securemobil] SimpleUser securemobil
     * @property {string|null} [userName] SimpleUser userName
     * @property {string|null} [userNickname] SimpleUser userNickname
     * @property {number|null} [incompleteUser] SimpleUser incompleteUser
     * @property {string|null} [portrait] SimpleUser portrait
     * @property {number|null} [agreeType] SimpleUser agreeType
     * @property {string|null} [aheadUrl] SimpleUser aheadUrl
     * @property {string|null} [blockMsg] SimpleUser blockMsg
     * @property {number|null} [showOnlyme] SimpleUser showOnlyme
     */

    /**
     * Constructs a new SimpleUser.
     * @exports SimpleUser
     * @classdesc Represents a SimpleUser.
     * @implements ISimpleUser
     * @constructor
     * @param {ISimpleUser=} [properties] Properties to set
     */
    function SimpleUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimpleUser userId.
     * @member {number|Long} userId
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * SimpleUser userStatus.
     * @member {number} userStatus
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.userStatus = 0;

    /**
     * SimpleUser secureemail.
     * @member {string} secureemail
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.secureemail = "";

    /**
     * SimpleUser securemobil.
     * @member {string} securemobil
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.securemobil = "";

    /**
     * SimpleUser userName.
     * @member {string} userName
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.userName = "";

    /**
     * SimpleUser userNickname.
     * @member {string} userNickname
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.userNickname = "";

    /**
     * SimpleUser incompleteUser.
     * @member {number} incompleteUser
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.incompleteUser = 0;

    /**
     * SimpleUser portrait.
     * @member {string} portrait
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.portrait = "";

    /**
     * SimpleUser agreeType.
     * @member {number} agreeType
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.agreeType = 0;

    /**
     * SimpleUser aheadUrl.
     * @member {string} aheadUrl
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.aheadUrl = "";

    /**
     * SimpleUser blockMsg.
     * @member {string} blockMsg
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.blockMsg = "";

    /**
     * SimpleUser showOnlyme.
     * @member {number} showOnlyme
     * @memberof SimpleUser
     * @instance
     */
    SimpleUser.prototype.showOnlyme = 0;

    /**
     * Creates a new SimpleUser instance using the specified properties.
     * @function create
     * @memberof SimpleUser
     * @static
     * @param {ISimpleUser=} [properties] Properties to set
     * @returns {SimpleUser} SimpleUser instance
     */
    SimpleUser.create = function create(properties) {
        return new SimpleUser(properties);
    };

    /**
     * Encodes the specified SimpleUser message. Does not implicitly {@link SimpleUser.verify|verify} messages.
     * @function encode
     * @memberof SimpleUser
     * @static
     * @param {ISimpleUser} message SimpleUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimpleUser.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.userId);
        if (message.userStatus != null && Object.hasOwnProperty.call(message, "userStatus"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userStatus);
        if (message.secureemail != null && Object.hasOwnProperty.call(message, "secureemail"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.secureemail);
        if (message.securemobil != null && Object.hasOwnProperty.call(message, "securemobil"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.securemobil);
        if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.userName);
        if (message.userNickname != null && Object.hasOwnProperty.call(message, "userNickname"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.userNickname);
        if (message.incompleteUser != null && Object.hasOwnProperty.call(message, "incompleteUser"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.incompleteUser);
        if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.portrait);
        if (message.agreeType != null && Object.hasOwnProperty.call(message, "agreeType"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.agreeType);
        if (message.aheadUrl != null && Object.hasOwnProperty.call(message, "aheadUrl"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.aheadUrl);
        if (message.blockMsg != null && Object.hasOwnProperty.call(message, "blockMsg"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.blockMsg);
        if (message.showOnlyme != null && Object.hasOwnProperty.call(message, "showOnlyme"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.showOnlyme);
        return writer;
    };

    /**
     * Encodes the specified SimpleUser message, length delimited. Does not implicitly {@link SimpleUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimpleUser
     * @static
     * @param {ISimpleUser} message SimpleUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimpleUser.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimpleUser message from the specified reader or buffer.
     * @function decode
     * @memberof SimpleUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimpleUser} SimpleUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimpleUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimpleUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.userId = reader.int64();
                    break;
                }
            case 2: {
                    message.userStatus = reader.int32();
                    break;
                }
            case 3: {
                    message.secureemail = reader.string();
                    break;
                }
            case 4: {
                    message.securemobil = reader.string();
                    break;
                }
            case 5: {
                    message.userName = reader.string();
                    break;
                }
            case 6: {
                    message.userNickname = reader.string();
                    break;
                }
            case 7: {
                    message.incompleteUser = reader.uint32();
                    break;
                }
            case 8: {
                    message.portrait = reader.string();
                    break;
                }
            case 9: {
                    message.agreeType = reader.int32();
                    break;
                }
            case 10: {
                    message.aheadUrl = reader.string();
                    break;
                }
            case 11: {
                    message.blockMsg = reader.string();
                    break;
                }
            case 12: {
                    message.showOnlyme = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimpleUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimpleUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimpleUser} SimpleUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimpleUser.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimpleUser message.
     * @function verify
     * @memberof SimpleUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimpleUser.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                return "userId: integer|Long expected";
        if (message.userStatus != null && message.hasOwnProperty("userStatus"))
            if (!$util.isInteger(message.userStatus))
                return "userStatus: integer expected";
        if (message.secureemail != null && message.hasOwnProperty("secureemail"))
            if (!$util.isString(message.secureemail))
                return "secureemail: string expected";
        if (message.securemobil != null && message.hasOwnProperty("securemobil"))
            if (!$util.isString(message.securemobil))
                return "securemobil: string expected";
        if (message.userName != null && message.hasOwnProperty("userName"))
            if (!$util.isString(message.userName))
                return "userName: string expected";
        if (message.userNickname != null && message.hasOwnProperty("userNickname"))
            if (!$util.isString(message.userNickname))
                return "userNickname: string expected";
        if (message.incompleteUser != null && message.hasOwnProperty("incompleteUser"))
            if (!$util.isInteger(message.incompleteUser))
                return "incompleteUser: integer expected";
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            if (!$util.isString(message.portrait))
                return "portrait: string expected";
        if (message.agreeType != null && message.hasOwnProperty("agreeType"))
            if (!$util.isInteger(message.agreeType))
                return "agreeType: integer expected";
        if (message.aheadUrl != null && message.hasOwnProperty("aheadUrl"))
            if (!$util.isString(message.aheadUrl))
                return "aheadUrl: string expected";
        if (message.blockMsg != null && message.hasOwnProperty("blockMsg"))
            if (!$util.isString(message.blockMsg))
                return "blockMsg: string expected";
        if (message.showOnlyme != null && message.hasOwnProperty("showOnlyme"))
            if (!$util.isInteger(message.showOnlyme))
                return "showOnlyme: integer expected";
        return null;
    };

    /**
     * Creates a SimpleUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimpleUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimpleUser} SimpleUser
     */
    SimpleUser.fromObject = function fromObject(object) {
        if (object instanceof $root.SimpleUser)
            return object;
        let message = new $root.SimpleUser();
        if (object.userId != null)
            if ($util.Long)
                (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
            else if (typeof object.userId === "string")
                message.userId = parseInt(object.userId, 10);
            else if (typeof object.userId === "number")
                message.userId = object.userId;
            else if (typeof object.userId === "object")
                message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
        if (object.userStatus != null)
            message.userStatus = object.userStatus | 0;
        if (object.secureemail != null)
            message.secureemail = String(object.secureemail);
        if (object.securemobil != null)
            message.securemobil = String(object.securemobil);
        if (object.userName != null)
            message.userName = String(object.userName);
        if (object.userNickname != null)
            message.userNickname = String(object.userNickname);
        if (object.incompleteUser != null)
            message.incompleteUser = object.incompleteUser >>> 0;
        if (object.portrait != null)
            message.portrait = String(object.portrait);
        if (object.agreeType != null)
            message.agreeType = object.agreeType | 0;
        if (object.aheadUrl != null)
            message.aheadUrl = String(object.aheadUrl);
        if (object.blockMsg != null)
            message.blockMsg = String(object.blockMsg);
        if (object.showOnlyme != null)
            message.showOnlyme = object.showOnlyme | 0;
        return message;
    };

    /**
     * Creates a plain object from a SimpleUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimpleUser
     * @static
     * @param {SimpleUser} message SimpleUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimpleUser.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.userId = options.longs === String ? "0" : 0;
            object.userStatus = 0;
            object.secureemail = "";
            object.securemobil = "";
            object.userName = "";
            object.userNickname = "";
            object.incompleteUser = 0;
            object.portrait = "";
            object.agreeType = 0;
            object.aheadUrl = "";
            object.blockMsg = "";
            object.showOnlyme = 0;
        }
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (typeof message.userId === "number")
                object.userId = options.longs === String ? String(message.userId) : message.userId;
            else
                object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
        if (message.userStatus != null && message.hasOwnProperty("userStatus"))
            object.userStatus = message.userStatus;
        if (message.secureemail != null && message.hasOwnProperty("secureemail"))
            object.secureemail = message.secureemail;
        if (message.securemobil != null && message.hasOwnProperty("securemobil"))
            object.securemobil = message.securemobil;
        if (message.userName != null && message.hasOwnProperty("userName"))
            object.userName = message.userName;
        if (message.userNickname != null && message.hasOwnProperty("userNickname"))
            object.userNickname = message.userNickname;
        if (message.incompleteUser != null && message.hasOwnProperty("incompleteUser"))
            object.incompleteUser = message.incompleteUser;
        if (message.portrait != null && message.hasOwnProperty("portrait"))
            object.portrait = message.portrait;
        if (message.agreeType != null && message.hasOwnProperty("agreeType"))
            object.agreeType = message.agreeType;
        if (message.aheadUrl != null && message.hasOwnProperty("aheadUrl"))
            object.aheadUrl = message.aheadUrl;
        if (message.blockMsg != null && message.hasOwnProperty("blockMsg"))
            object.blockMsg = message.blockMsg;
        if (message.showOnlyme != null && message.hasOwnProperty("showOnlyme"))
            object.showOnlyme = message.showOnlyme;
        return object;
    };

    /**
     * Converts this SimpleUser to JSON.
     * @function toJSON
     * @memberof SimpleUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimpleUser.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimpleUser
     * @function getTypeUrl
     * @memberof SimpleUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimpleUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimpleUser";
    };

    return SimpleUser;
})();

export const SpringVirtualUser = $root.SpringVirtualUser = (() => {

    /**
     * Properties of a SpringVirtualUser.
     * @exports ISpringVirtualUser
     * @interface ISpringVirtualUser
     * @property {number|null} [isVirtual] SpringVirtualUser isVirtual
     * @property {string|null} [url] SpringVirtualUser url
     */

    /**
     * Constructs a new SpringVirtualUser.
     * @exports SpringVirtualUser
     * @classdesc Represents a SpringVirtualUser.
     * @implements ISpringVirtualUser
     * @constructor
     * @param {ISpringVirtualUser=} [properties] Properties to set
     */
    function SpringVirtualUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SpringVirtualUser isVirtual.
     * @member {number} isVirtual
     * @memberof SpringVirtualUser
     * @instance
     */
    SpringVirtualUser.prototype.isVirtual = 0;

    /**
     * SpringVirtualUser url.
     * @member {string} url
     * @memberof SpringVirtualUser
     * @instance
     */
    SpringVirtualUser.prototype.url = "";

    /**
     * Creates a new SpringVirtualUser instance using the specified properties.
     * @function create
     * @memberof SpringVirtualUser
     * @static
     * @param {ISpringVirtualUser=} [properties] Properties to set
     * @returns {SpringVirtualUser} SpringVirtualUser instance
     */
    SpringVirtualUser.create = function create(properties) {
        return new SpringVirtualUser(properties);
    };

    /**
     * Encodes the specified SpringVirtualUser message. Does not implicitly {@link SpringVirtualUser.verify|verify} messages.
     * @function encode
     * @memberof SpringVirtualUser
     * @static
     * @param {ISpringVirtualUser} message SpringVirtualUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SpringVirtualUser.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isVirtual != null && Object.hasOwnProperty.call(message, "isVirtual"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.isVirtual);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
        return writer;
    };

    /**
     * Encodes the specified SpringVirtualUser message, length delimited. Does not implicitly {@link SpringVirtualUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SpringVirtualUser
     * @static
     * @param {ISpringVirtualUser} message SpringVirtualUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SpringVirtualUser.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SpringVirtualUser message from the specified reader or buffer.
     * @function decode
     * @memberof SpringVirtualUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SpringVirtualUser} SpringVirtualUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SpringVirtualUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SpringVirtualUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isVirtual = reader.uint32();
                    break;
                }
            case 2: {
                    message.url = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SpringVirtualUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SpringVirtualUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SpringVirtualUser} SpringVirtualUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SpringVirtualUser.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SpringVirtualUser message.
     * @function verify
     * @memberof SpringVirtualUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SpringVirtualUser.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isVirtual != null && message.hasOwnProperty("isVirtual"))
            if (!$util.isInteger(message.isVirtual))
                return "isVirtual: integer expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        return null;
    };

    /**
     * Creates a SpringVirtualUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SpringVirtualUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SpringVirtualUser} SpringVirtualUser
     */
    SpringVirtualUser.fromObject = function fromObject(object) {
        if (object instanceof $root.SpringVirtualUser)
            return object;
        let message = new $root.SpringVirtualUser();
        if (object.isVirtual != null)
            message.isVirtual = object.isVirtual >>> 0;
        if (object.url != null)
            message.url = String(object.url);
        return message;
    };

    /**
     * Creates a plain object from a SpringVirtualUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SpringVirtualUser
     * @static
     * @param {SpringVirtualUser} message SpringVirtualUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SpringVirtualUser.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.isVirtual = 0;
            object.url = "";
        }
        if (message.isVirtual != null && message.hasOwnProperty("isVirtual"))
            object.isVirtual = message.isVirtual;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        return object;
    };

    /**
     * Converts this SpringVirtualUser to JSON.
     * @function toJSON
     * @memberof SpringVirtualUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SpringVirtualUser.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SpringVirtualUser
     * @function getTypeUrl
     * @memberof SpringVirtualUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SpringVirtualUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SpringVirtualUser";
    };

    return SpringVirtualUser;
})();

export const TbVipInfo = $root.TbVipInfo = (() => {

    /**
     * Properties of a TbVipInfo.
     * @exports ITbVipInfo
     * @interface ITbVipInfo
     * @property {string|null} [intro] TbVipInfo intro
     * @property {string|null} [vUrl] TbVipInfo vUrl
     * @property {string|null} [vDetail] TbVipInfo vDetail
     */

    /**
     * Constructs a new TbVipInfo.
     * @exports TbVipInfo
     * @classdesc Represents a TbVipInfo.
     * @implements ITbVipInfo
     * @constructor
     * @param {ITbVipInfo=} [properties] Properties to set
     */
    function TbVipInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TbVipInfo intro.
     * @member {string} intro
     * @memberof TbVipInfo
     * @instance
     */
    TbVipInfo.prototype.intro = "";

    /**
     * TbVipInfo vUrl.
     * @member {string} vUrl
     * @memberof TbVipInfo
     * @instance
     */
    TbVipInfo.prototype.vUrl = "";

    /**
     * TbVipInfo vDetail.
     * @member {string} vDetail
     * @memberof TbVipInfo
     * @instance
     */
    TbVipInfo.prototype.vDetail = "";

    /**
     * Creates a new TbVipInfo instance using the specified properties.
     * @function create
     * @memberof TbVipInfo
     * @static
     * @param {ITbVipInfo=} [properties] Properties to set
     * @returns {TbVipInfo} TbVipInfo instance
     */
    TbVipInfo.create = function create(properties) {
        return new TbVipInfo(properties);
    };

    /**
     * Encodes the specified TbVipInfo message. Does not implicitly {@link TbVipInfo.verify|verify} messages.
     * @function encode
     * @memberof TbVipInfo
     * @static
     * @param {ITbVipInfo} message TbVipInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TbVipInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.intro != null && Object.hasOwnProperty.call(message, "intro"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.intro);
        if (message.vUrl != null && Object.hasOwnProperty.call(message, "vUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.vUrl);
        if (message.vDetail != null && Object.hasOwnProperty.call(message, "vDetail"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.vDetail);
        return writer;
    };

    /**
     * Encodes the specified TbVipInfo message, length delimited. Does not implicitly {@link TbVipInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TbVipInfo
     * @static
     * @param {ITbVipInfo} message TbVipInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TbVipInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TbVipInfo message from the specified reader or buffer.
     * @function decode
     * @memberof TbVipInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TbVipInfo} TbVipInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TbVipInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TbVipInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.intro = reader.string();
                    break;
                }
            case 2: {
                    message.vUrl = reader.string();
                    break;
                }
            case 3: {
                    message.vDetail = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TbVipInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TbVipInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TbVipInfo} TbVipInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TbVipInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TbVipInfo message.
     * @function verify
     * @memberof TbVipInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TbVipInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.intro != null && message.hasOwnProperty("intro"))
            if (!$util.isString(message.intro))
                return "intro: string expected";
        if (message.vUrl != null && message.hasOwnProperty("vUrl"))
            if (!$util.isString(message.vUrl))
                return "vUrl: string expected";
        if (message.vDetail != null && message.hasOwnProperty("vDetail"))
            if (!$util.isString(message.vDetail))
                return "vDetail: string expected";
        return null;
    };

    /**
     * Creates a TbVipInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TbVipInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TbVipInfo} TbVipInfo
     */
    TbVipInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.TbVipInfo)
            return object;
        let message = new $root.TbVipInfo();
        if (object.intro != null)
            message.intro = String(object.intro);
        if (object.vUrl != null)
            message.vUrl = String(object.vUrl);
        if (object.vDetail != null)
            message.vDetail = String(object.vDetail);
        return message;
    };

    /**
     * Creates a plain object from a TbVipInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TbVipInfo
     * @static
     * @param {TbVipInfo} message TbVipInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TbVipInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.intro = "";
            object.vUrl = "";
            object.vDetail = "";
        }
        if (message.intro != null && message.hasOwnProperty("intro"))
            object.intro = message.intro;
        if (message.vUrl != null && message.hasOwnProperty("vUrl"))
            object.vUrl = message.vUrl;
        if (message.vDetail != null && message.hasOwnProperty("vDetail"))
            object.vDetail = message.vDetail;
        return object;
    };

    /**
     * Converts this TbVipInfo to JSON.
     * @function toJSON
     * @memberof TbVipInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TbVipInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TbVipInfo
     * @function getTypeUrl
     * @memberof TbVipInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TbVipInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TbVipInfo";
    };

    return TbVipInfo;
})();

export const ThemeCardInUser = $root.ThemeCardInUser = (() => {

    /**
     * Properties of a ThemeCardInUser.
     * @exports IThemeCardInUser
     * @interface IThemeCardInUser
     * @property {number|Long|null} [propsId] ThemeCardInUser propsId
     * @property {string|null} [imgIos] ThemeCardInUser imgIos
     * @property {string|null} [coordinate] ThemeCardInUser coordinate
     * @property {string|null} [imgAndroid] ThemeCardInUser imgAndroid
     * @property {number|null} [level] ThemeCardInUser level
     * @property {string|null} [dynamicUrl] ThemeCardInUser dynamicUrl
     * @property {string|null} [exclusiveNo] ThemeCardInUser exclusiveNo
     * @property {string|null} [jumpUrl] ThemeCardInUser jumpUrl
     */

    /**
     * Constructs a new ThemeCardInUser.
     * @exports ThemeCardInUser
     * @classdesc Represents a ThemeCardInUser.
     * @implements IThemeCardInUser
     * @constructor
     * @param {IThemeCardInUser=} [properties] Properties to set
     */
    function ThemeCardInUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ThemeCardInUser propsId.
     * @member {number|Long} propsId
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.propsId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ThemeCardInUser imgIos.
     * @member {string} imgIos
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.imgIos = "";

    /**
     * ThemeCardInUser coordinate.
     * @member {string} coordinate
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.coordinate = "";

    /**
     * ThemeCardInUser imgAndroid.
     * @member {string} imgAndroid
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.imgAndroid = "";

    /**
     * ThemeCardInUser level.
     * @member {number} level
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.level = 0;

    /**
     * ThemeCardInUser dynamicUrl.
     * @member {string} dynamicUrl
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.dynamicUrl = "";

    /**
     * ThemeCardInUser exclusiveNo.
     * @member {string} exclusiveNo
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.exclusiveNo = "";

    /**
     * ThemeCardInUser jumpUrl.
     * @member {string} jumpUrl
     * @memberof ThemeCardInUser
     * @instance
     */
    ThemeCardInUser.prototype.jumpUrl = "";

    /**
     * Creates a new ThemeCardInUser instance using the specified properties.
     * @function create
     * @memberof ThemeCardInUser
     * @static
     * @param {IThemeCardInUser=} [properties] Properties to set
     * @returns {ThemeCardInUser} ThemeCardInUser instance
     */
    ThemeCardInUser.create = function create(properties) {
        return new ThemeCardInUser(properties);
    };

    /**
     * Encodes the specified ThemeCardInUser message. Does not implicitly {@link ThemeCardInUser.verify|verify} messages.
     * @function encode
     * @memberof ThemeCardInUser
     * @static
     * @param {IThemeCardInUser} message ThemeCardInUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ThemeCardInUser.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.propsId);
        if (message.imgIos != null && Object.hasOwnProperty.call(message, "imgIos"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.imgIos);
        if (message.coordinate != null && Object.hasOwnProperty.call(message, "coordinate"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.coordinate);
        if (message.imgAndroid != null && Object.hasOwnProperty.call(message, "imgAndroid"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.imgAndroid);
        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.level);
        if (message.dynamicUrl != null && Object.hasOwnProperty.call(message, "dynamicUrl"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.dynamicUrl);
        if (message.exclusiveNo != null && Object.hasOwnProperty.call(message, "exclusiveNo"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.exclusiveNo);
        if (message.jumpUrl != null && Object.hasOwnProperty.call(message, "jumpUrl"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.jumpUrl);
        return writer;
    };

    /**
     * Encodes the specified ThemeCardInUser message, length delimited. Does not implicitly {@link ThemeCardInUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ThemeCardInUser
     * @static
     * @param {IThemeCardInUser} message ThemeCardInUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ThemeCardInUser.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ThemeCardInUser message from the specified reader or buffer.
     * @function decode
     * @memberof ThemeCardInUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ThemeCardInUser} ThemeCardInUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ThemeCardInUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ThemeCardInUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.propsId = reader.uint64();
                    break;
                }
            case 2: {
                    message.imgIos = reader.string();
                    break;
                }
            case 3: {
                    message.coordinate = reader.string();
                    break;
                }
            case 4: {
                    message.imgAndroid = reader.string();
                    break;
                }
            case 5: {
                    message.level = reader.uint32();
                    break;
                }
            case 6: {
                    message.dynamicUrl = reader.string();
                    break;
                }
            case 7: {
                    message.exclusiveNo = reader.string();
                    break;
                }
            case 8: {
                    message.jumpUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ThemeCardInUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ThemeCardInUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ThemeCardInUser} ThemeCardInUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ThemeCardInUser.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ThemeCardInUser message.
     * @function verify
     * @memberof ThemeCardInUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ThemeCardInUser.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isInteger(message.propsId) && !(message.propsId && $util.isInteger(message.propsId.low) && $util.isInteger(message.propsId.high)))
                return "propsId: integer|Long expected";
        if (message.imgIos != null && message.hasOwnProperty("imgIos"))
            if (!$util.isString(message.imgIos))
                return "imgIos: string expected";
        if (message.coordinate != null && message.hasOwnProperty("coordinate"))
            if (!$util.isString(message.coordinate))
                return "coordinate: string expected";
        if (message.imgAndroid != null && message.hasOwnProperty("imgAndroid"))
            if (!$util.isString(message.imgAndroid))
                return "imgAndroid: string expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.dynamicUrl != null && message.hasOwnProperty("dynamicUrl"))
            if (!$util.isString(message.dynamicUrl))
                return "dynamicUrl: string expected";
        if (message.exclusiveNo != null && message.hasOwnProperty("exclusiveNo"))
            if (!$util.isString(message.exclusiveNo))
                return "exclusiveNo: string expected";
        if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
            if (!$util.isString(message.jumpUrl))
                return "jumpUrl: string expected";
        return null;
    };

    /**
     * Creates a ThemeCardInUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ThemeCardInUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ThemeCardInUser} ThemeCardInUser
     */
    ThemeCardInUser.fromObject = function fromObject(object) {
        if (object instanceof $root.ThemeCardInUser)
            return object;
        let message = new $root.ThemeCardInUser();
        if (object.propsId != null)
            if ($util.Long)
                (message.propsId = $util.Long.fromValue(object.propsId)).unsigned = true;
            else if (typeof object.propsId === "string")
                message.propsId = parseInt(object.propsId, 10);
            else if (typeof object.propsId === "number")
                message.propsId = object.propsId;
            else if (typeof object.propsId === "object")
                message.propsId = new $util.LongBits(object.propsId.low >>> 0, object.propsId.high >>> 0).toNumber(true);
        if (object.imgIos != null)
            message.imgIos = String(object.imgIos);
        if (object.coordinate != null)
            message.coordinate = String(object.coordinate);
        if (object.imgAndroid != null)
            message.imgAndroid = String(object.imgAndroid);
        if (object.level != null)
            message.level = object.level >>> 0;
        if (object.dynamicUrl != null)
            message.dynamicUrl = String(object.dynamicUrl);
        if (object.exclusiveNo != null)
            message.exclusiveNo = String(object.exclusiveNo);
        if (object.jumpUrl != null)
            message.jumpUrl = String(object.jumpUrl);
        return message;
    };

    /**
     * Creates a plain object from a ThemeCardInUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ThemeCardInUser
     * @static
     * @param {ThemeCardInUser} message ThemeCardInUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ThemeCardInUser.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.propsId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.propsId = options.longs === String ? "0" : 0;
            object.imgIos = "";
            object.coordinate = "";
            object.imgAndroid = "";
            object.level = 0;
            object.dynamicUrl = "";
            object.exclusiveNo = "";
            object.jumpUrl = "";
        }
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (typeof message.propsId === "number")
                object.propsId = options.longs === String ? String(message.propsId) : message.propsId;
            else
                object.propsId = options.longs === String ? $util.Long.prototype.toString.call(message.propsId) : options.longs === Number ? new $util.LongBits(message.propsId.low >>> 0, message.propsId.high >>> 0).toNumber(true) : message.propsId;
        if (message.imgIos != null && message.hasOwnProperty("imgIos"))
            object.imgIos = message.imgIos;
        if (message.coordinate != null && message.hasOwnProperty("coordinate"))
            object.coordinate = message.coordinate;
        if (message.imgAndroid != null && message.hasOwnProperty("imgAndroid"))
            object.imgAndroid = message.imgAndroid;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.dynamicUrl != null && message.hasOwnProperty("dynamicUrl"))
            object.dynamicUrl = message.dynamicUrl;
        if (message.exclusiveNo != null && message.hasOwnProperty("exclusiveNo"))
            object.exclusiveNo = message.exclusiveNo;
        if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
            object.jumpUrl = message.jumpUrl;
        return object;
    };

    /**
     * Converts this ThemeCardInUser to JSON.
     * @function toJSON
     * @memberof ThemeCardInUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ThemeCardInUser.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ThemeCardInUser
     * @function getTypeUrl
     * @memberof ThemeCardInUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ThemeCardInUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ThemeCardInUser";
    };

    return ThemeCardInUser;
})();

export const ThemeTailInUser = $root.ThemeTailInUser = (() => {

    /**
     * Properties of a ThemeTailInUser.
     * @exports IThemeTailInUser
     * @interface IThemeTailInUser
     * @property {string|null} [url] ThemeTailInUser url
     * @property {string|null} [dynamic] ThemeTailInUser dynamic
     * @property {string|null} [propsId] ThemeTailInUser propsId
     */

    /**
     * Constructs a new ThemeTailInUser.
     * @exports ThemeTailInUser
     * @classdesc Represents a ThemeTailInUser.
     * @implements IThemeTailInUser
     * @constructor
     * @param {IThemeTailInUser=} [properties] Properties to set
     */
    function ThemeTailInUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ThemeTailInUser url.
     * @member {string} url
     * @memberof ThemeTailInUser
     * @instance
     */
    ThemeTailInUser.prototype.url = "";

    /**
     * ThemeTailInUser dynamic.
     * @member {string} dynamic
     * @memberof ThemeTailInUser
     * @instance
     */
    ThemeTailInUser.prototype.dynamic = "";

    /**
     * ThemeTailInUser propsId.
     * @member {string} propsId
     * @memberof ThemeTailInUser
     * @instance
     */
    ThemeTailInUser.prototype.propsId = "";

    /**
     * Creates a new ThemeTailInUser instance using the specified properties.
     * @function create
     * @memberof ThemeTailInUser
     * @static
     * @param {IThemeTailInUser=} [properties] Properties to set
     * @returns {ThemeTailInUser} ThemeTailInUser instance
     */
    ThemeTailInUser.create = function create(properties) {
        return new ThemeTailInUser(properties);
    };

    /**
     * Encodes the specified ThemeTailInUser message. Does not implicitly {@link ThemeTailInUser.verify|verify} messages.
     * @function encode
     * @memberof ThemeTailInUser
     * @static
     * @param {IThemeTailInUser} message ThemeTailInUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ThemeTailInUser.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.dynamic != null && Object.hasOwnProperty.call(message, "dynamic"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.dynamic);
        if (message.propsId != null && Object.hasOwnProperty.call(message, "propsId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.propsId);
        return writer;
    };

    /**
     * Encodes the specified ThemeTailInUser message, length delimited. Does not implicitly {@link ThemeTailInUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ThemeTailInUser
     * @static
     * @param {IThemeTailInUser} message ThemeTailInUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ThemeTailInUser.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ThemeTailInUser message from the specified reader or buffer.
     * @function decode
     * @memberof ThemeTailInUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ThemeTailInUser} ThemeTailInUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ThemeTailInUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ThemeTailInUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.url = reader.string();
                    break;
                }
            case 2: {
                    message.dynamic = reader.string();
                    break;
                }
            case 3: {
                    message.propsId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ThemeTailInUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ThemeTailInUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ThemeTailInUser} ThemeTailInUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ThemeTailInUser.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ThemeTailInUser message.
     * @function verify
     * @memberof ThemeTailInUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ThemeTailInUser.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.dynamic != null && message.hasOwnProperty("dynamic"))
            if (!$util.isString(message.dynamic))
                return "dynamic: string expected";
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            if (!$util.isString(message.propsId))
                return "propsId: string expected";
        return null;
    };

    /**
     * Creates a ThemeTailInUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ThemeTailInUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ThemeTailInUser} ThemeTailInUser
     */
    ThemeTailInUser.fromObject = function fromObject(object) {
        if (object instanceof $root.ThemeTailInUser)
            return object;
        let message = new $root.ThemeTailInUser();
        if (object.url != null)
            message.url = String(object.url);
        if (object.dynamic != null)
            message.dynamic = String(object.dynamic);
        if (object.propsId != null)
            message.propsId = String(object.propsId);
        return message;
    };

    /**
     * Creates a plain object from a ThemeTailInUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ThemeTailInUser
     * @static
     * @param {ThemeTailInUser} message ThemeTailInUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ThemeTailInUser.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.url = "";
            object.dynamic = "";
            object.propsId = "";
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.dynamic != null && message.hasOwnProperty("dynamic"))
            object.dynamic = message.dynamic;
        if (message.propsId != null && message.hasOwnProperty("propsId"))
            object.propsId = message.propsId;
        return object;
    };

    /**
     * Converts this ThemeTailInUser to JSON.
     * @function toJSON
     * @memberof ThemeTailInUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ThemeTailInUser.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ThemeTailInUser
     * @function getTypeUrl
     * @memberof ThemeTailInUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ThemeTailInUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ThemeTailInUser";
    };

    return ThemeTailInUser;
})();

export const TshowInfo = $root.TshowInfo = (() => {

    /**
     * Properties of a TshowInfo.
     * @exports ITshowInfo
     * @interface ITshowInfo
     * @property {string|null} [icon] TshowInfo icon
     * @property {string|null} [name] TshowInfo name
     * @property {string|null} [url] TshowInfo url
     */

    /**
     * Constructs a new TshowInfo.
     * @exports TshowInfo
     * @classdesc Represents a TshowInfo.
     * @implements ITshowInfo
     * @constructor
     * @param {ITshowInfo=} [properties] Properties to set
     */
    function TshowInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TshowInfo icon.
     * @member {string} icon
     * @memberof TshowInfo
     * @instance
     */
    TshowInfo.prototype.icon = "";

    /**
     * TshowInfo name.
     * @member {string} name
     * @memberof TshowInfo
     * @instance
     */
    TshowInfo.prototype.name = "";

    /**
     * TshowInfo url.
     * @member {string} url
     * @memberof TshowInfo
     * @instance
     */
    TshowInfo.prototype.url = "";

    /**
     * Creates a new TshowInfo instance using the specified properties.
     * @function create
     * @memberof TshowInfo
     * @static
     * @param {ITshowInfo=} [properties] Properties to set
     * @returns {TshowInfo} TshowInfo instance
     */
    TshowInfo.create = function create(properties) {
        return new TshowInfo(properties);
    };

    /**
     * Encodes the specified TshowInfo message. Does not implicitly {@link TshowInfo.verify|verify} messages.
     * @function encode
     * @memberof TshowInfo
     * @static
     * @param {ITshowInfo} message TshowInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TshowInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.icon);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
        return writer;
    };

    /**
     * Encodes the specified TshowInfo message, length delimited. Does not implicitly {@link TshowInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TshowInfo
     * @static
     * @param {ITshowInfo} message TshowInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TshowInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TshowInfo message from the specified reader or buffer.
     * @function decode
     * @memberof TshowInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TshowInfo} TshowInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TshowInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TshowInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.icon = reader.string();
                    break;
                }
            case 2: {
                    message.name = reader.string();
                    break;
                }
            case 3: {
                    message.url = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TshowInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TshowInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TshowInfo} TshowInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TshowInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TshowInfo message.
     * @function verify
     * @memberof TshowInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TshowInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.icon != null && message.hasOwnProperty("icon"))
            if (!$util.isString(message.icon))
                return "icon: string expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        return null;
    };

    /**
     * Creates a TshowInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TshowInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TshowInfo} TshowInfo
     */
    TshowInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.TshowInfo)
            return object;
        let message = new $root.TshowInfo();
        if (object.icon != null)
            message.icon = String(object.icon);
        if (object.name != null)
            message.name = String(object.name);
        if (object.url != null)
            message.url = String(object.url);
        return message;
    };

    /**
     * Creates a plain object from a TshowInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TshowInfo
     * @static
     * @param {TshowInfo} message TshowInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TshowInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.icon = "";
            object.name = "";
            object.url = "";
        }
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = message.icon;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        return object;
    };

    /**
     * Converts this TshowInfo to JSON.
     * @function toJSON
     * @memberof TshowInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TshowInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TshowInfo
     * @function getTypeUrl
     * @memberof TshowInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TshowInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TshowInfo";
    };

    return TshowInfo;
})();

export const TwAnchorProfitItem = $root.TwAnchorProfitItem = (() => {

    /**
     * Properties of a TwAnchorProfitItem.
     * @exports ITwAnchorProfitItem
     * @interface ITwAnchorProfitItem
     * @property {number|null} [id] TwAnchorProfitItem id
     * @property {number|null} [availableAnchorLevel] TwAnchorProfitItem availableAnchorLevel
     * @property {string|null} [name] TwAnchorProfitItem name
     * @property {string|null} [iconUnlockUrl] TwAnchorProfitItem iconUnlockUrl
     * @property {string|null} [iconLockUrl] TwAnchorProfitItem iconLockUrl
     */

    /**
     * Constructs a new TwAnchorProfitItem.
     * @exports TwAnchorProfitItem
     * @classdesc Represents a TwAnchorProfitItem.
     * @implements ITwAnchorProfitItem
     * @constructor
     * @param {ITwAnchorProfitItem=} [properties] Properties to set
     */
    function TwAnchorProfitItem(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TwAnchorProfitItem id.
     * @member {number} id
     * @memberof TwAnchorProfitItem
     * @instance
     */
    TwAnchorProfitItem.prototype.id = 0;

    /**
     * TwAnchorProfitItem availableAnchorLevel.
     * @member {number} availableAnchorLevel
     * @memberof TwAnchorProfitItem
     * @instance
     */
    TwAnchorProfitItem.prototype.availableAnchorLevel = 0;

    /**
     * TwAnchorProfitItem name.
     * @member {string} name
     * @memberof TwAnchorProfitItem
     * @instance
     */
    TwAnchorProfitItem.prototype.name = "";

    /**
     * TwAnchorProfitItem iconUnlockUrl.
     * @member {string} iconUnlockUrl
     * @memberof TwAnchorProfitItem
     * @instance
     */
    TwAnchorProfitItem.prototype.iconUnlockUrl = "";

    /**
     * TwAnchorProfitItem iconLockUrl.
     * @member {string} iconLockUrl
     * @memberof TwAnchorProfitItem
     * @instance
     */
    TwAnchorProfitItem.prototype.iconLockUrl = "";

    /**
     * Creates a new TwAnchorProfitItem instance using the specified properties.
     * @function create
     * @memberof TwAnchorProfitItem
     * @static
     * @param {ITwAnchorProfitItem=} [properties] Properties to set
     * @returns {TwAnchorProfitItem} TwAnchorProfitItem instance
     */
    TwAnchorProfitItem.create = function create(properties) {
        return new TwAnchorProfitItem(properties);
    };

    /**
     * Encodes the specified TwAnchorProfitItem message. Does not implicitly {@link TwAnchorProfitItem.verify|verify} messages.
     * @function encode
     * @memberof TwAnchorProfitItem
     * @static
     * @param {ITwAnchorProfitItem} message TwAnchorProfitItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TwAnchorProfitItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.availableAnchorLevel != null && Object.hasOwnProperty.call(message, "availableAnchorLevel"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.availableAnchorLevel);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
        if (message.iconUnlockUrl != null && Object.hasOwnProperty.call(message, "iconUnlockUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.iconUnlockUrl);
        if (message.iconLockUrl != null && Object.hasOwnProperty.call(message, "iconLockUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.iconLockUrl);
        return writer;
    };

    /**
     * Encodes the specified TwAnchorProfitItem message, length delimited. Does not implicitly {@link TwAnchorProfitItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TwAnchorProfitItem
     * @static
     * @param {ITwAnchorProfitItem} message TwAnchorProfitItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TwAnchorProfitItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TwAnchorProfitItem message from the specified reader or buffer.
     * @function decode
     * @memberof TwAnchorProfitItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TwAnchorProfitItem} TwAnchorProfitItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TwAnchorProfitItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TwAnchorProfitItem();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.id = reader.int32();
                    break;
                }
            case 2: {
                    message.availableAnchorLevel = reader.uint32();
                    break;
                }
            case 3: {
                    message.name = reader.string();
                    break;
                }
            case 4: {
                    message.iconUnlockUrl = reader.string();
                    break;
                }
            case 5: {
                    message.iconLockUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TwAnchorProfitItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TwAnchorProfitItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TwAnchorProfitItem} TwAnchorProfitItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TwAnchorProfitItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TwAnchorProfitItem message.
     * @function verify
     * @memberof TwAnchorProfitItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TwAnchorProfitItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.availableAnchorLevel != null && message.hasOwnProperty("availableAnchorLevel"))
            if (!$util.isInteger(message.availableAnchorLevel))
                return "availableAnchorLevel: integer expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.iconUnlockUrl != null && message.hasOwnProperty("iconUnlockUrl"))
            if (!$util.isString(message.iconUnlockUrl))
                return "iconUnlockUrl: string expected";
        if (message.iconLockUrl != null && message.hasOwnProperty("iconLockUrl"))
            if (!$util.isString(message.iconLockUrl))
                return "iconLockUrl: string expected";
        return null;
    };

    /**
     * Creates a TwAnchorProfitItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TwAnchorProfitItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TwAnchorProfitItem} TwAnchorProfitItem
     */
    TwAnchorProfitItem.fromObject = function fromObject(object) {
        if (object instanceof $root.TwAnchorProfitItem)
            return object;
        let message = new $root.TwAnchorProfitItem();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.availableAnchorLevel != null)
            message.availableAnchorLevel = object.availableAnchorLevel >>> 0;
        if (object.name != null)
            message.name = String(object.name);
        if (object.iconUnlockUrl != null)
            message.iconUnlockUrl = String(object.iconUnlockUrl);
        if (object.iconLockUrl != null)
            message.iconLockUrl = String(object.iconLockUrl);
        return message;
    };

    /**
     * Creates a plain object from a TwAnchorProfitItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TwAnchorProfitItem
     * @static
     * @param {TwAnchorProfitItem} message TwAnchorProfitItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TwAnchorProfitItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = 0;
            object.availableAnchorLevel = 0;
            object.name = "";
            object.iconUnlockUrl = "";
            object.iconLockUrl = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.availableAnchorLevel != null && message.hasOwnProperty("availableAnchorLevel"))
            object.availableAnchorLevel = message.availableAnchorLevel;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.iconUnlockUrl != null && message.hasOwnProperty("iconUnlockUrl"))
            object.iconUnlockUrl = message.iconUnlockUrl;
        if (message.iconLockUrl != null && message.hasOwnProperty("iconLockUrl"))
            object.iconLockUrl = message.iconLockUrl;
        return object;
    };

    /**
     * Converts this TwAnchorProfitItem to JSON.
     * @function toJSON
     * @memberof TwAnchorProfitItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TwAnchorProfitItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TwAnchorProfitItem
     * @function getTypeUrl
     * @memberof TwAnchorProfitItem
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TwAnchorProfitItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TwAnchorProfitItem";
    };

    return TwAnchorProfitItem;
})();

export const TwZhiBoUser = $root.TwZhiBoUser = (() => {

    /**
     * Properties of a TwZhiBoUser.
     * @exports ITwZhiBoUser
     * @interface ITwZhiBoUser
     * @property {number|null} [anchorLevel] TwZhiBoUser anchorLevel
     * @property {number|null} [inBlackList] TwZhiBoUser inBlackList
     * @property {string|null} [fieldEx] TwZhiBoUser fieldEx
     */

    /**
     * Constructs a new TwZhiBoUser.
     * @exports TwZhiBoUser
     * @classdesc Represents a TwZhiBoUser.
     * @implements ITwZhiBoUser
     * @constructor
     * @param {ITwZhiBoUser=} [properties] Properties to set
     */
    function TwZhiBoUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TwZhiBoUser anchorLevel.
     * @member {number} anchorLevel
     * @memberof TwZhiBoUser
     * @instance
     */
    TwZhiBoUser.prototype.anchorLevel = 0;

    /**
     * TwZhiBoUser inBlackList.
     * @member {number} inBlackList
     * @memberof TwZhiBoUser
     * @instance
     */
    TwZhiBoUser.prototype.inBlackList = 0;

    /**
     * TwZhiBoUser fieldEx.
     * @member {string} fieldEx
     * @memberof TwZhiBoUser
     * @instance
     */
    TwZhiBoUser.prototype.fieldEx = "";

    /**
     * Creates a new TwZhiBoUser instance using the specified properties.
     * @function create
     * @memberof TwZhiBoUser
     * @static
     * @param {ITwZhiBoUser=} [properties] Properties to set
     * @returns {TwZhiBoUser} TwZhiBoUser instance
     */
    TwZhiBoUser.create = function create(properties) {
        return new TwZhiBoUser(properties);
    };

    /**
     * Encodes the specified TwZhiBoUser message. Does not implicitly {@link TwZhiBoUser.verify|verify} messages.
     * @function encode
     * @memberof TwZhiBoUser
     * @static
     * @param {ITwZhiBoUser} message TwZhiBoUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TwZhiBoUser.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.anchorLevel != null && Object.hasOwnProperty.call(message, "anchorLevel"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.anchorLevel);
        if (message.inBlackList != null && Object.hasOwnProperty.call(message, "inBlackList"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.inBlackList);
        if (message.fieldEx != null && Object.hasOwnProperty.call(message, "fieldEx"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.fieldEx);
        return writer;
    };

    /**
     * Encodes the specified TwZhiBoUser message, length delimited. Does not implicitly {@link TwZhiBoUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TwZhiBoUser
     * @static
     * @param {ITwZhiBoUser} message TwZhiBoUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TwZhiBoUser.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TwZhiBoUser message from the specified reader or buffer.
     * @function decode
     * @memberof TwZhiBoUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TwZhiBoUser} TwZhiBoUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TwZhiBoUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TwZhiBoUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.anchorLevel = reader.uint32();
                    break;
                }
            case 2: {
                    message.inBlackList = reader.uint32();
                    break;
                }
            case 3: {
                    message.fieldEx = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TwZhiBoUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TwZhiBoUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TwZhiBoUser} TwZhiBoUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TwZhiBoUser.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TwZhiBoUser message.
     * @function verify
     * @memberof TwZhiBoUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TwZhiBoUser.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.anchorLevel != null && message.hasOwnProperty("anchorLevel"))
            if (!$util.isInteger(message.anchorLevel))
                return "anchorLevel: integer expected";
        if (message.inBlackList != null && message.hasOwnProperty("inBlackList"))
            if (!$util.isInteger(message.inBlackList))
                return "inBlackList: integer expected";
        if (message.fieldEx != null && message.hasOwnProperty("fieldEx"))
            if (!$util.isString(message.fieldEx))
                return "fieldEx: string expected";
        return null;
    };

    /**
     * Creates a TwZhiBoUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TwZhiBoUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TwZhiBoUser} TwZhiBoUser
     */
    TwZhiBoUser.fromObject = function fromObject(object) {
        if (object instanceof $root.TwZhiBoUser)
            return object;
        let message = new $root.TwZhiBoUser();
        if (object.anchorLevel != null)
            message.anchorLevel = object.anchorLevel >>> 0;
        if (object.inBlackList != null)
            message.inBlackList = object.inBlackList >>> 0;
        if (object.fieldEx != null)
            message.fieldEx = String(object.fieldEx);
        return message;
    };

    /**
     * Creates a plain object from a TwZhiBoUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TwZhiBoUser
     * @static
     * @param {TwZhiBoUser} message TwZhiBoUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TwZhiBoUser.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.anchorLevel = 0;
            object.inBlackList = 0;
            object.fieldEx = "";
        }
        if (message.anchorLevel != null && message.hasOwnProperty("anchorLevel"))
            object.anchorLevel = message.anchorLevel;
        if (message.inBlackList != null && message.hasOwnProperty("inBlackList"))
            object.inBlackList = message.inBlackList;
        if (message.fieldEx != null && message.hasOwnProperty("fieldEx"))
            object.fieldEx = message.fieldEx;
        return object;
    };

    /**
     * Converts this TwZhiBoUser to JSON.
     * @function toJSON
     * @memberof TwZhiBoUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TwZhiBoUser.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TwZhiBoUser
     * @function getTypeUrl
     * @memberof TwZhiBoUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TwZhiBoUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TwZhiBoUser";
    };

    return TwZhiBoUser;
})();

export const UserPics = $root.UserPics = (() => {

    /**
     * Properties of a UserPics.
     * @exports IUserPics
     * @interface IUserPics
     * @property {string|null} [big] UserPics big
     * @property {string|null} [small] UserPics small
     */

    /**
     * Constructs a new UserPics.
     * @exports UserPics
     * @classdesc Represents a UserPics.
     * @implements IUserPics
     * @constructor
     * @param {IUserPics=} [properties] Properties to set
     */
    function UserPics(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserPics big.
     * @member {string} big
     * @memberof UserPics
     * @instance
     */
    UserPics.prototype.big = "";

    /**
     * UserPics small.
     * @member {string} small
     * @memberof UserPics
     * @instance
     */
    UserPics.prototype.small = "";

    /**
     * Creates a new UserPics instance using the specified properties.
     * @function create
     * @memberof UserPics
     * @static
     * @param {IUserPics=} [properties] Properties to set
     * @returns {UserPics} UserPics instance
     */
    UserPics.create = function create(properties) {
        return new UserPics(properties);
    };

    /**
     * Encodes the specified UserPics message. Does not implicitly {@link UserPics.verify|verify} messages.
     * @function encode
     * @memberof UserPics
     * @static
     * @param {IUserPics} message UserPics message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserPics.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.big != null && Object.hasOwnProperty.call(message, "big"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.big);
        if (message.small != null && Object.hasOwnProperty.call(message, "small"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.small);
        return writer;
    };

    /**
     * Encodes the specified UserPics message, length delimited. Does not implicitly {@link UserPics.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserPics
     * @static
     * @param {IUserPics} message UserPics message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserPics.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserPics message from the specified reader or buffer.
     * @function decode
     * @memberof UserPics
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserPics} UserPics
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserPics.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserPics();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.big = reader.string();
                    break;
                }
            case 2: {
                    message.small = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserPics message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserPics
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserPics} UserPics
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserPics.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserPics message.
     * @function verify
     * @memberof UserPics
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserPics.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.big != null && message.hasOwnProperty("big"))
            if (!$util.isString(message.big))
                return "big: string expected";
        if (message.small != null && message.hasOwnProperty("small"))
            if (!$util.isString(message.small))
                return "small: string expected";
        return null;
    };

    /**
     * Creates a UserPics message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserPics
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserPics} UserPics
     */
    UserPics.fromObject = function fromObject(object) {
        if (object instanceof $root.UserPics)
            return object;
        let message = new $root.UserPics();
        if (object.big != null)
            message.big = String(object.big);
        if (object.small != null)
            message.small = String(object.small);
        return message;
    };

    /**
     * Creates a plain object from a UserPics message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserPics
     * @static
     * @param {UserPics} message UserPics
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserPics.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.big = "";
            object.small = "";
        }
        if (message.big != null && message.hasOwnProperty("big"))
            object.big = message.big;
        if (message.small != null && message.hasOwnProperty("small"))
            object.small = message.small;
        return object;
    };

    /**
     * Converts this UserPics to JSON.
     * @function toJSON
     * @memberof UserPics
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserPics.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserPics
     * @function getTypeUrl
     * @memberof UserPics
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserPics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/UserPics";
    };

    return UserPics;
})();

export const UserVideoChannelInfo = $root.UserVideoChannelInfo = (() => {

    /**
     * Properties of a UserVideoChannelInfo.
     * @exports IUserVideoChannelInfo
     * @interface IUserVideoChannelInfo
     * @property {number|null} [manChannel] UserVideoChannelInfo manChannel
     * @property {number|null} [followChannel] UserVideoChannelInfo followChannel
     */

    /**
     * Constructs a new UserVideoChannelInfo.
     * @exports UserVideoChannelInfo
     * @classdesc Represents a UserVideoChannelInfo.
     * @implements IUserVideoChannelInfo
     * @constructor
     * @param {IUserVideoChannelInfo=} [properties] Properties to set
     */
    function UserVideoChannelInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserVideoChannelInfo manChannel.
     * @member {number} manChannel
     * @memberof UserVideoChannelInfo
     * @instance
     */
    UserVideoChannelInfo.prototype.manChannel = 0;

    /**
     * UserVideoChannelInfo followChannel.
     * @member {number} followChannel
     * @memberof UserVideoChannelInfo
     * @instance
     */
    UserVideoChannelInfo.prototype.followChannel = 0;

    /**
     * Creates a new UserVideoChannelInfo instance using the specified properties.
     * @function create
     * @memberof UserVideoChannelInfo
     * @static
     * @param {IUserVideoChannelInfo=} [properties] Properties to set
     * @returns {UserVideoChannelInfo} UserVideoChannelInfo instance
     */
    UserVideoChannelInfo.create = function create(properties) {
        return new UserVideoChannelInfo(properties);
    };

    /**
     * Encodes the specified UserVideoChannelInfo message. Does not implicitly {@link UserVideoChannelInfo.verify|verify} messages.
     * @function encode
     * @memberof UserVideoChannelInfo
     * @static
     * @param {IUserVideoChannelInfo} message UserVideoChannelInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserVideoChannelInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.manChannel != null && Object.hasOwnProperty.call(message, "manChannel"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.manChannel);
        if (message.followChannel != null && Object.hasOwnProperty.call(message, "followChannel"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.followChannel);
        return writer;
    };

    /**
     * Encodes the specified UserVideoChannelInfo message, length delimited. Does not implicitly {@link UserVideoChannelInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserVideoChannelInfo
     * @static
     * @param {IUserVideoChannelInfo} message UserVideoChannelInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserVideoChannelInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserVideoChannelInfo message from the specified reader or buffer.
     * @function decode
     * @memberof UserVideoChannelInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserVideoChannelInfo} UserVideoChannelInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserVideoChannelInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserVideoChannelInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.manChannel = reader.int32();
                    break;
                }
            case 2: {
                    message.followChannel = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserVideoChannelInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserVideoChannelInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserVideoChannelInfo} UserVideoChannelInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserVideoChannelInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserVideoChannelInfo message.
     * @function verify
     * @memberof UserVideoChannelInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserVideoChannelInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.manChannel != null && message.hasOwnProperty("manChannel"))
            if (!$util.isInteger(message.manChannel))
                return "manChannel: integer expected";
        if (message.followChannel != null && message.hasOwnProperty("followChannel"))
            if (!$util.isInteger(message.followChannel))
                return "followChannel: integer expected";
        return null;
    };

    /**
     * Creates a UserVideoChannelInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserVideoChannelInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserVideoChannelInfo} UserVideoChannelInfo
     */
    UserVideoChannelInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.UserVideoChannelInfo)
            return object;
        let message = new $root.UserVideoChannelInfo();
        if (object.manChannel != null)
            message.manChannel = object.manChannel | 0;
        if (object.followChannel != null)
            message.followChannel = object.followChannel | 0;
        return message;
    };

    /**
     * Creates a plain object from a UserVideoChannelInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserVideoChannelInfo
     * @static
     * @param {UserVideoChannelInfo} message UserVideoChannelInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserVideoChannelInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.manChannel = 0;
            object.followChannel = 0;
        }
        if (message.manChannel != null && message.hasOwnProperty("manChannel"))
            object.manChannel = message.manChannel;
        if (message.followChannel != null && message.hasOwnProperty("followChannel"))
            object.followChannel = message.followChannel;
        return object;
    };

    /**
     * Converts this UserVideoChannelInfo to JSON.
     * @function toJSON
     * @memberof UserVideoChannelInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserVideoChannelInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserVideoChannelInfo
     * @function getTypeUrl
     * @memberof UserVideoChannelInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserVideoChannelInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/UserVideoChannelInfo";
    };

    return UserVideoChannelInfo;
})();

export const UserVipInfo = $root.UserVipInfo = (() => {

    /**
     * Properties of a UserVipInfo.
     * @exports IUserVipInfo
     * @interface IUserVipInfo
     * @property {number|null} [vStatus] UserVipInfo vStatus
     * @property {number|null} [sTime] UserVipInfo sTime
     * @property {number|null} [eTime] UserVipInfo eTime
     * @property {number|null} [extScore] UserVipInfo extScore
     * @property {number|null} [vLevel] UserVipInfo vLevel
     * @property {number|null} [aScore] UserVipInfo aScore
     * @property {number|null} [nScore] UserVipInfo nScore
     * @property {string|null} [iconUrl] UserVipInfo iconUrl
     */

    /**
     * Constructs a new UserVipInfo.
     * @exports UserVipInfo
     * @classdesc Represents a UserVipInfo.
     * @implements IUserVipInfo
     * @constructor
     * @param {IUserVipInfo=} [properties] Properties to set
     */
    function UserVipInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserVipInfo vStatus.
     * @member {number} vStatus
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.vStatus = 0;

    /**
     * UserVipInfo sTime.
     * @member {number} sTime
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.sTime = 0;

    /**
     * UserVipInfo eTime.
     * @member {number} eTime
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.eTime = 0;

    /**
     * UserVipInfo extScore.
     * @member {number} extScore
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.extScore = 0;

    /**
     * UserVipInfo vLevel.
     * @member {number} vLevel
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.vLevel = 0;

    /**
     * UserVipInfo aScore.
     * @member {number} aScore
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.aScore = 0;

    /**
     * UserVipInfo nScore.
     * @member {number} nScore
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.nScore = 0;

    /**
     * UserVipInfo iconUrl.
     * @member {string} iconUrl
     * @memberof UserVipInfo
     * @instance
     */
    UserVipInfo.prototype.iconUrl = "";

    /**
     * Creates a new UserVipInfo instance using the specified properties.
     * @function create
     * @memberof UserVipInfo
     * @static
     * @param {IUserVipInfo=} [properties] Properties to set
     * @returns {UserVipInfo} UserVipInfo instance
     */
    UserVipInfo.create = function create(properties) {
        return new UserVipInfo(properties);
    };

    /**
     * Encodes the specified UserVipInfo message. Does not implicitly {@link UserVipInfo.verify|verify} messages.
     * @function encode
     * @memberof UserVipInfo
     * @static
     * @param {IUserVipInfo} message UserVipInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserVipInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.vStatus != null && Object.hasOwnProperty.call(message, "vStatus"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.vStatus);
        if (message.sTime != null && Object.hasOwnProperty.call(message, "sTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sTime);
        if (message.eTime != null && Object.hasOwnProperty.call(message, "eTime"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.eTime);
        if (message.extScore != null && Object.hasOwnProperty.call(message, "extScore"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.extScore);
        if (message.vLevel != null && Object.hasOwnProperty.call(message, "vLevel"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.vLevel);
        if (message.aScore != null && Object.hasOwnProperty.call(message, "aScore"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.aScore);
        if (message.nScore != null && Object.hasOwnProperty.call(message, "nScore"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.nScore);
        if (message.iconUrl != null && Object.hasOwnProperty.call(message, "iconUrl"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.iconUrl);
        return writer;
    };

    /**
     * Encodes the specified UserVipInfo message, length delimited. Does not implicitly {@link UserVipInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserVipInfo
     * @static
     * @param {IUserVipInfo} message UserVipInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserVipInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserVipInfo message from the specified reader or buffer.
     * @function decode
     * @memberof UserVipInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserVipInfo} UserVipInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserVipInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserVipInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.vStatus = reader.uint32();
                    break;
                }
            case 2: {
                    message.sTime = reader.uint32();
                    break;
                }
            case 3: {
                    message.eTime = reader.uint32();
                    break;
                }
            case 4: {
                    message.extScore = reader.uint32();
                    break;
                }
            case 5: {
                    message.vLevel = reader.uint32();
                    break;
                }
            case 6: {
                    message.aScore = reader.int32();
                    break;
                }
            case 7: {
                    message.nScore = reader.uint32();
                    break;
                }
            case 8: {
                    message.iconUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserVipInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserVipInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserVipInfo} UserVipInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserVipInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserVipInfo message.
     * @function verify
     * @memberof UserVipInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserVipInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.vStatus != null && message.hasOwnProperty("vStatus"))
            if (!$util.isInteger(message.vStatus))
                return "vStatus: integer expected";
        if (message.sTime != null && message.hasOwnProperty("sTime"))
            if (!$util.isInteger(message.sTime))
                return "sTime: integer expected";
        if (message.eTime != null && message.hasOwnProperty("eTime"))
            if (!$util.isInteger(message.eTime))
                return "eTime: integer expected";
        if (message.extScore != null && message.hasOwnProperty("extScore"))
            if (!$util.isInteger(message.extScore))
                return "extScore: integer expected";
        if (message.vLevel != null && message.hasOwnProperty("vLevel"))
            if (!$util.isInteger(message.vLevel))
                return "vLevel: integer expected";
        if (message.aScore != null && message.hasOwnProperty("aScore"))
            if (!$util.isInteger(message.aScore))
                return "aScore: integer expected";
        if (message.nScore != null && message.hasOwnProperty("nScore"))
            if (!$util.isInteger(message.nScore))
                return "nScore: integer expected";
        if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
            if (!$util.isString(message.iconUrl))
                return "iconUrl: string expected";
        return null;
    };

    /**
     * Creates a UserVipInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserVipInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserVipInfo} UserVipInfo
     */
    UserVipInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.UserVipInfo)
            return object;
        let message = new $root.UserVipInfo();
        if (object.vStatus != null)
            message.vStatus = object.vStatus >>> 0;
        if (object.sTime != null)
            message.sTime = object.sTime >>> 0;
        if (object.eTime != null)
            message.eTime = object.eTime >>> 0;
        if (object.extScore != null)
            message.extScore = object.extScore >>> 0;
        if (object.vLevel != null)
            message.vLevel = object.vLevel >>> 0;
        if (object.aScore != null)
            message.aScore = object.aScore | 0;
        if (object.nScore != null)
            message.nScore = object.nScore >>> 0;
        if (object.iconUrl != null)
            message.iconUrl = String(object.iconUrl);
        return message;
    };

    /**
     * Creates a plain object from a UserVipInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserVipInfo
     * @static
     * @param {UserVipInfo} message UserVipInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserVipInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.vStatus = 0;
            object.sTime = 0;
            object.eTime = 0;
            object.extScore = 0;
            object.vLevel = 0;
            object.aScore = 0;
            object.nScore = 0;
            object.iconUrl = "";
        }
        if (message.vStatus != null && message.hasOwnProperty("vStatus"))
            object.vStatus = message.vStatus;
        if (message.sTime != null && message.hasOwnProperty("sTime"))
            object.sTime = message.sTime;
        if (message.eTime != null && message.hasOwnProperty("eTime"))
            object.eTime = message.eTime;
        if (message.extScore != null && message.hasOwnProperty("extScore"))
            object.extScore = message.extScore;
        if (message.vLevel != null && message.hasOwnProperty("vLevel"))
            object.vLevel = message.vLevel;
        if (message.aScore != null && message.hasOwnProperty("aScore"))
            object.aScore = message.aScore;
        if (message.nScore != null && message.hasOwnProperty("nScore"))
            object.nScore = message.nScore;
        if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
            object.iconUrl = message.iconUrl;
        return object;
    };

    /**
     * Converts this UserVipInfo to JSON.
     * @function toJSON
     * @memberof UserVipInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserVipInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserVipInfo
     * @function getTypeUrl
     * @memberof UserVipInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserVipInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/UserVipInfo";
    };

    return UserVipInfo;
})();

export const VipCloseAd = $root.VipCloseAd = (() => {

    /**
     * Properties of a VipCloseAd.
     * @exports IVipCloseAd
     * @interface IVipCloseAd
     * @property {number|null} [isOpen] VipCloseAd isOpen
     * @property {number|null} [vipClose] VipCloseAd vipClose
     * @property {Array.<number>|null} [forumClose] VipCloseAd forumClose
     */

    /**
     * Constructs a new VipCloseAd.
     * @exports VipCloseAd
     * @classdesc Represents a VipCloseAd.
     * @implements IVipCloseAd
     * @constructor
     * @param {IVipCloseAd=} [properties] Properties to set
     */
    function VipCloseAd(properties) {
        this.forumClose = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VipCloseAd isOpen.
     * @member {number} isOpen
     * @memberof VipCloseAd
     * @instance
     */
    VipCloseAd.prototype.isOpen = 0;

    /**
     * VipCloseAd vipClose.
     * @member {number} vipClose
     * @memberof VipCloseAd
     * @instance
     */
    VipCloseAd.prototype.vipClose = 0;

    /**
     * VipCloseAd forumClose.
     * @member {Array.<number>} forumClose
     * @memberof VipCloseAd
     * @instance
     */
    VipCloseAd.prototype.forumClose = $util.emptyArray;

    /**
     * Creates a new VipCloseAd instance using the specified properties.
     * @function create
     * @memberof VipCloseAd
     * @static
     * @param {IVipCloseAd=} [properties] Properties to set
     * @returns {VipCloseAd} VipCloseAd instance
     */
    VipCloseAd.create = function create(properties) {
        return new VipCloseAd(properties);
    };

    /**
     * Encodes the specified VipCloseAd message. Does not implicitly {@link VipCloseAd.verify|verify} messages.
     * @function encode
     * @memberof VipCloseAd
     * @static
     * @param {IVipCloseAd} message VipCloseAd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VipCloseAd.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isOpen != null && Object.hasOwnProperty.call(message, "isOpen"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isOpen);
        if (message.vipClose != null && Object.hasOwnProperty.call(message, "vipClose"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.vipClose);
        if (message.forumClose != null && message.forumClose.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (let i = 0; i < message.forumClose.length; ++i)
                writer.int32(message.forumClose[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified VipCloseAd message, length delimited. Does not implicitly {@link VipCloseAd.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VipCloseAd
     * @static
     * @param {IVipCloseAd} message VipCloseAd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VipCloseAd.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VipCloseAd message from the specified reader or buffer.
     * @function decode
     * @memberof VipCloseAd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VipCloseAd} VipCloseAd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VipCloseAd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VipCloseAd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.isOpen = reader.int32();
                    break;
                }
            case 2: {
                    message.vipClose = reader.int32();
                    break;
                }
            case 3: {
                    if (!(message.forumClose && message.forumClose.length))
                        message.forumClose = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.forumClose.push(reader.int32());
                    } else
                        message.forumClose.push(reader.int32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VipCloseAd message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VipCloseAd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VipCloseAd} VipCloseAd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VipCloseAd.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VipCloseAd message.
     * @function verify
     * @memberof VipCloseAd
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VipCloseAd.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isOpen != null && message.hasOwnProperty("isOpen"))
            if (!$util.isInteger(message.isOpen))
                return "isOpen: integer expected";
        if (message.vipClose != null && message.hasOwnProperty("vipClose"))
            if (!$util.isInteger(message.vipClose))
                return "vipClose: integer expected";
        if (message.forumClose != null && message.hasOwnProperty("forumClose")) {
            if (!Array.isArray(message.forumClose))
                return "forumClose: array expected";
            for (let i = 0; i < message.forumClose.length; ++i)
                if (!$util.isInteger(message.forumClose[i]))
                    return "forumClose: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a VipCloseAd message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VipCloseAd
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VipCloseAd} VipCloseAd
     */
    VipCloseAd.fromObject = function fromObject(object) {
        if (object instanceof $root.VipCloseAd)
            return object;
        let message = new $root.VipCloseAd();
        if (object.isOpen != null)
            message.isOpen = object.isOpen | 0;
        if (object.vipClose != null)
            message.vipClose = object.vipClose | 0;
        if (object.forumClose) {
            if (!Array.isArray(object.forumClose))
                throw TypeError(".VipCloseAd.forumClose: array expected");
            message.forumClose = [];
            for (let i = 0; i < object.forumClose.length; ++i)
                message.forumClose[i] = object.forumClose[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a VipCloseAd message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VipCloseAd
     * @static
     * @param {VipCloseAd} message VipCloseAd
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VipCloseAd.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.forumClose = [];
        if (options.defaults) {
            object.isOpen = 0;
            object.vipClose = 0;
        }
        if (message.isOpen != null && message.hasOwnProperty("isOpen"))
            object.isOpen = message.isOpen;
        if (message.vipClose != null && message.hasOwnProperty("vipClose"))
            object.vipClose = message.vipClose;
        if (message.forumClose && message.forumClose.length) {
            object.forumClose = [];
            for (let j = 0; j < message.forumClose.length; ++j)
                object.forumClose[j] = message.forumClose[j];
        }
        return object;
    };

    /**
     * Converts this VipCloseAd to JSON.
     * @function toJSON
     * @memberof VipCloseAd
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VipCloseAd.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for VipCloseAd
     * @function getTypeUrl
     * @memberof VipCloseAd
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    VipCloseAd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/VipCloseAd";
    };

    return VipCloseAd;
})();

export const VipShowInfo = $root.VipShowInfo = (() => {

    /**
     * Properties of a VipShowInfo.
     * @exports IVipShowInfo
     * @interface IVipShowInfo
     * @property {string|null} [vipIcon] VipShowInfo vipIcon
     * @property {string|null} [content] VipShowInfo content
     * @property {string|null} [link] VipShowInfo link
     * @property {string|null} [title] VipShowInfo title
     */

    /**
     * Constructs a new VipShowInfo.
     * @exports VipShowInfo
     * @classdesc Represents a VipShowInfo.
     * @implements IVipShowInfo
     * @constructor
     * @param {IVipShowInfo=} [properties] Properties to set
     */
    function VipShowInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VipShowInfo vipIcon.
     * @member {string} vipIcon
     * @memberof VipShowInfo
     * @instance
     */
    VipShowInfo.prototype.vipIcon = "";

    /**
     * VipShowInfo content.
     * @member {string} content
     * @memberof VipShowInfo
     * @instance
     */
    VipShowInfo.prototype.content = "";

    /**
     * VipShowInfo link.
     * @member {string} link
     * @memberof VipShowInfo
     * @instance
     */
    VipShowInfo.prototype.link = "";

    /**
     * VipShowInfo title.
     * @member {string} title
     * @memberof VipShowInfo
     * @instance
     */
    VipShowInfo.prototype.title = "";

    /**
     * Creates a new VipShowInfo instance using the specified properties.
     * @function create
     * @memberof VipShowInfo
     * @static
     * @param {IVipShowInfo=} [properties] Properties to set
     * @returns {VipShowInfo} VipShowInfo instance
     */
    VipShowInfo.create = function create(properties) {
        return new VipShowInfo(properties);
    };

    /**
     * Encodes the specified VipShowInfo message. Does not implicitly {@link VipShowInfo.verify|verify} messages.
     * @function encode
     * @memberof VipShowInfo
     * @static
     * @param {IVipShowInfo} message VipShowInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VipShowInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.vipIcon != null && Object.hasOwnProperty.call(message, "vipIcon"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.vipIcon);
        if (message.content != null && Object.hasOwnProperty.call(message, "content"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
        if (message.link != null && Object.hasOwnProperty.call(message, "link"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.link);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.title);
        return writer;
    };

    /**
     * Encodes the specified VipShowInfo message, length delimited. Does not implicitly {@link VipShowInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VipShowInfo
     * @static
     * @param {IVipShowInfo} message VipShowInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VipShowInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VipShowInfo message from the specified reader or buffer.
     * @function decode
     * @memberof VipShowInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VipShowInfo} VipShowInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VipShowInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VipShowInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.vipIcon = reader.string();
                    break;
                }
            case 2: {
                    message.content = reader.string();
                    break;
                }
            case 3: {
                    message.link = reader.string();
                    break;
                }
            case 4: {
                    message.title = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VipShowInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VipShowInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VipShowInfo} VipShowInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VipShowInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VipShowInfo message.
     * @function verify
     * @memberof VipShowInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VipShowInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.vipIcon != null && message.hasOwnProperty("vipIcon"))
            if (!$util.isString(message.vipIcon))
                return "vipIcon: string expected";
        if (message.content != null && message.hasOwnProperty("content"))
            if (!$util.isString(message.content))
                return "content: string expected";
        if (message.link != null && message.hasOwnProperty("link"))
            if (!$util.isString(message.link))
                return "link: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        return null;
    };

    /**
     * Creates a VipShowInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VipShowInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VipShowInfo} VipShowInfo
     */
    VipShowInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.VipShowInfo)
            return object;
        let message = new $root.VipShowInfo();
        if (object.vipIcon != null)
            message.vipIcon = String(object.vipIcon);
        if (object.content != null)
            message.content = String(object.content);
        if (object.link != null)
            message.link = String(object.link);
        if (object.title != null)
            message.title = String(object.title);
        return message;
    };

    /**
     * Creates a plain object from a VipShowInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VipShowInfo
     * @static
     * @param {VipShowInfo} message VipShowInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VipShowInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.vipIcon = "";
            object.content = "";
            object.link = "";
            object.title = "";
        }
        if (message.vipIcon != null && message.hasOwnProperty("vipIcon"))
            object.vipIcon = message.vipIcon;
        if (message.content != null && message.hasOwnProperty("content"))
            object.content = message.content;
        if (message.link != null && message.hasOwnProperty("link"))
            object.link = message.link;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        return object;
    };

    /**
     * Converts this VipShowInfo to JSON.
     * @function toJSON
     * @memberof VipShowInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VipShowInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for VipShowInfo
     * @function getTypeUrl
     * @memberof VipShowInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    VipShowInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/VipShowInfo";
    };

    return VipShowInfo;
})();

export const VirtualImageInfo = $root.VirtualImageInfo = (() => {

    /**
     * Properties of a VirtualImageInfo.
     * @exports IVirtualImageInfo
     * @interface IVirtualImageInfo
     * @property {number|null} [issetVirtualImage] VirtualImageInfo issetVirtualImage
     * @property {string|null} [virtualImageUrl] VirtualImageInfo virtualImageUrl
     * @property {number|null} [imageAgreeCount] VirtualImageInfo imageAgreeCount
     * @property {number|null} [isAllowAgree] VirtualImageInfo isAllowAgree
     * @property {number|null} [virtualBackgroundType] VirtualImageInfo virtualBackgroundType
     * @property {string|null} [virtualBackground] VirtualImageInfo virtualBackground
     * @property {number|null} [recentIncrAgree] VirtualImageInfo recentIncrAgree
     * @property {number|null} [snapshootId] VirtualImageInfo snapshootId
     * @property {IStateInfo|null} [personalState] VirtualImageInfo personalState
     * @property {Array.<IStateInfo>|null} [stateList] VirtualImageInfo stateList
     * @property {number|null} [allowCustomize] VirtualImageInfo allowCustomize
     * @property {number|null} [isDisplay] VirtualImageInfo isDisplay
     * @property {number|null} [isBackgroundFirstly] VirtualImageInfo isBackgroundFirstly
     * @property {string|null} [dynamicVirtualImageUrl] VirtualImageInfo dynamicVirtualImageUrl
     */

    /**
     * Constructs a new VirtualImageInfo.
     * @exports VirtualImageInfo
     * @classdesc Represents a VirtualImageInfo.
     * @implements IVirtualImageInfo
     * @constructor
     * @param {IVirtualImageInfo=} [properties] Properties to set
     */
    function VirtualImageInfo(properties) {
        this.stateList = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VirtualImageInfo issetVirtualImage.
     * @member {number} issetVirtualImage
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.issetVirtualImage = 0;

    /**
     * VirtualImageInfo virtualImageUrl.
     * @member {string} virtualImageUrl
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.virtualImageUrl = "";

    /**
     * VirtualImageInfo imageAgreeCount.
     * @member {number} imageAgreeCount
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.imageAgreeCount = 0;

    /**
     * VirtualImageInfo isAllowAgree.
     * @member {number} isAllowAgree
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.isAllowAgree = 0;

    /**
     * VirtualImageInfo virtualBackgroundType.
     * @member {number} virtualBackgroundType
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.virtualBackgroundType = 0;

    /**
     * VirtualImageInfo virtualBackground.
     * @member {string} virtualBackground
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.virtualBackground = "";

    /**
     * VirtualImageInfo recentIncrAgree.
     * @member {number} recentIncrAgree
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.recentIncrAgree = 0;

    /**
     * VirtualImageInfo snapshootId.
     * @member {number} snapshootId
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.snapshootId = 0;

    /**
     * VirtualImageInfo personalState.
     * @member {IStateInfo|null|undefined} personalState
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.personalState = null;

    /**
     * VirtualImageInfo stateList.
     * @member {Array.<IStateInfo>} stateList
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.stateList = $util.emptyArray;

    /**
     * VirtualImageInfo allowCustomize.
     * @member {number} allowCustomize
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.allowCustomize = 0;

    /**
     * VirtualImageInfo isDisplay.
     * @member {number} isDisplay
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.isDisplay = 0;

    /**
     * VirtualImageInfo isBackgroundFirstly.
     * @member {number} isBackgroundFirstly
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.isBackgroundFirstly = 0;

    /**
     * VirtualImageInfo dynamicVirtualImageUrl.
     * @member {string} dynamicVirtualImageUrl
     * @memberof VirtualImageInfo
     * @instance
     */
    VirtualImageInfo.prototype.dynamicVirtualImageUrl = "";

    /**
     * Creates a new VirtualImageInfo instance using the specified properties.
     * @function create
     * @memberof VirtualImageInfo
     * @static
     * @param {IVirtualImageInfo=} [properties] Properties to set
     * @returns {VirtualImageInfo} VirtualImageInfo instance
     */
    VirtualImageInfo.create = function create(properties) {
        return new VirtualImageInfo(properties);
    };

    /**
     * Encodes the specified VirtualImageInfo message. Does not implicitly {@link VirtualImageInfo.verify|verify} messages.
     * @function encode
     * @memberof VirtualImageInfo
     * @static
     * @param {IVirtualImageInfo} message VirtualImageInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VirtualImageInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.issetVirtualImage != null && Object.hasOwnProperty.call(message, "issetVirtualImage"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.issetVirtualImage);
        if (message.virtualImageUrl != null && Object.hasOwnProperty.call(message, "virtualImageUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.virtualImageUrl);
        if (message.imageAgreeCount != null && Object.hasOwnProperty.call(message, "imageAgreeCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.imageAgreeCount);
        if (message.isAllowAgree != null && Object.hasOwnProperty.call(message, "isAllowAgree"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.isAllowAgree);
        if (message.virtualBackgroundType != null && Object.hasOwnProperty.call(message, "virtualBackgroundType"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.virtualBackgroundType);
        if (message.virtualBackground != null && Object.hasOwnProperty.call(message, "virtualBackground"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.virtualBackground);
        if (message.recentIncrAgree != null && Object.hasOwnProperty.call(message, "recentIncrAgree"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.recentIncrAgree);
        if (message.snapshootId != null && Object.hasOwnProperty.call(message, "snapshootId"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.snapshootId);
        if (message.personalState != null && Object.hasOwnProperty.call(message, "personalState"))
            $root.StateInfo.encode(message.personalState, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.stateList != null && message.stateList.length)
            for (let i = 0; i < message.stateList.length; ++i)
                $root.StateInfo.encode(message.stateList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.allowCustomize != null && Object.hasOwnProperty.call(message, "allowCustomize"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.allowCustomize);
        if (message.isDisplay != null && Object.hasOwnProperty.call(message, "isDisplay"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.isDisplay);
        if (message.isBackgroundFirstly != null && Object.hasOwnProperty.call(message, "isBackgroundFirstly"))
            writer.uint32(/* id 13, wireType 0 =*/104).int32(message.isBackgroundFirstly);
        if (message.dynamicVirtualImageUrl != null && Object.hasOwnProperty.call(message, "dynamicVirtualImageUrl"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.dynamicVirtualImageUrl);
        return writer;
    };

    /**
     * Encodes the specified VirtualImageInfo message, length delimited. Does not implicitly {@link VirtualImageInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VirtualImageInfo
     * @static
     * @param {IVirtualImageInfo} message VirtualImageInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VirtualImageInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VirtualImageInfo message from the specified reader or buffer.
     * @function decode
     * @memberof VirtualImageInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VirtualImageInfo} VirtualImageInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VirtualImageInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VirtualImageInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.issetVirtualImage = reader.int32();
                    break;
                }
            case 2: {
                    message.virtualImageUrl = reader.string();
                    break;
                }
            case 3: {
                    message.imageAgreeCount = reader.int32();
                    break;
                }
            case 4: {
                    message.isAllowAgree = reader.int32();
                    break;
                }
            case 5: {
                    message.virtualBackgroundType = reader.int32();
                    break;
                }
            case 6: {
                    message.virtualBackground = reader.string();
                    break;
                }
            case 7: {
                    message.recentIncrAgree = reader.int32();
                    break;
                }
            case 8: {
                    message.snapshootId = reader.int32();
                    break;
                }
            case 9: {
                    message.personalState = $root.StateInfo.decode(reader, reader.uint32());
                    break;
                }
            case 10: {
                    if (!(message.stateList && message.stateList.length))
                        message.stateList = [];
                    message.stateList.push($root.StateInfo.decode(reader, reader.uint32()));
                    break;
                }
            case 11: {
                    message.allowCustomize = reader.int32();
                    break;
                }
            case 12: {
                    message.isDisplay = reader.int32();
                    break;
                }
            case 13: {
                    message.isBackgroundFirstly = reader.int32();
                    break;
                }
            case 14: {
                    message.dynamicVirtualImageUrl = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VirtualImageInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VirtualImageInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VirtualImageInfo} VirtualImageInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VirtualImageInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VirtualImageInfo message.
     * @function verify
     * @memberof VirtualImageInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VirtualImageInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.issetVirtualImage != null && message.hasOwnProperty("issetVirtualImage"))
            if (!$util.isInteger(message.issetVirtualImage))
                return "issetVirtualImage: integer expected";
        if (message.virtualImageUrl != null && message.hasOwnProperty("virtualImageUrl"))
            if (!$util.isString(message.virtualImageUrl))
                return "virtualImageUrl: string expected";
        if (message.imageAgreeCount != null && message.hasOwnProperty("imageAgreeCount"))
            if (!$util.isInteger(message.imageAgreeCount))
                return "imageAgreeCount: integer expected";
        if (message.isAllowAgree != null && message.hasOwnProperty("isAllowAgree"))
            if (!$util.isInteger(message.isAllowAgree))
                return "isAllowAgree: integer expected";
        if (message.virtualBackgroundType != null && message.hasOwnProperty("virtualBackgroundType"))
            if (!$util.isInteger(message.virtualBackgroundType))
                return "virtualBackgroundType: integer expected";
        if (message.virtualBackground != null && message.hasOwnProperty("virtualBackground"))
            if (!$util.isString(message.virtualBackground))
                return "virtualBackground: string expected";
        if (message.recentIncrAgree != null && message.hasOwnProperty("recentIncrAgree"))
            if (!$util.isInteger(message.recentIncrAgree))
                return "recentIncrAgree: integer expected";
        if (message.snapshootId != null && message.hasOwnProperty("snapshootId"))
            if (!$util.isInteger(message.snapshootId))
                return "snapshootId: integer expected";
        if (message.personalState != null && message.hasOwnProperty("personalState")) {
            let error = $root.StateInfo.verify(message.personalState);
            if (error)
                return "personalState." + error;
        }
        if (message.stateList != null && message.hasOwnProperty("stateList")) {
            if (!Array.isArray(message.stateList))
                return "stateList: array expected";
            for (let i = 0; i < message.stateList.length; ++i) {
                let error = $root.StateInfo.verify(message.stateList[i]);
                if (error)
                    return "stateList." + error;
            }
        }
        if (message.allowCustomize != null && message.hasOwnProperty("allowCustomize"))
            if (!$util.isInteger(message.allowCustomize))
                return "allowCustomize: integer expected";
        if (message.isDisplay != null && message.hasOwnProperty("isDisplay"))
            if (!$util.isInteger(message.isDisplay))
                return "isDisplay: integer expected";
        if (message.isBackgroundFirstly != null && message.hasOwnProperty("isBackgroundFirstly"))
            if (!$util.isInteger(message.isBackgroundFirstly))
                return "isBackgroundFirstly: integer expected";
        if (message.dynamicVirtualImageUrl != null && message.hasOwnProperty("dynamicVirtualImageUrl"))
            if (!$util.isString(message.dynamicVirtualImageUrl))
                return "dynamicVirtualImageUrl: string expected";
        return null;
    };

    /**
     * Creates a VirtualImageInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VirtualImageInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VirtualImageInfo} VirtualImageInfo
     */
    VirtualImageInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.VirtualImageInfo)
            return object;
        let message = new $root.VirtualImageInfo();
        if (object.issetVirtualImage != null)
            message.issetVirtualImage = object.issetVirtualImage | 0;
        if (object.virtualImageUrl != null)
            message.virtualImageUrl = String(object.virtualImageUrl);
        if (object.imageAgreeCount != null)
            message.imageAgreeCount = object.imageAgreeCount | 0;
        if (object.isAllowAgree != null)
            message.isAllowAgree = object.isAllowAgree | 0;
        if (object.virtualBackgroundType != null)
            message.virtualBackgroundType = object.virtualBackgroundType | 0;
        if (object.virtualBackground != null)
            message.virtualBackground = String(object.virtualBackground);
        if (object.recentIncrAgree != null)
            message.recentIncrAgree = object.recentIncrAgree | 0;
        if (object.snapshootId != null)
            message.snapshootId = object.snapshootId | 0;
        if (object.personalState != null) {
            if (typeof object.personalState !== "object")
                throw TypeError(".VirtualImageInfo.personalState: object expected");
            message.personalState = $root.StateInfo.fromObject(object.personalState);
        }
        if (object.stateList) {
            if (!Array.isArray(object.stateList))
                throw TypeError(".VirtualImageInfo.stateList: array expected");
            message.stateList = [];
            for (let i = 0; i < object.stateList.length; ++i) {
                if (typeof object.stateList[i] !== "object")
                    throw TypeError(".VirtualImageInfo.stateList: object expected");
                message.stateList[i] = $root.StateInfo.fromObject(object.stateList[i]);
            }
        }
        if (object.allowCustomize != null)
            message.allowCustomize = object.allowCustomize | 0;
        if (object.isDisplay != null)
            message.isDisplay = object.isDisplay | 0;
        if (object.isBackgroundFirstly != null)
            message.isBackgroundFirstly = object.isBackgroundFirstly | 0;
        if (object.dynamicVirtualImageUrl != null)
            message.dynamicVirtualImageUrl = String(object.dynamicVirtualImageUrl);
        return message;
    };

    /**
     * Creates a plain object from a VirtualImageInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VirtualImageInfo
     * @static
     * @param {VirtualImageInfo} message VirtualImageInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VirtualImageInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.stateList = [];
        if (options.defaults) {
            object.issetVirtualImage = 0;
            object.virtualImageUrl = "";
            object.imageAgreeCount = 0;
            object.isAllowAgree = 0;
            object.virtualBackgroundType = 0;
            object.virtualBackground = "";
            object.recentIncrAgree = 0;
            object.snapshootId = 0;
            object.personalState = null;
            object.allowCustomize = 0;
            object.isDisplay = 0;
            object.isBackgroundFirstly = 0;
            object.dynamicVirtualImageUrl = "";
        }
        if (message.issetVirtualImage != null && message.hasOwnProperty("issetVirtualImage"))
            object.issetVirtualImage = message.issetVirtualImage;
        if (message.virtualImageUrl != null && message.hasOwnProperty("virtualImageUrl"))
            object.virtualImageUrl = message.virtualImageUrl;
        if (message.imageAgreeCount != null && message.hasOwnProperty("imageAgreeCount"))
            object.imageAgreeCount = message.imageAgreeCount;
        if (message.isAllowAgree != null && message.hasOwnProperty("isAllowAgree"))
            object.isAllowAgree = message.isAllowAgree;
        if (message.virtualBackgroundType != null && message.hasOwnProperty("virtualBackgroundType"))
            object.virtualBackgroundType = message.virtualBackgroundType;
        if (message.virtualBackground != null && message.hasOwnProperty("virtualBackground"))
            object.virtualBackground = message.virtualBackground;
        if (message.recentIncrAgree != null && message.hasOwnProperty("recentIncrAgree"))
            object.recentIncrAgree = message.recentIncrAgree;
        if (message.snapshootId != null && message.hasOwnProperty("snapshootId"))
            object.snapshootId = message.snapshootId;
        if (message.personalState != null && message.hasOwnProperty("personalState"))
            object.personalState = $root.StateInfo.toObject(message.personalState, options);
        if (message.stateList && message.stateList.length) {
            object.stateList = [];
            for (let j = 0; j < message.stateList.length; ++j)
                object.stateList[j] = $root.StateInfo.toObject(message.stateList[j], options);
        }
        if (message.allowCustomize != null && message.hasOwnProperty("allowCustomize"))
            object.allowCustomize = message.allowCustomize;
        if (message.isDisplay != null && message.hasOwnProperty("isDisplay"))
            object.isDisplay = message.isDisplay;
        if (message.isBackgroundFirstly != null && message.hasOwnProperty("isBackgroundFirstly"))
            object.isBackgroundFirstly = message.isBackgroundFirstly;
        if (message.dynamicVirtualImageUrl != null && message.hasOwnProperty("dynamicVirtualImageUrl"))
            object.dynamicVirtualImageUrl = message.dynamicVirtualImageUrl;
        return object;
    };

    /**
     * Converts this VirtualImageInfo to JSON.
     * @function toJSON
     * @memberof VirtualImageInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VirtualImageInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for VirtualImageInfo
     * @function getTypeUrl
     * @memberof VirtualImageInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    VirtualImageInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/VirtualImageInfo";
    };

    return VirtualImageInfo;
})();

export const StateInfo = $root.StateInfo = (() => {

    /**
     * Properties of a StateInfo.
     * @exports IStateInfo
     * @interface IStateInfo
     * @property {string|null} [icon] StateInfo icon
     * @property {string|null} [text] StateInfo text
     * @property {number|null} [iconType] StateInfo iconType
     * @property {number|null} [iconPid] StateInfo iconPid
     * @property {number|Long|null} [iconPidNew] StateInfo iconPidNew
     */

    /**
     * Constructs a new StateInfo.
     * @exports StateInfo
     * @classdesc Represents a StateInfo.
     * @implements IStateInfo
     * @constructor
     * @param {IStateInfo=} [properties] Properties to set
     */
    function StateInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StateInfo icon.
     * @member {string} icon
     * @memberof StateInfo
     * @instance
     */
    StateInfo.prototype.icon = "";

    /**
     * StateInfo text.
     * @member {string} text
     * @memberof StateInfo
     * @instance
     */
    StateInfo.prototype.text = "";

    /**
     * StateInfo iconType.
     * @member {number} iconType
     * @memberof StateInfo
     * @instance
     */
    StateInfo.prototype.iconType = 0;

    /**
     * StateInfo iconPid.
     * @member {number} iconPid
     * @memberof StateInfo
     * @instance
     */
    StateInfo.prototype.iconPid = 0;

    /**
     * StateInfo iconPidNew.
     * @member {number|Long} iconPidNew
     * @memberof StateInfo
     * @instance
     */
    StateInfo.prototype.iconPidNew = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new StateInfo instance using the specified properties.
     * @function create
     * @memberof StateInfo
     * @static
     * @param {IStateInfo=} [properties] Properties to set
     * @returns {StateInfo} StateInfo instance
     */
    StateInfo.create = function create(properties) {
        return new StateInfo(properties);
    };

    /**
     * Encodes the specified StateInfo message. Does not implicitly {@link StateInfo.verify|verify} messages.
     * @function encode
     * @memberof StateInfo
     * @static
     * @param {IStateInfo} message StateInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StateInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.icon);
        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
        if (message.iconType != null && Object.hasOwnProperty.call(message, "iconType"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.iconType);
        if (message.iconPid != null && Object.hasOwnProperty.call(message, "iconPid"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.iconPid);
        if (message.iconPidNew != null && Object.hasOwnProperty.call(message, "iconPidNew"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.iconPidNew);
        return writer;
    };

    /**
     * Encodes the specified StateInfo message, length delimited. Does not implicitly {@link StateInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StateInfo
     * @static
     * @param {IStateInfo} message StateInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StateInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StateInfo message from the specified reader or buffer.
     * @function decode
     * @memberof StateInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StateInfo} StateInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StateInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StateInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.icon = reader.string();
                    break;
                }
            case 2: {
                    message.text = reader.string();
                    break;
                }
            case 3: {
                    message.iconType = reader.int32();
                    break;
                }
            case 4: {
                    message.iconPid = reader.int32();
                    break;
                }
            case 5: {
                    message.iconPidNew = reader.int64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StateInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StateInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StateInfo} StateInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StateInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StateInfo message.
     * @function verify
     * @memberof StateInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StateInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.icon != null && message.hasOwnProperty("icon"))
            if (!$util.isString(message.icon))
                return "icon: string expected";
        if (message.text != null && message.hasOwnProperty("text"))
            if (!$util.isString(message.text))
                return "text: string expected";
        if (message.iconType != null && message.hasOwnProperty("iconType"))
            if (!$util.isInteger(message.iconType))
                return "iconType: integer expected";
        if (message.iconPid != null && message.hasOwnProperty("iconPid"))
            if (!$util.isInteger(message.iconPid))
                return "iconPid: integer expected";
        if (message.iconPidNew != null && message.hasOwnProperty("iconPidNew"))
            if (!$util.isInteger(message.iconPidNew) && !(message.iconPidNew && $util.isInteger(message.iconPidNew.low) && $util.isInteger(message.iconPidNew.high)))
                return "iconPidNew: integer|Long expected";
        return null;
    };

    /**
     * Creates a StateInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StateInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StateInfo} StateInfo
     */
    StateInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.StateInfo)
            return object;
        let message = new $root.StateInfo();
        if (object.icon != null)
            message.icon = String(object.icon);
        if (object.text != null)
            message.text = String(object.text);
        if (object.iconType != null)
            message.iconType = object.iconType | 0;
        if (object.iconPid != null)
            message.iconPid = object.iconPid | 0;
        if (object.iconPidNew != null)
            if ($util.Long)
                (message.iconPidNew = $util.Long.fromValue(object.iconPidNew)).unsigned = false;
            else if (typeof object.iconPidNew === "string")
                message.iconPidNew = parseInt(object.iconPidNew, 10);
            else if (typeof object.iconPidNew === "number")
                message.iconPidNew = object.iconPidNew;
            else if (typeof object.iconPidNew === "object")
                message.iconPidNew = new $util.LongBits(object.iconPidNew.low >>> 0, object.iconPidNew.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a StateInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StateInfo
     * @static
     * @param {StateInfo} message StateInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StateInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.icon = "";
            object.text = "";
            object.iconType = 0;
            object.iconPid = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.iconPidNew = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.iconPidNew = options.longs === String ? "0" : 0;
        }
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = message.icon;
        if (message.text != null && message.hasOwnProperty("text"))
            object.text = message.text;
        if (message.iconType != null && message.hasOwnProperty("iconType"))
            object.iconType = message.iconType;
        if (message.iconPid != null && message.hasOwnProperty("iconPid"))
            object.iconPid = message.iconPid;
        if (message.iconPidNew != null && message.hasOwnProperty("iconPidNew"))
            if (typeof message.iconPidNew === "number")
                object.iconPidNew = options.longs === String ? String(message.iconPidNew) : message.iconPidNew;
            else
                object.iconPidNew = options.longs === String ? $util.Long.prototype.toString.call(message.iconPidNew) : options.longs === Number ? new $util.LongBits(message.iconPidNew.low >>> 0, message.iconPidNew.high >>> 0).toNumber() : message.iconPidNew;
        return object;
    };

    /**
     * Converts this StateInfo to JSON.
     * @function toJSON
     * @memberof StateInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StateInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for StateInfo
     * @function getTypeUrl
     * @memberof StateInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    StateInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/StateInfo";
    };

    return StateInfo;
})();

export const WorkCreatorInfo = $root.WorkCreatorInfo = (() => {

    /**
     * Properties of a WorkCreatorInfo.
     * @exports IWorkCreatorInfo
     * @interface IWorkCreatorInfo
     * @property {string|null} [authDesc] WorkCreatorInfo authDesc
     */

    /**
     * Constructs a new WorkCreatorInfo.
     * @exports WorkCreatorInfo
     * @classdesc Represents a WorkCreatorInfo.
     * @implements IWorkCreatorInfo
     * @constructor
     * @param {IWorkCreatorInfo=} [properties] Properties to set
     */
    function WorkCreatorInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WorkCreatorInfo authDesc.
     * @member {string} authDesc
     * @memberof WorkCreatorInfo
     * @instance
     */
    WorkCreatorInfo.prototype.authDesc = "";

    /**
     * Creates a new WorkCreatorInfo instance using the specified properties.
     * @function create
     * @memberof WorkCreatorInfo
     * @static
     * @param {IWorkCreatorInfo=} [properties] Properties to set
     * @returns {WorkCreatorInfo} WorkCreatorInfo instance
     */
    WorkCreatorInfo.create = function create(properties) {
        return new WorkCreatorInfo(properties);
    };

    /**
     * Encodes the specified WorkCreatorInfo message. Does not implicitly {@link WorkCreatorInfo.verify|verify} messages.
     * @function encode
     * @memberof WorkCreatorInfo
     * @static
     * @param {IWorkCreatorInfo} message WorkCreatorInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WorkCreatorInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.authDesc != null && Object.hasOwnProperty.call(message, "authDesc"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.authDesc);
        return writer;
    };

    /**
     * Encodes the specified WorkCreatorInfo message, length delimited. Does not implicitly {@link WorkCreatorInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WorkCreatorInfo
     * @static
     * @param {IWorkCreatorInfo} message WorkCreatorInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WorkCreatorInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WorkCreatorInfo message from the specified reader or buffer.
     * @function decode
     * @memberof WorkCreatorInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WorkCreatorInfo} WorkCreatorInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WorkCreatorInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WorkCreatorInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.authDesc = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WorkCreatorInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WorkCreatorInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WorkCreatorInfo} WorkCreatorInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WorkCreatorInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WorkCreatorInfo message.
     * @function verify
     * @memberof WorkCreatorInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WorkCreatorInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.authDesc != null && message.hasOwnProperty("authDesc"))
            if (!$util.isString(message.authDesc))
                return "authDesc: string expected";
        return null;
    };

    /**
     * Creates a WorkCreatorInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WorkCreatorInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WorkCreatorInfo} WorkCreatorInfo
     */
    WorkCreatorInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.WorkCreatorInfo)
            return object;
        let message = new $root.WorkCreatorInfo();
        if (object.authDesc != null)
            message.authDesc = String(object.authDesc);
        return message;
    };

    /**
     * Creates a plain object from a WorkCreatorInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WorkCreatorInfo
     * @static
     * @param {WorkCreatorInfo} message WorkCreatorInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WorkCreatorInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.authDesc = "";
        if (message.authDesc != null && message.hasOwnProperty("authDesc"))
            object.authDesc = message.authDesc;
        return object;
    };

    /**
     * Converts this WorkCreatorInfo to JSON.
     * @function toJSON
     * @memberof WorkCreatorInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WorkCreatorInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for WorkCreatorInfo
     * @function getTypeUrl
     * @memberof WorkCreatorInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    WorkCreatorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/WorkCreatorInfo";
    };

    return WorkCreatorInfo;
})();

export { $root as default };
