/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const tieba = $root.tieba = (() => {

    /**
     * Namespace tieba.
     * @exports tieba
     * @namespace
     */
    const tieba = {};

    tieba.userPost = (function() {

        /**
         * Namespace userPost.
         * @memberof tieba
         * @namespace
         */
        const userPost = {};

        userPost.UserPostResponse = (function() {

            /**
             * Properties of a UserPostResponse.
             * @memberof tieba.userPost
             * @interface IUserPostResponse
             * @property {tieba.IError|null} [error] UserPostResponse error
             * @property {tieba.userPost.IUserPostResponseData|null} [data] UserPostResponse data
             */

            /**
             * Constructs a new UserPostResponse.
             * @memberof tieba.userPost
             * @classdesc Represents a UserPostResponse.
             * @implements IUserPostResponse
             * @constructor
             * @param {tieba.userPost.IUserPostResponse=} [properties] Properties to set
             */
            function UserPostResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserPostResponse error.
             * @member {tieba.IError|null|undefined} error
             * @memberof tieba.userPost.UserPostResponse
             * @instance
             */
            UserPostResponse.prototype.error = null;

            /**
             * UserPostResponse data.
             * @member {tieba.userPost.IUserPostResponseData|null|undefined} data
             * @memberof tieba.userPost.UserPostResponse
             * @instance
             */
            UserPostResponse.prototype.data = null;

            /**
             * Creates a new UserPostResponse instance using the specified properties.
             * @function create
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {tieba.userPost.IUserPostResponse=} [properties] Properties to set
             * @returns {tieba.userPost.UserPostResponse} UserPostResponse instance
             */
            UserPostResponse.create = function create(properties) {
                return new UserPostResponse(properties);
            };

            /**
             * Encodes the specified UserPostResponse message. Does not implicitly {@link tieba.userPost.UserPostResponse.verify|verify} messages.
             * @function encode
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {tieba.userPost.IUserPostResponse} message UserPostResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserPostResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    $root.tieba.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.tieba.userPost.UserPostResponseData.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UserPostResponse message, length delimited. Does not implicitly {@link tieba.userPost.UserPostResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {tieba.userPost.IUserPostResponse} message UserPostResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserPostResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserPostResponse message from the specified reader or buffer.
             * @function decode
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tieba.userPost.UserPostResponse} UserPostResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserPostResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.userPost.UserPostResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.error = $root.tieba.Error.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.data = $root.tieba.userPost.UserPostResponseData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserPostResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tieba.userPost.UserPostResponse} UserPostResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserPostResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserPostResponse message.
             * @function verify
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserPostResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.error != null && message.hasOwnProperty("error")) {
                    let error = $root.tieba.Error.verify(message.error);
                    if (error)
                        return "error." + error;
                }
                if (message.data != null && message.hasOwnProperty("data")) {
                    let error = $root.tieba.userPost.UserPostResponseData.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                return null;
            };

            /**
             * Creates a UserPostResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tieba.userPost.UserPostResponse} UserPostResponse
             */
            UserPostResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.tieba.userPost.UserPostResponse)
                    return object;
                let message = new $root.tieba.userPost.UserPostResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".tieba.userPost.UserPostResponse.error: object expected");
                    message.error = $root.tieba.Error.fromObject(object.error);
                }
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".tieba.userPost.UserPostResponse.data: object expected");
                    message.data = $root.tieba.userPost.UserPostResponseData.fromObject(object.data);
                }
                return message;
            };

            /**
             * Creates a plain object from a UserPostResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {tieba.userPost.UserPostResponse} message UserPostResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserPostResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.error = null;
                    object.data = null;
                }
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = $root.tieba.Error.toObject(message.error, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.tieba.userPost.UserPostResponseData.toObject(message.data, options);
                return object;
            };

            /**
             * Converts this UserPostResponse to JSON.
             * @function toJSON
             * @memberof tieba.userPost.UserPostResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserPostResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserPostResponse
             * @function getTypeUrl
             * @memberof tieba.userPost.UserPostResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserPostResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/tieba.userPost.UserPostResponse";
            };

            return UserPostResponse;
        })();

        userPost.UserPostResponseData = (function() {

            /**
             * Properties of a UserPostResponseData.
             * @memberof tieba.userPost
             * @interface IUserPostResponseData
             * @property {Array.<tieba.IPostInfoList>|null} [postList] UserPostResponseData postList
             * @property {number|null} [hidePost] UserPostResponseData hidePost
             * @property {number|Long|null} [time] UserPostResponseData time
             * @property {number|Long|null} [ctime] UserPostResponseData ctime
             * @property {number|Long|null} [logid] UserPostResponseData logid
             * @property {number|null} [maskType] UserPostResponseData maskType
             * @property {number|null} [viewCardNum] UserPostResponseData viewCardNum
             * @property {number|null} [reddotDeletedThread] UserPostResponseData reddotDeletedThread
             */

            /**
             * Constructs a new UserPostResponseData.
             * @memberof tieba.userPost
             * @classdesc Represents a UserPostResponseData.
             * @implements IUserPostResponseData
             * @constructor
             * @param {tieba.userPost.IUserPostResponseData=} [properties] Properties to set
             */
            function UserPostResponseData(properties) {
                this.postList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserPostResponseData postList.
             * @member {Array.<tieba.IPostInfoList>} postList
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.postList = $util.emptyArray;

            /**
             * UserPostResponseData hidePost.
             * @member {number} hidePost
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.hidePost = 0;

            /**
             * UserPostResponseData time.
             * @member {number|Long} time
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UserPostResponseData ctime.
             * @member {number|Long} ctime
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.ctime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UserPostResponseData logid.
             * @member {number|Long} logid
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.logid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UserPostResponseData maskType.
             * @member {number} maskType
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.maskType = 0;

            /**
             * UserPostResponseData viewCardNum.
             * @member {number} viewCardNum
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.viewCardNum = 0;

            /**
             * UserPostResponseData reddotDeletedThread.
             * @member {number} reddotDeletedThread
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             */
            UserPostResponseData.prototype.reddotDeletedThread = 0;

            /**
             * Creates a new UserPostResponseData instance using the specified properties.
             * @function create
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {tieba.userPost.IUserPostResponseData=} [properties] Properties to set
             * @returns {tieba.userPost.UserPostResponseData} UserPostResponseData instance
             */
            UserPostResponseData.create = function create(properties) {
                return new UserPostResponseData(properties);
            };

            /**
             * Encodes the specified UserPostResponseData message. Does not implicitly {@link tieba.userPost.UserPostResponseData.verify|verify} messages.
             * @function encode
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {tieba.userPost.IUserPostResponseData} message UserPostResponseData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserPostResponseData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.postList != null && message.postList.length)
                    for (let i = 0; i < message.postList.length; ++i)
                        $root.tieba.PostInfoList.encode(message.postList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.hidePost != null && Object.hasOwnProperty.call(message, "hidePost"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hidePost);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.time);
                if (message.ctime != null && Object.hasOwnProperty.call(message, "ctime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.ctime);
                if (message.logid != null && Object.hasOwnProperty.call(message, "logid"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.logid);
                if (message.maskType != null && Object.hasOwnProperty.call(message, "maskType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maskType);
                if (message.viewCardNum != null && Object.hasOwnProperty.call(message, "viewCardNum"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.viewCardNum);
                if (message.reddotDeletedThread != null && Object.hasOwnProperty.call(message, "reddotDeletedThread"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.reddotDeletedThread);
                return writer;
            };

            /**
             * Encodes the specified UserPostResponseData message, length delimited. Does not implicitly {@link tieba.userPost.UserPostResponseData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {tieba.userPost.IUserPostResponseData} message UserPostResponseData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserPostResponseData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserPostResponseData message from the specified reader or buffer.
             * @function decode
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tieba.userPost.UserPostResponseData} UserPostResponseData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserPostResponseData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.userPost.UserPostResponseData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.postList && message.postList.length))
                                message.postList = [];
                            message.postList.push($root.tieba.PostInfoList.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.hidePost = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.time = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.ctime = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.logid = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.maskType = reader.int32();
                            break;
                        }
                    case 7: {
                            message.viewCardNum = reader.int32();
                            break;
                        }
                    case 8: {
                            message.reddotDeletedThread = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserPostResponseData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tieba.userPost.UserPostResponseData} UserPostResponseData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserPostResponseData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserPostResponseData message.
             * @function verify
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserPostResponseData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.postList != null && message.hasOwnProperty("postList")) {
                    if (!Array.isArray(message.postList))
                        return "postList: array expected";
                    for (let i = 0; i < message.postList.length; ++i) {
                        let error = $root.tieba.PostInfoList.verify(message.postList[i]);
                        if (error)
                            return "postList." + error;
                    }
                }
                if (message.hidePost != null && message.hasOwnProperty("hidePost"))
                    if (!$util.isInteger(message.hidePost))
                        return "hidePost: integer expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                        return "time: integer|Long expected";
                if (message.ctime != null && message.hasOwnProperty("ctime"))
                    if (!$util.isInteger(message.ctime) && !(message.ctime && $util.isInteger(message.ctime.low) && $util.isInteger(message.ctime.high)))
                        return "ctime: integer|Long expected";
                if (message.logid != null && message.hasOwnProperty("logid"))
                    if (!$util.isInteger(message.logid) && !(message.logid && $util.isInteger(message.logid.low) && $util.isInteger(message.logid.high)))
                        return "logid: integer|Long expected";
                if (message.maskType != null && message.hasOwnProperty("maskType"))
                    if (!$util.isInteger(message.maskType))
                        return "maskType: integer expected";
                if (message.viewCardNum != null && message.hasOwnProperty("viewCardNum"))
                    if (!$util.isInteger(message.viewCardNum))
                        return "viewCardNum: integer expected";
                if (message.reddotDeletedThread != null && message.hasOwnProperty("reddotDeletedThread"))
                    if (!$util.isInteger(message.reddotDeletedThread))
                        return "reddotDeletedThread: integer expected";
                return null;
            };

            /**
             * Creates a UserPostResponseData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tieba.userPost.UserPostResponseData} UserPostResponseData
             */
            UserPostResponseData.fromObject = function fromObject(object) {
                if (object instanceof $root.tieba.userPost.UserPostResponseData)
                    return object;
                let message = new $root.tieba.userPost.UserPostResponseData();
                if (object.postList) {
                    if (!Array.isArray(object.postList))
                        throw TypeError(".tieba.userPost.UserPostResponseData.postList: array expected");
                    message.postList = [];
                    for (let i = 0; i < object.postList.length; ++i) {
                        if (typeof object.postList[i] !== "object")
                            throw TypeError(".tieba.userPost.UserPostResponseData.postList: object expected");
                        message.postList[i] = $root.tieba.PostInfoList.fromObject(object.postList[i]);
                    }
                }
                if (object.hidePost != null)
                    message.hidePost = object.hidePost >>> 0;
                if (object.time != null)
                    if ($util.Long)
                        (message.time = $util.Long.fromValue(object.time)).unsigned = true;
                    else if (typeof object.time === "string")
                        message.time = parseInt(object.time, 10);
                    else if (typeof object.time === "number")
                        message.time = object.time;
                    else if (typeof object.time === "object")
                        message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber(true);
                if (object.ctime != null)
                    if ($util.Long)
                        (message.ctime = $util.Long.fromValue(object.ctime)).unsigned = true;
                    else if (typeof object.ctime === "string")
                        message.ctime = parseInt(object.ctime, 10);
                    else if (typeof object.ctime === "number")
                        message.ctime = object.ctime;
                    else if (typeof object.ctime === "object")
                        message.ctime = new $util.LongBits(object.ctime.low >>> 0, object.ctime.high >>> 0).toNumber(true);
                if (object.logid != null)
                    if ($util.Long)
                        (message.logid = $util.Long.fromValue(object.logid)).unsigned = true;
                    else if (typeof object.logid === "string")
                        message.logid = parseInt(object.logid, 10);
                    else if (typeof object.logid === "number")
                        message.logid = object.logid;
                    else if (typeof object.logid === "object")
                        message.logid = new $util.LongBits(object.logid.low >>> 0, object.logid.high >>> 0).toNumber(true);
                if (object.maskType != null)
                    message.maskType = object.maskType | 0;
                if (object.viewCardNum != null)
                    message.viewCardNum = object.viewCardNum | 0;
                if (object.reddotDeletedThread != null)
                    message.reddotDeletedThread = object.reddotDeletedThread | 0;
                return message;
            };

            /**
             * Creates a plain object from a UserPostResponseData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {tieba.userPost.UserPostResponseData} message UserPostResponseData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserPostResponseData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.postList = [];
                if (options.defaults) {
                    object.hidePost = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.time = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.ctime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ctime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.logid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.logid = options.longs === String ? "0" : 0;
                    object.maskType = 0;
                    object.viewCardNum = 0;
                    object.reddotDeletedThread = 0;
                }
                if (message.postList && message.postList.length) {
                    object.postList = [];
                    for (let j = 0; j < message.postList.length; ++j)
                        object.postList[j] = $root.tieba.PostInfoList.toObject(message.postList[j], options);
                }
                if (message.hidePost != null && message.hasOwnProperty("hidePost"))
                    object.hidePost = message.hidePost;
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time === "number")
                        object.time = options.longs === String ? String(message.time) : message.time;
                    else
                        object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber(true) : message.time;
                if (message.ctime != null && message.hasOwnProperty("ctime"))
                    if (typeof message.ctime === "number")
                        object.ctime = options.longs === String ? String(message.ctime) : message.ctime;
                    else
                        object.ctime = options.longs === String ? $util.Long.prototype.toString.call(message.ctime) : options.longs === Number ? new $util.LongBits(message.ctime.low >>> 0, message.ctime.high >>> 0).toNumber(true) : message.ctime;
                if (message.logid != null && message.hasOwnProperty("logid"))
                    if (typeof message.logid === "number")
                        object.logid = options.longs === String ? String(message.logid) : message.logid;
                    else
                        object.logid = options.longs === String ? $util.Long.prototype.toString.call(message.logid) : options.longs === Number ? new $util.LongBits(message.logid.low >>> 0, message.logid.high >>> 0).toNumber(true) : message.logid;
                if (message.maskType != null && message.hasOwnProperty("maskType"))
                    object.maskType = message.maskType;
                if (message.viewCardNum != null && message.hasOwnProperty("viewCardNum"))
                    object.viewCardNum = message.viewCardNum;
                if (message.reddotDeletedThread != null && message.hasOwnProperty("reddotDeletedThread"))
                    object.reddotDeletedThread = message.reddotDeletedThread;
                return object;
            };

            /**
             * Converts this UserPostResponseData to JSON.
             * @function toJSON
             * @memberof tieba.userPost.UserPostResponseData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserPostResponseData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserPostResponseData
             * @function getTypeUrl
             * @memberof tieba.userPost.UserPostResponseData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserPostResponseData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/tieba.userPost.UserPostResponseData";
            };

            return UserPostResponseData;
        })();

        return userPost;
    })();

    tieba.Error = (function() {

        /**
         * Properties of an Error.
         * @memberof tieba
         * @interface IError
         * @property {string|null} [errorMsg] Error errorMsg
         * @property {number|null} [errorCode] Error errorCode
         * @property {string|null} [userMsg] Error userMsg
         */

        /**
         * Constructs a new Error.
         * @memberof tieba
         * @classdesc Represents an Error.
         * @implements IError
         * @constructor
         * @param {tieba.IError=} [properties] Properties to set
         */
        function Error(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Error errorMsg.
         * @member {string} errorMsg
         * @memberof tieba.Error
         * @instance
         */
        Error.prototype.errorMsg = "";

        /**
         * Error errorCode.
         * @member {number} errorCode
         * @memberof tieba.Error
         * @instance
         */
        Error.prototype.errorCode = 0;

        /**
         * Error userMsg.
         * @member {string} userMsg
         * @memberof tieba.Error
         * @instance
         */
        Error.prototype.userMsg = "";

        /**
         * Creates a new Error instance using the specified properties.
         * @function create
         * @memberof tieba.Error
         * @static
         * @param {tieba.IError=} [properties] Properties to set
         * @returns {tieba.Error} Error instance
         */
        Error.create = function create(properties) {
            return new Error(properties);
        };

        /**
         * Encodes the specified Error message. Does not implicitly {@link tieba.Error.verify|verify} messages.
         * @function encode
         * @memberof tieba.Error
         * @static
         * @param {tieba.IError} message Error message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorCode);
            if (message.errorMsg != null && Object.hasOwnProperty.call(message, "errorMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMsg);
            if (message.userMsg != null && Object.hasOwnProperty.call(message, "userMsg"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.userMsg);
            return writer;
        };

        /**
         * Encodes the specified Error message, length delimited. Does not implicitly {@link tieba.Error.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Error
         * @static
         * @param {tieba.IError} message Error message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Error.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Error message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Error();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.errorMsg = reader.string();
                        break;
                    }
                case 1: {
                        message.errorCode = reader.int32();
                        break;
                    }
                case 3: {
                        message.userMsg = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Error message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Error
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Error} Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Error.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Error message.
         * @function verify
         * @memberof tieba.Error
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Error.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                if (!$util.isString(message.errorMsg))
                    return "errorMsg: string expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            if (message.userMsg != null && message.hasOwnProperty("userMsg"))
                if (!$util.isString(message.userMsg))
                    return "userMsg: string expected";
            return null;
        };

        /**
         * Creates an Error message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Error
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Error} Error
         */
        Error.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Error)
                return object;
            let message = new $root.tieba.Error();
            if (object.errorMsg != null)
                message.errorMsg = String(object.errorMsg);
            if (object.errorCode != null)
                message.errorCode = object.errorCode | 0;
            if (object.userMsg != null)
                message.userMsg = String(object.userMsg);
            return message;
        };

        /**
         * Creates a plain object from an Error message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Error
         * @static
         * @param {tieba.Error} message Error
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Error.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.errorCode = 0;
                object.errorMsg = "";
                object.userMsg = "";
            }
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                object.errorCode = message.errorCode;
            if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                object.errorMsg = message.errorMsg;
            if (message.userMsg != null && message.hasOwnProperty("userMsg"))
                object.userMsg = message.userMsg;
            return object;
        };

        /**
         * Converts this Error to JSON.
         * @function toJSON
         * @memberof tieba.Error
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Error.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Error
         * @function getTypeUrl
         * @memberof tieba.Error
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Error.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Error";
        };

        return Error;
    })();

    tieba.PostInfoList = (function() {

        /**
         * Properties of a PostInfoList.
         * @memberof tieba
         * @interface IPostInfoList
         * @property {number|Long|null} [forumId] PostInfoList forumId
         * @property {number|Long|null} [threadId] PostInfoList threadId
         * @property {number|Long|null} [postId] PostInfoList postId
         * @property {number|null} [isThread] PostInfoList isThread
         * @property {number|null} [createTime] PostInfoList createTime
         * @property {string|null} [forumName] PostInfoList forumName
         * @property {string|null} [title] PostInfoList title
         * @property {Array.<tieba.IPostInfoContent>|null} [content] PostInfoList content
         * @property {string|null} [contentThread] PostInfoList contentThread
         * @property {string|null} [userName] PostInfoList userName
         * @property {string|null} [ip] PostInfoList ip
         * @property {number|null} [isPostDeleted] PostInfoList isPostDeleted
         * @property {string|null} [ptype] PostInfoList ptype
         * @property {string|null} [_abstract] PostInfoList _abstract
         * @property {Array.<tieba.IAbstract>|null} [abstractThread] PostInfoList abstractThread
         * @property {Array.<tieba.IMedia>|null} [media] PostInfoList media
         * @property {number|null} [replyNum] PostInfoList replyNum
         * @property {number|Long|null} [userId] PostInfoList userId
         * @property {string|null} [userPortrait] PostInfoList userPortrait
         * @property {string|null} [postType] PostInfoList postType
         * @property {tieba.ILbsInfo|null} [lbsInfo] PostInfoList lbsInfo
         * @property {tieba.IQuote|null} [quote] PostInfoList quote
         * @property {Array.<tieba.IVoice>|null} [voiceInfo] PostInfoList voiceInfo
         * @property {tieba.IAnchorInfo|null} [anchorInfo] PostInfoList anchorInfo
         * @property {number|null} [hidePost] PostInfoList hidePost
         * @property {number|Long|null} [threadType] PostInfoList threadType
         * @property {tieba.IZhiBoInfoTW|null} [twzhiboInfo] PostInfoList twzhiboInfo
         * @property {tieba.IPollInfo|null} [pollInfo] PostInfoList pollInfo
         * @property {tieba.IVideoInfo|null} [videoInfo] PostInfoList videoInfo
         * @property {boolean|null} [isDeal] PostInfoList isDeal
         * @property {tieba.IDealInfo|null} [dealInfo] PostInfoList dealInfo
         * @property {Array.<tieba.IMultipleForum>|null} [multipleForumList] PostInfoList multipleForumList
         * @property {number|null} [freqNum] PostInfoList freqNum
         * @property {number|Long|null} [vForumId] PostInfoList vForumId
         * @property {string|null} [nameShow] PostInfoList nameShow
         * @property {tieba.IAlaLiveInfo|null} [alaInfo] PostInfoList alaInfo
         * @property {number|null} [agreeNum] PostInfoList agreeNum
         * @property {number|null} [viewNum] PostInfoList viewNum
         * @property {number|null} [shareNum] PostInfoList shareNum
         * @property {tieba.IAgree|null} [agree] PostInfoList agree
         * @property {number|null} [isRemain] PostInfoList isRemain
         * @property {tieba.IOriginThreadInfo|null} [originThreadInfo] PostInfoList originThreadInfo
         * @property {number|null} [isViewYear] PostInfoList isViewYear
         * @property {number|null} [isShareThread] PostInfoList isShareThread
         * @property {Array.<tieba.IPbContent>|null} [richTitle] PostInfoList richTitle
         * @property {Array.<tieba.IPbContent>|null} [richAbstract] PostInfoList richAbstract
         * @property {number|null} [isNtitle] PostInfoList isNtitle
         * @property {string|null} [articleCover] PostInfoList articleCover
         * @property {Array.<tieba.IPbContent>|null} [firstPostContent] PostInfoList firstPostContent
         * @property {tieba.IBaijiahaoInfo|null} [baijiahaoInfo] PostInfoList baijiahaoInfo
         * @property {string|null} [wonderfulPostInfo] PostInfoList wonderfulPostInfo
         * @property {tieba.IItem|null} [item] PostInfoList item
         * @property {Array.<tieba.IHeadItem>|null} [itemStar] PostInfoList itemStar
         * @property {Array.<tieba.IPbLinkInfo>|null} [pbLinkInfo] PostInfoList pbLinkInfo
         * @property {Array.<tieba.IPrivSets>|null} [privSets] PostInfoList privSets
         * @property {number|null} [isAuthorView] PostInfoList isAuthorView
         * @property {number|null} [isManager] PostInfoList isManager
         * @property {number|null} [isOriginManager] PostInfoList isOriginManager
         * @property {number|null} [goodTypes] PostInfoList goodTypes
         * @property {number|null} [topTypes] PostInfoList topTypes
         * @property {tieba.IUserPostPerm|null} [userPostPerm] PostInfoList userPostPerm
         * @property {string|null} [targetScheme] PostInfoList targetScheme
         */

        /**
         * Constructs a new PostInfoList.
         * @memberof tieba
         * @classdesc Represents a PostInfoList.
         * @implements IPostInfoList
         * @constructor
         * @param {tieba.IPostInfoList=} [properties] Properties to set
         */
        function PostInfoList(properties) {
            this.content = [];
            this.abstractThread = [];
            this.media = [];
            this.voiceInfo = [];
            this.multipleForumList = [];
            this.richTitle = [];
            this.richAbstract = [];
            this.firstPostContent = [];
            this.itemStar = [];
            this.pbLinkInfo = [];
            this.privSets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostInfoList forumId.
         * @member {number|Long} forumId
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.forumId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoList threadId.
         * @member {number|Long} threadId
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.threadId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoList postId.
         * @member {number|Long} postId
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.postId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoList isThread.
         * @member {number} isThread
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isThread = 0;

        /**
         * PostInfoList createTime.
         * @member {number} createTime
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.createTime = 0;

        /**
         * PostInfoList forumName.
         * @member {string} forumName
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.forumName = "";

        /**
         * PostInfoList title.
         * @member {string} title
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.title = "";

        /**
         * PostInfoList content.
         * @member {Array.<tieba.IPostInfoContent>} content
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.content = $util.emptyArray;

        /**
         * PostInfoList contentThread.
         * @member {string} contentThread
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.contentThread = "";

        /**
         * PostInfoList userName.
         * @member {string} userName
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.userName = "";

        /**
         * PostInfoList ip.
         * @member {string} ip
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.ip = "";

        /**
         * PostInfoList isPostDeleted.
         * @member {number} isPostDeleted
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isPostDeleted = 0;

        /**
         * PostInfoList ptype.
         * @member {string} ptype
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.ptype = "";

        /**
         * PostInfoList _abstract.
         * @member {string} _abstract
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype._abstract = "";

        /**
         * PostInfoList abstractThread.
         * @member {Array.<tieba.IAbstract>} abstractThread
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.abstractThread = $util.emptyArray;

        /**
         * PostInfoList media.
         * @member {Array.<tieba.IMedia>} media
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.media = $util.emptyArray;

        /**
         * PostInfoList replyNum.
         * @member {number} replyNum
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.replyNum = 0;

        /**
         * PostInfoList userId.
         * @member {number|Long} userId
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PostInfoList userPortrait.
         * @member {string} userPortrait
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.userPortrait = "";

        /**
         * PostInfoList postType.
         * @member {string} postType
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.postType = "";

        /**
         * PostInfoList lbsInfo.
         * @member {tieba.ILbsInfo|null|undefined} lbsInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.lbsInfo = null;

        /**
         * PostInfoList quote.
         * @member {tieba.IQuote|null|undefined} quote
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.quote = null;

        /**
         * PostInfoList voiceInfo.
         * @member {Array.<tieba.IVoice>} voiceInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.voiceInfo = $util.emptyArray;

        /**
         * PostInfoList anchorInfo.
         * @member {tieba.IAnchorInfo|null|undefined} anchorInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.anchorInfo = null;

        /**
         * PostInfoList hidePost.
         * @member {number} hidePost
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.hidePost = 0;

        /**
         * PostInfoList threadType.
         * @member {number|Long} threadType
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.threadType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoList twzhiboInfo.
         * @member {tieba.IZhiBoInfoTW|null|undefined} twzhiboInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.twzhiboInfo = null;

        /**
         * PostInfoList pollInfo.
         * @member {tieba.IPollInfo|null|undefined} pollInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.pollInfo = null;

        /**
         * PostInfoList videoInfo.
         * @member {tieba.IVideoInfo|null|undefined} videoInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.videoInfo = null;

        /**
         * PostInfoList isDeal.
         * @member {boolean} isDeal
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isDeal = false;

        /**
         * PostInfoList dealInfo.
         * @member {tieba.IDealInfo|null|undefined} dealInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.dealInfo = null;

        /**
         * PostInfoList multipleForumList.
         * @member {Array.<tieba.IMultipleForum>} multipleForumList
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.multipleForumList = $util.emptyArray;

        /**
         * PostInfoList freqNum.
         * @member {number} freqNum
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.freqNum = 0;

        /**
         * PostInfoList vForumId.
         * @member {number|Long} vForumId
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.vForumId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoList nameShow.
         * @member {string} nameShow
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.nameShow = "";

        /**
         * PostInfoList alaInfo.
         * @member {tieba.IAlaLiveInfo|null|undefined} alaInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.alaInfo = null;

        /**
         * PostInfoList agreeNum.
         * @member {number} agreeNum
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.agreeNum = 0;

        /**
         * PostInfoList viewNum.
         * @member {number} viewNum
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.viewNum = 0;

        /**
         * PostInfoList shareNum.
         * @member {number} shareNum
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.shareNum = 0;

        /**
         * PostInfoList agree.
         * @member {tieba.IAgree|null|undefined} agree
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.agree = null;

        /**
         * PostInfoList isRemain.
         * @member {number} isRemain
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isRemain = 0;

        /**
         * PostInfoList originThreadInfo.
         * @member {tieba.IOriginThreadInfo|null|undefined} originThreadInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.originThreadInfo = null;

        /**
         * PostInfoList isViewYear.
         * @member {number} isViewYear
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isViewYear = 0;

        /**
         * PostInfoList isShareThread.
         * @member {number} isShareThread
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isShareThread = 0;

        /**
         * PostInfoList richTitle.
         * @member {Array.<tieba.IPbContent>} richTitle
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.richTitle = $util.emptyArray;

        /**
         * PostInfoList richAbstract.
         * @member {Array.<tieba.IPbContent>} richAbstract
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.richAbstract = $util.emptyArray;

        /**
         * PostInfoList isNtitle.
         * @member {number} isNtitle
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isNtitle = 0;

        /**
         * PostInfoList articleCover.
         * @member {string} articleCover
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.articleCover = "";

        /**
         * PostInfoList firstPostContent.
         * @member {Array.<tieba.IPbContent>} firstPostContent
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.firstPostContent = $util.emptyArray;

        /**
         * PostInfoList baijiahaoInfo.
         * @member {tieba.IBaijiahaoInfo|null|undefined} baijiahaoInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.baijiahaoInfo = null;

        /**
         * PostInfoList wonderfulPostInfo.
         * @member {string} wonderfulPostInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.wonderfulPostInfo = "";

        /**
         * PostInfoList item.
         * @member {tieba.IItem|null|undefined} item
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.item = null;

        /**
         * PostInfoList itemStar.
         * @member {Array.<tieba.IHeadItem>} itemStar
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.itemStar = $util.emptyArray;

        /**
         * PostInfoList pbLinkInfo.
         * @member {Array.<tieba.IPbLinkInfo>} pbLinkInfo
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.pbLinkInfo = $util.emptyArray;

        /**
         * PostInfoList privSets.
         * @member {Array.<tieba.IPrivSets>} privSets
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.privSets = $util.emptyArray;

        /**
         * PostInfoList isAuthorView.
         * @member {number} isAuthorView
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isAuthorView = 0;

        /**
         * PostInfoList isManager.
         * @member {number} isManager
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isManager = 0;

        /**
         * PostInfoList isOriginManager.
         * @member {number} isOriginManager
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.isOriginManager = 0;

        /**
         * PostInfoList goodTypes.
         * @member {number} goodTypes
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.goodTypes = 0;

        /**
         * PostInfoList topTypes.
         * @member {number} topTypes
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.topTypes = 0;

        /**
         * PostInfoList userPostPerm.
         * @member {tieba.IUserPostPerm|null|undefined} userPostPerm
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.userPostPerm = null;

        /**
         * PostInfoList targetScheme.
         * @member {string} targetScheme
         * @memberof tieba.PostInfoList
         * @instance
         */
        PostInfoList.prototype.targetScheme = "";

        /**
         * Creates a new PostInfoList instance using the specified properties.
         * @function create
         * @memberof tieba.PostInfoList
         * @static
         * @param {tieba.IPostInfoList=} [properties] Properties to set
         * @returns {tieba.PostInfoList} PostInfoList instance
         */
        PostInfoList.create = function create(properties) {
            return new PostInfoList(properties);
        };

        /**
         * Encodes the specified PostInfoList message. Does not implicitly {@link tieba.PostInfoList.verify|verify} messages.
         * @function encode
         * @memberof tieba.PostInfoList
         * @static
         * @param {tieba.IPostInfoList} message PostInfoList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostInfoList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forumId != null && Object.hasOwnProperty.call(message, "forumId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.forumId);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.threadId);
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.postId);
            if (message.isThread != null && Object.hasOwnProperty.call(message, "isThread"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.isThread);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.createTime);
            if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.forumName);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.title);
            if (message.content != null && message.content.length)
                for (let i = 0; i < message.content.length; ++i)
                    $root.tieba.PostInfoContent.encode(message.content[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.contentThread != null && Object.hasOwnProperty.call(message, "contentThread"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.contentThread);
            if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.userName);
            if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.ip);
            if (message.isPostDeleted != null && Object.hasOwnProperty.call(message, "isPostDeleted"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.isPostDeleted);
            if (message.ptype != null && Object.hasOwnProperty.call(message, "ptype"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.ptype);
            if (message._abstract != null && Object.hasOwnProperty.call(message, "_abstract"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message._abstract);
            if (message.abstractThread != null && message.abstractThread.length)
                for (let i = 0; i < message.abstractThread.length; ++i)
                    $root.tieba.Abstract.encode(message.abstractThread[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.media != null && message.media.length)
                for (let i = 0; i < message.media.length; ++i)
                    $root.tieba.Media.encode(message.media[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.replyNum != null && Object.hasOwnProperty.call(message, "replyNum"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.replyNum);
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.userId);
            if (message.userPortrait != null && Object.hasOwnProperty.call(message, "userPortrait"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.userPortrait);
            if (message.postType != null && Object.hasOwnProperty.call(message, "postType"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.postType);
            if (message.lbsInfo != null && Object.hasOwnProperty.call(message, "lbsInfo"))
                $root.tieba.LbsInfo.encode(message.lbsInfo, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.quote != null && Object.hasOwnProperty.call(message, "quote"))
                $root.tieba.Quote.encode(message.quote, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.voiceInfo != null && message.voiceInfo.length)
                for (let i = 0; i < message.voiceInfo.length; ++i)
                    $root.tieba.Voice.encode(message.voiceInfo[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.anchorInfo != null && Object.hasOwnProperty.call(message, "anchorInfo"))
                $root.tieba.AnchorInfo.encode(message.anchorInfo, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.hidePost != null && Object.hasOwnProperty.call(message, "hidePost"))
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.hidePost);
            if (message.threadType != null && Object.hasOwnProperty.call(message, "threadType"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint64(message.threadType);
            if (message.twzhiboInfo != null && Object.hasOwnProperty.call(message, "twzhiboInfo"))
                $root.tieba.ZhiBoInfoTW.encode(message.twzhiboInfo, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.pollInfo != null && Object.hasOwnProperty.call(message, "pollInfo"))
                $root.tieba.PollInfo.encode(message.pollInfo, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.videoInfo != null && Object.hasOwnProperty.call(message, "videoInfo"))
                $root.tieba.VideoInfo.encode(message.videoInfo, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.isDeal != null && Object.hasOwnProperty.call(message, "isDeal"))
                writer.uint32(/* id 30, wireType 0 =*/240).bool(message.isDeal);
            if (message.dealInfo != null && Object.hasOwnProperty.call(message, "dealInfo"))
                $root.tieba.DealInfo.encode(message.dealInfo, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.multipleForumList != null && message.multipleForumList.length)
                for (let i = 0; i < message.multipleForumList.length; ++i)
                    $root.tieba.MultipleForum.encode(message.multipleForumList[i], writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.freqNum != null && Object.hasOwnProperty.call(message, "freqNum"))
                writer.uint32(/* id 33, wireType 0 =*/264).int32(message.freqNum);
            if (message.vForumId != null && Object.hasOwnProperty.call(message, "vForumId"))
                writer.uint32(/* id 34, wireType 0 =*/272).uint64(message.vForumId);
            if (message.nameShow != null && Object.hasOwnProperty.call(message, "nameShow"))
                writer.uint32(/* id 35, wireType 2 =*/282).string(message.nameShow);
            if (message.alaInfo != null && Object.hasOwnProperty.call(message, "alaInfo"))
                $root.tieba.AlaLiveInfo.encode(message.alaInfo, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.agreeNum != null && Object.hasOwnProperty.call(message, "agreeNum"))
                writer.uint32(/* id 37, wireType 0 =*/296).int32(message.agreeNum);
            if (message.viewNum != null && Object.hasOwnProperty.call(message, "viewNum"))
                writer.uint32(/* id 38, wireType 0 =*/304).int32(message.viewNum);
            if (message.shareNum != null && Object.hasOwnProperty.call(message, "shareNum"))
                writer.uint32(/* id 39, wireType 0 =*/312).int32(message.shareNum);
            if (message.agree != null && Object.hasOwnProperty.call(message, "agree"))
                $root.tieba.Agree.encode(message.agree, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.isRemain != null && Object.hasOwnProperty.call(message, "isRemain"))
                writer.uint32(/* id 41, wireType 0 =*/328).int32(message.isRemain);
            if (message.originThreadInfo != null && Object.hasOwnProperty.call(message, "originThreadInfo"))
                $root.tieba.OriginThreadInfo.encode(message.originThreadInfo, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.isViewYear != null && Object.hasOwnProperty.call(message, "isViewYear"))
                writer.uint32(/* id 43, wireType 0 =*/344).int32(message.isViewYear);
            if (message.isShareThread != null && Object.hasOwnProperty.call(message, "isShareThread"))
                writer.uint32(/* id 44, wireType 0 =*/352).int32(message.isShareThread);
            if (message.richTitle != null && message.richTitle.length)
                for (let i = 0; i < message.richTitle.length; ++i)
                    $root.tieba.PbContent.encode(message.richTitle[i], writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.richAbstract != null && message.richAbstract.length)
                for (let i = 0; i < message.richAbstract.length; ++i)
                    $root.tieba.PbContent.encode(message.richAbstract[i], writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
            if (message.isNtitle != null && Object.hasOwnProperty.call(message, "isNtitle"))
                writer.uint32(/* id 47, wireType 0 =*/376).int32(message.isNtitle);
            if (message.articleCover != null && Object.hasOwnProperty.call(message, "articleCover"))
                writer.uint32(/* id 48, wireType 2 =*/386).string(message.articleCover);
            if (message.firstPostContent != null && message.firstPostContent.length)
                for (let i = 0; i < message.firstPostContent.length; ++i)
                    $root.tieba.PbContent.encode(message.firstPostContent[i], writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
            if (message.baijiahaoInfo != null && Object.hasOwnProperty.call(message, "baijiahaoInfo"))
                $root.tieba.BaijiahaoInfo.encode(message.baijiahaoInfo, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            if (message.wonderfulPostInfo != null && Object.hasOwnProperty.call(message, "wonderfulPostInfo"))
                writer.uint32(/* id 51, wireType 2 =*/410).string(message.wonderfulPostInfo);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.tieba.Item.encode(message.item, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
            if (message.itemStar != null && message.itemStar.length)
                for (let i = 0; i < message.itemStar.length; ++i)
                    $root.tieba.HeadItem.encode(message.itemStar[i], writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.pbLinkInfo != null && message.pbLinkInfo.length)
                for (let i = 0; i < message.pbLinkInfo.length; ++i)
                    $root.tieba.PbLinkInfo.encode(message.pbLinkInfo[i], writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
            if (message.privSets != null && message.privSets.length)
                for (let i = 0; i < message.privSets.length; ++i)
                    $root.tieba.PrivSets.encode(message.privSets[i], writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
            if (message.isAuthorView != null && Object.hasOwnProperty.call(message, "isAuthorView"))
                writer.uint32(/* id 57, wireType 0 =*/456).int32(message.isAuthorView);
            if (message.isManager != null && Object.hasOwnProperty.call(message, "isManager"))
                writer.uint32(/* id 59, wireType 0 =*/472).int32(message.isManager);
            if (message.isOriginManager != null && Object.hasOwnProperty.call(message, "isOriginManager"))
                writer.uint32(/* id 60, wireType 0 =*/480).int32(message.isOriginManager);
            if (message.goodTypes != null && Object.hasOwnProperty.call(message, "goodTypes"))
                writer.uint32(/* id 61, wireType 0 =*/488).int32(message.goodTypes);
            if (message.topTypes != null && Object.hasOwnProperty.call(message, "topTypes"))
                writer.uint32(/* id 62, wireType 0 =*/496).int32(message.topTypes);
            if (message.userPostPerm != null && Object.hasOwnProperty.call(message, "userPostPerm"))
                $root.tieba.UserPostPerm.encode(message.userPostPerm, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
            if (message.targetScheme != null && Object.hasOwnProperty.call(message, "targetScheme"))
                writer.uint32(/* id 66, wireType 2 =*/530).string(message.targetScheme);
            return writer;
        };

        /**
         * Encodes the specified PostInfoList message, length delimited. Does not implicitly {@link tieba.PostInfoList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.PostInfoList
         * @static
         * @param {tieba.IPostInfoList} message PostInfoList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostInfoList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostInfoList message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.PostInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.PostInfoList} PostInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostInfoList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.PostInfoList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.forumId = reader.uint64();
                        break;
                    }
                case 2: {
                        message.threadId = reader.uint64();
                        break;
                    }
                case 3: {
                        message.postId = reader.uint64();
                        break;
                    }
                case 4: {
                        message.isThread = reader.uint32();
                        break;
                    }
                case 5: {
                        message.createTime = reader.uint32();
                        break;
                    }
                case 6: {
                        message.forumName = reader.string();
                        break;
                    }
                case 7: {
                        message.title = reader.string();
                        break;
                    }
                case 8: {
                        if (!(message.content && message.content.length))
                            message.content = [];
                        message.content.push($root.tieba.PostInfoContent.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.contentThread = reader.string();
                        break;
                    }
                case 10: {
                        message.userName = reader.string();
                        break;
                    }
                case 11: {
                        message.ip = reader.string();
                        break;
                    }
                case 12: {
                        message.isPostDeleted = reader.uint32();
                        break;
                    }
                case 13: {
                        message.ptype = reader.string();
                        break;
                    }
                case 14: {
                        message._abstract = reader.string();
                        break;
                    }
                case 15: {
                        if (!(message.abstractThread && message.abstractThread.length))
                            message.abstractThread = [];
                        message.abstractThread.push($root.tieba.Abstract.decode(reader, reader.uint32()));
                        break;
                    }
                case 16: {
                        if (!(message.media && message.media.length))
                            message.media = [];
                        message.media.push($root.tieba.Media.decode(reader, reader.uint32()));
                        break;
                    }
                case 17: {
                        message.replyNum = reader.uint32();
                        break;
                    }
                case 18: {
                        message.userId = reader.int64();
                        break;
                    }
                case 19: {
                        message.userPortrait = reader.string();
                        break;
                    }
                case 20: {
                        message.postType = reader.string();
                        break;
                    }
                case 21: {
                        message.lbsInfo = $root.tieba.LbsInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.quote = $root.tieba.Quote.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        if (!(message.voiceInfo && message.voiceInfo.length))
                            message.voiceInfo = [];
                        message.voiceInfo.push($root.tieba.Voice.decode(reader, reader.uint32()));
                        break;
                    }
                case 24: {
                        message.anchorInfo = $root.tieba.AnchorInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 25: {
                        message.hidePost = reader.int32();
                        break;
                    }
                case 26: {
                        message.threadType = reader.uint64();
                        break;
                    }
                case 27: {
                        message.twzhiboInfo = $root.tieba.ZhiBoInfoTW.decode(reader, reader.uint32());
                        break;
                    }
                case 28: {
                        message.pollInfo = $root.tieba.PollInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 29: {
                        message.videoInfo = $root.tieba.VideoInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 30: {
                        message.isDeal = reader.bool();
                        break;
                    }
                case 31: {
                        message.dealInfo = $root.tieba.DealInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 32: {
                        if (!(message.multipleForumList && message.multipleForumList.length))
                            message.multipleForumList = [];
                        message.multipleForumList.push($root.tieba.MultipleForum.decode(reader, reader.uint32()));
                        break;
                    }
                case 33: {
                        message.freqNum = reader.int32();
                        break;
                    }
                case 34: {
                        message.vForumId = reader.uint64();
                        break;
                    }
                case 35: {
                        message.nameShow = reader.string();
                        break;
                    }
                case 36: {
                        message.alaInfo = $root.tieba.AlaLiveInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 37: {
                        message.agreeNum = reader.int32();
                        break;
                    }
                case 38: {
                        message.viewNum = reader.int32();
                        break;
                    }
                case 39: {
                        message.shareNum = reader.int32();
                        break;
                    }
                case 40: {
                        message.agree = $root.tieba.Agree.decode(reader, reader.uint32());
                        break;
                    }
                case 41: {
                        message.isRemain = reader.int32();
                        break;
                    }
                case 42: {
                        message.originThreadInfo = $root.tieba.OriginThreadInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 43: {
                        message.isViewYear = reader.int32();
                        break;
                    }
                case 44: {
                        message.isShareThread = reader.int32();
                        break;
                    }
                case 45: {
                        if (!(message.richTitle && message.richTitle.length))
                            message.richTitle = [];
                        message.richTitle.push($root.tieba.PbContent.decode(reader, reader.uint32()));
                        break;
                    }
                case 46: {
                        if (!(message.richAbstract && message.richAbstract.length))
                            message.richAbstract = [];
                        message.richAbstract.push($root.tieba.PbContent.decode(reader, reader.uint32()));
                        break;
                    }
                case 47: {
                        message.isNtitle = reader.int32();
                        break;
                    }
                case 48: {
                        message.articleCover = reader.string();
                        break;
                    }
                case 49: {
                        if (!(message.firstPostContent && message.firstPostContent.length))
                            message.firstPostContent = [];
                        message.firstPostContent.push($root.tieba.PbContent.decode(reader, reader.uint32()));
                        break;
                    }
                case 50: {
                        message.baijiahaoInfo = $root.tieba.BaijiahaoInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 51: {
                        message.wonderfulPostInfo = reader.string();
                        break;
                    }
                case 52: {
                        message.item = $root.tieba.Item.decode(reader, reader.uint32());
                        break;
                    }
                case 53: {
                        if (!(message.itemStar && message.itemStar.length))
                            message.itemStar = [];
                        message.itemStar.push($root.tieba.HeadItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 54: {
                        if (!(message.pbLinkInfo && message.pbLinkInfo.length))
                            message.pbLinkInfo = [];
                        message.pbLinkInfo.push($root.tieba.PbLinkInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 56: {
                        if (!(message.privSets && message.privSets.length))
                            message.privSets = [];
                        message.privSets.push($root.tieba.PrivSets.decode(reader, reader.uint32()));
                        break;
                    }
                case 57: {
                        message.isAuthorView = reader.int32();
                        break;
                    }
                case 59: {
                        message.isManager = reader.int32();
                        break;
                    }
                case 60: {
                        message.isOriginManager = reader.int32();
                        break;
                    }
                case 61: {
                        message.goodTypes = reader.int32();
                        break;
                    }
                case 62: {
                        message.topTypes = reader.int32();
                        break;
                    }
                case 63: {
                        message.userPostPerm = $root.tieba.UserPostPerm.decode(reader, reader.uint32());
                        break;
                    }
                case 66: {
                        message.targetScheme = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostInfoList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.PostInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.PostInfoList} PostInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostInfoList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostInfoList message.
         * @function verify
         * @memberof tieba.PostInfoList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostInfoList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (!$util.isInteger(message.forumId) && !(message.forumId && $util.isInteger(message.forumId.low) && $util.isInteger(message.forumId.high)))
                    return "forumId: integer|Long expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                    return "threadId: integer|Long expected";
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isInteger(message.postId) && !(message.postId && $util.isInteger(message.postId.low) && $util.isInteger(message.postId.high)))
                    return "postId: integer|Long expected";
            if (message.isThread != null && message.hasOwnProperty("isThread"))
                if (!$util.isInteger(message.isThread))
                    return "isThread: integer expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime))
                    return "createTime: integer expected";
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                if (!$util.isString(message.forumName))
                    return "forumName: string expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.content != null && message.hasOwnProperty("content")) {
                if (!Array.isArray(message.content))
                    return "content: array expected";
                for (let i = 0; i < message.content.length; ++i) {
                    let error = $root.tieba.PostInfoContent.verify(message.content[i]);
                    if (error)
                        return "content." + error;
                }
            }
            if (message.contentThread != null && message.hasOwnProperty("contentThread"))
                if (!$util.isString(message.contentThread))
                    return "contentThread: string expected";
            if (message.userName != null && message.hasOwnProperty("userName"))
                if (!$util.isString(message.userName))
                    return "userName: string expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            if (message.isPostDeleted != null && message.hasOwnProperty("isPostDeleted"))
                if (!$util.isInteger(message.isPostDeleted))
                    return "isPostDeleted: integer expected";
            if (message.ptype != null && message.hasOwnProperty("ptype"))
                if (!$util.isString(message.ptype))
                    return "ptype: string expected";
            if (message._abstract != null && message.hasOwnProperty("_abstract"))
                if (!$util.isString(message._abstract))
                    return "_abstract: string expected";
            if (message.abstractThread != null && message.hasOwnProperty("abstractThread")) {
                if (!Array.isArray(message.abstractThread))
                    return "abstractThread: array expected";
                for (let i = 0; i < message.abstractThread.length; ++i) {
                    let error = $root.tieba.Abstract.verify(message.abstractThread[i]);
                    if (error)
                        return "abstractThread." + error;
                }
            }
            if (message.media != null && message.hasOwnProperty("media")) {
                if (!Array.isArray(message.media))
                    return "media: array expected";
                for (let i = 0; i < message.media.length; ++i) {
                    let error = $root.tieba.Media.verify(message.media[i]);
                    if (error)
                        return "media." + error;
                }
            }
            if (message.replyNum != null && message.hasOwnProperty("replyNum"))
                if (!$util.isInteger(message.replyNum))
                    return "replyNum: integer expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            if (message.userPortrait != null && message.hasOwnProperty("userPortrait"))
                if (!$util.isString(message.userPortrait))
                    return "userPortrait: string expected";
            if (message.postType != null && message.hasOwnProperty("postType"))
                if (!$util.isString(message.postType))
                    return "postType: string expected";
            if (message.lbsInfo != null && message.hasOwnProperty("lbsInfo")) {
                let error = $root.tieba.LbsInfo.verify(message.lbsInfo);
                if (error)
                    return "lbsInfo." + error;
            }
            if (message.quote != null && message.hasOwnProperty("quote")) {
                let error = $root.tieba.Quote.verify(message.quote);
                if (error)
                    return "quote." + error;
            }
            if (message.voiceInfo != null && message.hasOwnProperty("voiceInfo")) {
                if (!Array.isArray(message.voiceInfo))
                    return "voiceInfo: array expected";
                for (let i = 0; i < message.voiceInfo.length; ++i) {
                    let error = $root.tieba.Voice.verify(message.voiceInfo[i]);
                    if (error)
                        return "voiceInfo." + error;
                }
            }
            if (message.anchorInfo != null && message.hasOwnProperty("anchorInfo")) {
                let error = $root.tieba.AnchorInfo.verify(message.anchorInfo);
                if (error)
                    return "anchorInfo." + error;
            }
            if (message.hidePost != null && message.hasOwnProperty("hidePost"))
                if (!$util.isInteger(message.hidePost))
                    return "hidePost: integer expected";
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                if (!$util.isInteger(message.threadType) && !(message.threadType && $util.isInteger(message.threadType.low) && $util.isInteger(message.threadType.high)))
                    return "threadType: integer|Long expected";
            if (message.twzhiboInfo != null && message.hasOwnProperty("twzhiboInfo")) {
                let error = $root.tieba.ZhiBoInfoTW.verify(message.twzhiboInfo);
                if (error)
                    return "twzhiboInfo." + error;
            }
            if (message.pollInfo != null && message.hasOwnProperty("pollInfo")) {
                let error = $root.tieba.PollInfo.verify(message.pollInfo);
                if (error)
                    return "pollInfo." + error;
            }
            if (message.videoInfo != null && message.hasOwnProperty("videoInfo")) {
                let error = $root.tieba.VideoInfo.verify(message.videoInfo);
                if (error)
                    return "videoInfo." + error;
            }
            if (message.isDeal != null && message.hasOwnProperty("isDeal"))
                if (typeof message.isDeal !== "boolean")
                    return "isDeal: boolean expected";
            if (message.dealInfo != null && message.hasOwnProperty("dealInfo")) {
                let error = $root.tieba.DealInfo.verify(message.dealInfo);
                if (error)
                    return "dealInfo." + error;
            }
            if (message.multipleForumList != null && message.hasOwnProperty("multipleForumList")) {
                if (!Array.isArray(message.multipleForumList))
                    return "multipleForumList: array expected";
                for (let i = 0; i < message.multipleForumList.length; ++i) {
                    let error = $root.tieba.MultipleForum.verify(message.multipleForumList[i]);
                    if (error)
                        return "multipleForumList." + error;
                }
            }
            if (message.freqNum != null && message.hasOwnProperty("freqNum"))
                if (!$util.isInteger(message.freqNum))
                    return "freqNum: integer expected";
            if (message.vForumId != null && message.hasOwnProperty("vForumId"))
                if (!$util.isInteger(message.vForumId) && !(message.vForumId && $util.isInteger(message.vForumId.low) && $util.isInteger(message.vForumId.high)))
                    return "vForumId: integer|Long expected";
            if (message.nameShow != null && message.hasOwnProperty("nameShow"))
                if (!$util.isString(message.nameShow))
                    return "nameShow: string expected";
            if (message.alaInfo != null && message.hasOwnProperty("alaInfo")) {
                let error = $root.tieba.AlaLiveInfo.verify(message.alaInfo);
                if (error)
                    return "alaInfo." + error;
            }
            if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
                if (!$util.isInteger(message.agreeNum))
                    return "agreeNum: integer expected";
            if (message.viewNum != null && message.hasOwnProperty("viewNum"))
                if (!$util.isInteger(message.viewNum))
                    return "viewNum: integer expected";
            if (message.shareNum != null && message.hasOwnProperty("shareNum"))
                if (!$util.isInteger(message.shareNum))
                    return "shareNum: integer expected";
            if (message.agree != null && message.hasOwnProperty("agree")) {
                let error = $root.tieba.Agree.verify(message.agree);
                if (error)
                    return "agree." + error;
            }
            if (message.isRemain != null && message.hasOwnProperty("isRemain"))
                if (!$util.isInteger(message.isRemain))
                    return "isRemain: integer expected";
            if (message.originThreadInfo != null && message.hasOwnProperty("originThreadInfo")) {
                let error = $root.tieba.OriginThreadInfo.verify(message.originThreadInfo);
                if (error)
                    return "originThreadInfo." + error;
            }
            if (message.isViewYear != null && message.hasOwnProperty("isViewYear"))
                if (!$util.isInteger(message.isViewYear))
                    return "isViewYear: integer expected";
            if (message.isShareThread != null && message.hasOwnProperty("isShareThread"))
                if (!$util.isInteger(message.isShareThread))
                    return "isShareThread: integer expected";
            if (message.richTitle != null && message.hasOwnProperty("richTitle")) {
                if (!Array.isArray(message.richTitle))
                    return "richTitle: array expected";
                for (let i = 0; i < message.richTitle.length; ++i) {
                    let error = $root.tieba.PbContent.verify(message.richTitle[i]);
                    if (error)
                        return "richTitle." + error;
                }
            }
            if (message.richAbstract != null && message.hasOwnProperty("richAbstract")) {
                if (!Array.isArray(message.richAbstract))
                    return "richAbstract: array expected";
                for (let i = 0; i < message.richAbstract.length; ++i) {
                    let error = $root.tieba.PbContent.verify(message.richAbstract[i]);
                    if (error)
                        return "richAbstract." + error;
                }
            }
            if (message.isNtitle != null && message.hasOwnProperty("isNtitle"))
                if (!$util.isInteger(message.isNtitle))
                    return "isNtitle: integer expected";
            if (message.articleCover != null && message.hasOwnProperty("articleCover"))
                if (!$util.isString(message.articleCover))
                    return "articleCover: string expected";
            if (message.firstPostContent != null && message.hasOwnProperty("firstPostContent")) {
                if (!Array.isArray(message.firstPostContent))
                    return "firstPostContent: array expected";
                for (let i = 0; i < message.firstPostContent.length; ++i) {
                    let error = $root.tieba.PbContent.verify(message.firstPostContent[i]);
                    if (error)
                        return "firstPostContent." + error;
                }
            }
            if (message.baijiahaoInfo != null && message.hasOwnProperty("baijiahaoInfo")) {
                let error = $root.tieba.BaijiahaoInfo.verify(message.baijiahaoInfo);
                if (error)
                    return "baijiahaoInfo." + error;
            }
            if (message.wonderfulPostInfo != null && message.hasOwnProperty("wonderfulPostInfo"))
                if (!$util.isString(message.wonderfulPostInfo))
                    return "wonderfulPostInfo: string expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                let error = $root.tieba.Item.verify(message.item);
                if (error)
                    return "item." + error;
            }
            if (message.itemStar != null && message.hasOwnProperty("itemStar")) {
                if (!Array.isArray(message.itemStar))
                    return "itemStar: array expected";
                for (let i = 0; i < message.itemStar.length; ++i) {
                    let error = $root.tieba.HeadItem.verify(message.itemStar[i]);
                    if (error)
                        return "itemStar." + error;
                }
            }
            if (message.pbLinkInfo != null && message.hasOwnProperty("pbLinkInfo")) {
                if (!Array.isArray(message.pbLinkInfo))
                    return "pbLinkInfo: array expected";
                for (let i = 0; i < message.pbLinkInfo.length; ++i) {
                    let error = $root.tieba.PbLinkInfo.verify(message.pbLinkInfo[i]);
                    if (error)
                        return "pbLinkInfo." + error;
                }
            }
            if (message.privSets != null && message.hasOwnProperty("privSets")) {
                if (!Array.isArray(message.privSets))
                    return "privSets: array expected";
                for (let i = 0; i < message.privSets.length; ++i) {
                    let error = $root.tieba.PrivSets.verify(message.privSets[i]);
                    if (error)
                        return "privSets." + error;
                }
            }
            if (message.isAuthorView != null && message.hasOwnProperty("isAuthorView"))
                if (!$util.isInteger(message.isAuthorView))
                    return "isAuthorView: integer expected";
            if (message.isManager != null && message.hasOwnProperty("isManager"))
                if (!$util.isInteger(message.isManager))
                    return "isManager: integer expected";
            if (message.isOriginManager != null && message.hasOwnProperty("isOriginManager"))
                if (!$util.isInteger(message.isOriginManager))
                    return "isOriginManager: integer expected";
            if (message.goodTypes != null && message.hasOwnProperty("goodTypes"))
                if (!$util.isInteger(message.goodTypes))
                    return "goodTypes: integer expected";
            if (message.topTypes != null && message.hasOwnProperty("topTypes"))
                if (!$util.isInteger(message.topTypes))
                    return "topTypes: integer expected";
            if (message.userPostPerm != null && message.hasOwnProperty("userPostPerm")) {
                let error = $root.tieba.UserPostPerm.verify(message.userPostPerm);
                if (error)
                    return "userPostPerm." + error;
            }
            if (message.targetScheme != null && message.hasOwnProperty("targetScheme"))
                if (!$util.isString(message.targetScheme))
                    return "targetScheme: string expected";
            return null;
        };

        /**
         * Creates a PostInfoList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.PostInfoList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.PostInfoList} PostInfoList
         */
        PostInfoList.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.PostInfoList)
                return object;
            let message = new $root.tieba.PostInfoList();
            if (object.forumId != null)
                if ($util.Long)
                    (message.forumId = $util.Long.fromValue(object.forumId)).unsigned = true;
                else if (typeof object.forumId === "string")
                    message.forumId = parseInt(object.forumId, 10);
                else if (typeof object.forumId === "number")
                    message.forumId = object.forumId;
                else if (typeof object.forumId === "object")
                    message.forumId = new $util.LongBits(object.forumId.low >>> 0, object.forumId.high >>> 0).toNumber(true);
            if (object.threadId != null)
                if ($util.Long)
                    (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = true;
                else if (typeof object.threadId === "string")
                    message.threadId = parseInt(object.threadId, 10);
                else if (typeof object.threadId === "number")
                    message.threadId = object.threadId;
                else if (typeof object.threadId === "object")
                    message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber(true);
            if (object.postId != null)
                if ($util.Long)
                    (message.postId = $util.Long.fromValue(object.postId)).unsigned = true;
                else if (typeof object.postId === "string")
                    message.postId = parseInt(object.postId, 10);
                else if (typeof object.postId === "number")
                    message.postId = object.postId;
                else if (typeof object.postId === "object")
                    message.postId = new $util.LongBits(object.postId.low >>> 0, object.postId.high >>> 0).toNumber(true);
            if (object.isThread != null)
                message.isThread = object.isThread >>> 0;
            if (object.createTime != null)
                message.createTime = object.createTime >>> 0;
            if (object.forumName != null)
                message.forumName = String(object.forumName);
            if (object.title != null)
                message.title = String(object.title);
            if (object.content) {
                if (!Array.isArray(object.content))
                    throw TypeError(".tieba.PostInfoList.content: array expected");
                message.content = [];
                for (let i = 0; i < object.content.length; ++i) {
                    if (typeof object.content[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.content: object expected");
                    message.content[i] = $root.tieba.PostInfoContent.fromObject(object.content[i]);
                }
            }
            if (object.contentThread != null)
                message.contentThread = String(object.contentThread);
            if (object.userName != null)
                message.userName = String(object.userName);
            if (object.ip != null)
                message.ip = String(object.ip);
            if (object.isPostDeleted != null)
                message.isPostDeleted = object.isPostDeleted >>> 0;
            if (object.ptype != null)
                message.ptype = String(object.ptype);
            if (object._abstract != null)
                message._abstract = String(object._abstract);
            if (object.abstractThread) {
                if (!Array.isArray(object.abstractThread))
                    throw TypeError(".tieba.PostInfoList.abstractThread: array expected");
                message.abstractThread = [];
                for (let i = 0; i < object.abstractThread.length; ++i) {
                    if (typeof object.abstractThread[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.abstractThread: object expected");
                    message.abstractThread[i] = $root.tieba.Abstract.fromObject(object.abstractThread[i]);
                }
            }
            if (object.media) {
                if (!Array.isArray(object.media))
                    throw TypeError(".tieba.PostInfoList.media: array expected");
                message.media = [];
                for (let i = 0; i < object.media.length; ++i) {
                    if (typeof object.media[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.media: object expected");
                    message.media[i] = $root.tieba.Media.fromObject(object.media[i]);
                }
            }
            if (object.replyNum != null)
                message.replyNum = object.replyNum >>> 0;
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
            if (object.userPortrait != null)
                message.userPortrait = String(object.userPortrait);
            if (object.postType != null)
                message.postType = String(object.postType);
            if (object.lbsInfo != null) {
                if (typeof object.lbsInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.lbsInfo: object expected");
                message.lbsInfo = $root.tieba.LbsInfo.fromObject(object.lbsInfo);
            }
            if (object.quote != null) {
                if (typeof object.quote !== "object")
                    throw TypeError(".tieba.PostInfoList.quote: object expected");
                message.quote = $root.tieba.Quote.fromObject(object.quote);
            }
            if (object.voiceInfo) {
                if (!Array.isArray(object.voiceInfo))
                    throw TypeError(".tieba.PostInfoList.voiceInfo: array expected");
                message.voiceInfo = [];
                for (let i = 0; i < object.voiceInfo.length; ++i) {
                    if (typeof object.voiceInfo[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.voiceInfo: object expected");
                    message.voiceInfo[i] = $root.tieba.Voice.fromObject(object.voiceInfo[i]);
                }
            }
            if (object.anchorInfo != null) {
                if (typeof object.anchorInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.anchorInfo: object expected");
                message.anchorInfo = $root.tieba.AnchorInfo.fromObject(object.anchorInfo);
            }
            if (object.hidePost != null)
                message.hidePost = object.hidePost | 0;
            if (object.threadType != null)
                if ($util.Long)
                    (message.threadType = $util.Long.fromValue(object.threadType)).unsigned = true;
                else if (typeof object.threadType === "string")
                    message.threadType = parseInt(object.threadType, 10);
                else if (typeof object.threadType === "number")
                    message.threadType = object.threadType;
                else if (typeof object.threadType === "object")
                    message.threadType = new $util.LongBits(object.threadType.low >>> 0, object.threadType.high >>> 0).toNumber(true);
            if (object.twzhiboInfo != null) {
                if (typeof object.twzhiboInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.twzhiboInfo: object expected");
                message.twzhiboInfo = $root.tieba.ZhiBoInfoTW.fromObject(object.twzhiboInfo);
            }
            if (object.pollInfo != null) {
                if (typeof object.pollInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.pollInfo: object expected");
                message.pollInfo = $root.tieba.PollInfo.fromObject(object.pollInfo);
            }
            if (object.videoInfo != null) {
                if (typeof object.videoInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.videoInfo: object expected");
                message.videoInfo = $root.tieba.VideoInfo.fromObject(object.videoInfo);
            }
            if (object.isDeal != null)
                message.isDeal = Boolean(object.isDeal);
            if (object.dealInfo != null) {
                if (typeof object.dealInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.dealInfo: object expected");
                message.dealInfo = $root.tieba.DealInfo.fromObject(object.dealInfo);
            }
            if (object.multipleForumList) {
                if (!Array.isArray(object.multipleForumList))
                    throw TypeError(".tieba.PostInfoList.multipleForumList: array expected");
                message.multipleForumList = [];
                for (let i = 0; i < object.multipleForumList.length; ++i) {
                    if (typeof object.multipleForumList[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.multipleForumList: object expected");
                    message.multipleForumList[i] = $root.tieba.MultipleForum.fromObject(object.multipleForumList[i]);
                }
            }
            if (object.freqNum != null)
                message.freqNum = object.freqNum | 0;
            if (object.vForumId != null)
                if ($util.Long)
                    (message.vForumId = $util.Long.fromValue(object.vForumId)).unsigned = true;
                else if (typeof object.vForumId === "string")
                    message.vForumId = parseInt(object.vForumId, 10);
                else if (typeof object.vForumId === "number")
                    message.vForumId = object.vForumId;
                else if (typeof object.vForumId === "object")
                    message.vForumId = new $util.LongBits(object.vForumId.low >>> 0, object.vForumId.high >>> 0).toNumber(true);
            if (object.nameShow != null)
                message.nameShow = String(object.nameShow);
            if (object.alaInfo != null) {
                if (typeof object.alaInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.alaInfo: object expected");
                message.alaInfo = $root.tieba.AlaLiveInfo.fromObject(object.alaInfo);
            }
            if (object.agreeNum != null)
                message.agreeNum = object.agreeNum | 0;
            if (object.viewNum != null)
                message.viewNum = object.viewNum | 0;
            if (object.shareNum != null)
                message.shareNum = object.shareNum | 0;
            if (object.agree != null) {
                if (typeof object.agree !== "object")
                    throw TypeError(".tieba.PostInfoList.agree: object expected");
                message.agree = $root.tieba.Agree.fromObject(object.agree);
            }
            if (object.isRemain != null)
                message.isRemain = object.isRemain | 0;
            if (object.originThreadInfo != null) {
                if (typeof object.originThreadInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.originThreadInfo: object expected");
                message.originThreadInfo = $root.tieba.OriginThreadInfo.fromObject(object.originThreadInfo);
            }
            if (object.isViewYear != null)
                message.isViewYear = object.isViewYear | 0;
            if (object.isShareThread != null)
                message.isShareThread = object.isShareThread | 0;
            if (object.richTitle) {
                if (!Array.isArray(object.richTitle))
                    throw TypeError(".tieba.PostInfoList.richTitle: array expected");
                message.richTitle = [];
                for (let i = 0; i < object.richTitle.length; ++i) {
                    if (typeof object.richTitle[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.richTitle: object expected");
                    message.richTitle[i] = $root.tieba.PbContent.fromObject(object.richTitle[i]);
                }
            }
            if (object.richAbstract) {
                if (!Array.isArray(object.richAbstract))
                    throw TypeError(".tieba.PostInfoList.richAbstract: array expected");
                message.richAbstract = [];
                for (let i = 0; i < object.richAbstract.length; ++i) {
                    if (typeof object.richAbstract[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.richAbstract: object expected");
                    message.richAbstract[i] = $root.tieba.PbContent.fromObject(object.richAbstract[i]);
                }
            }
            if (object.isNtitle != null)
                message.isNtitle = object.isNtitle | 0;
            if (object.articleCover != null)
                message.articleCover = String(object.articleCover);
            if (object.firstPostContent) {
                if (!Array.isArray(object.firstPostContent))
                    throw TypeError(".tieba.PostInfoList.firstPostContent: array expected");
                message.firstPostContent = [];
                for (let i = 0; i < object.firstPostContent.length; ++i) {
                    if (typeof object.firstPostContent[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.firstPostContent: object expected");
                    message.firstPostContent[i] = $root.tieba.PbContent.fromObject(object.firstPostContent[i]);
                }
            }
            if (object.baijiahaoInfo != null) {
                if (typeof object.baijiahaoInfo !== "object")
                    throw TypeError(".tieba.PostInfoList.baijiahaoInfo: object expected");
                message.baijiahaoInfo = $root.tieba.BaijiahaoInfo.fromObject(object.baijiahaoInfo);
            }
            if (object.wonderfulPostInfo != null)
                message.wonderfulPostInfo = String(object.wonderfulPostInfo);
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".tieba.PostInfoList.item: object expected");
                message.item = $root.tieba.Item.fromObject(object.item);
            }
            if (object.itemStar) {
                if (!Array.isArray(object.itemStar))
                    throw TypeError(".tieba.PostInfoList.itemStar: array expected");
                message.itemStar = [];
                for (let i = 0; i < object.itemStar.length; ++i) {
                    if (typeof object.itemStar[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.itemStar: object expected");
                    message.itemStar[i] = $root.tieba.HeadItem.fromObject(object.itemStar[i]);
                }
            }
            if (object.pbLinkInfo) {
                if (!Array.isArray(object.pbLinkInfo))
                    throw TypeError(".tieba.PostInfoList.pbLinkInfo: array expected");
                message.pbLinkInfo = [];
                for (let i = 0; i < object.pbLinkInfo.length; ++i) {
                    if (typeof object.pbLinkInfo[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.pbLinkInfo: object expected");
                    message.pbLinkInfo[i] = $root.tieba.PbLinkInfo.fromObject(object.pbLinkInfo[i]);
                }
            }
            if (object.privSets) {
                if (!Array.isArray(object.privSets))
                    throw TypeError(".tieba.PostInfoList.privSets: array expected");
                message.privSets = [];
                for (let i = 0; i < object.privSets.length; ++i) {
                    if (typeof object.privSets[i] !== "object")
                        throw TypeError(".tieba.PostInfoList.privSets: object expected");
                    message.privSets[i] = $root.tieba.PrivSets.fromObject(object.privSets[i]);
                }
            }
            if (object.isAuthorView != null)
                message.isAuthorView = object.isAuthorView | 0;
            if (object.isManager != null)
                message.isManager = object.isManager | 0;
            if (object.isOriginManager != null)
                message.isOriginManager = object.isOriginManager | 0;
            if (object.goodTypes != null)
                message.goodTypes = object.goodTypes | 0;
            if (object.topTypes != null)
                message.topTypes = object.topTypes | 0;
            if (object.userPostPerm != null) {
                if (typeof object.userPostPerm !== "object")
                    throw TypeError(".tieba.PostInfoList.userPostPerm: object expected");
                message.userPostPerm = $root.tieba.UserPostPerm.fromObject(object.userPostPerm);
            }
            if (object.targetScheme != null)
                message.targetScheme = String(object.targetScheme);
            return message;
        };

        /**
         * Creates a plain object from a PostInfoList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.PostInfoList
         * @static
         * @param {tieba.PostInfoList} message PostInfoList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostInfoList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.content = [];
                object.abstractThread = [];
                object.media = [];
                object.voiceInfo = [];
                object.multipleForumList = [];
                object.richTitle = [];
                object.richAbstract = [];
                object.firstPostContent = [];
                object.itemStar = [];
                object.pbLinkInfo = [];
                object.privSets = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.forumId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.forumId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.threadId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.postId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.postId = options.longs === String ? "0" : 0;
                object.isThread = 0;
                object.createTime = 0;
                object.forumName = "";
                object.title = "";
                object.contentThread = "";
                object.userName = "";
                object.ip = "";
                object.isPostDeleted = 0;
                object.ptype = "";
                object._abstract = "";
                object.replyNum = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
                object.userPortrait = "";
                object.postType = "";
                object.lbsInfo = null;
                object.quote = null;
                object.anchorInfo = null;
                object.hidePost = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.threadType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.threadType = options.longs === String ? "0" : 0;
                object.twzhiboInfo = null;
                object.pollInfo = null;
                object.videoInfo = null;
                object.isDeal = false;
                object.dealInfo = null;
                object.freqNum = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.vForumId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vForumId = options.longs === String ? "0" : 0;
                object.nameShow = "";
                object.alaInfo = null;
                object.agreeNum = 0;
                object.viewNum = 0;
                object.shareNum = 0;
                object.agree = null;
                object.isRemain = 0;
                object.originThreadInfo = null;
                object.isViewYear = 0;
                object.isShareThread = 0;
                object.isNtitle = 0;
                object.articleCover = "";
                object.baijiahaoInfo = null;
                object.wonderfulPostInfo = "";
                object.item = null;
                object.isAuthorView = 0;
                object.isManager = 0;
                object.isOriginManager = 0;
                object.goodTypes = 0;
                object.topTypes = 0;
                object.userPostPerm = null;
                object.targetScheme = "";
            }
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (typeof message.forumId === "number")
                    object.forumId = options.longs === String ? String(message.forumId) : message.forumId;
                else
                    object.forumId = options.longs === String ? $util.Long.prototype.toString.call(message.forumId) : options.longs === Number ? new $util.LongBits(message.forumId.low >>> 0, message.forumId.high >>> 0).toNumber(true) : message.forumId;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (typeof message.threadId === "number")
                    object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                else
                    object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber(true) : message.threadId;
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (typeof message.postId === "number")
                    object.postId = options.longs === String ? String(message.postId) : message.postId;
                else
                    object.postId = options.longs === String ? $util.Long.prototype.toString.call(message.postId) : options.longs === Number ? new $util.LongBits(message.postId.low >>> 0, message.postId.high >>> 0).toNumber(true) : message.postId;
            if (message.isThread != null && message.hasOwnProperty("isThread"))
                object.isThread = message.isThread;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                object.forumName = message.forumName;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.content && message.content.length) {
                object.content = [];
                for (let j = 0; j < message.content.length; ++j)
                    object.content[j] = $root.tieba.PostInfoContent.toObject(message.content[j], options);
            }
            if (message.contentThread != null && message.hasOwnProperty("contentThread"))
                object.contentThread = message.contentThread;
            if (message.userName != null && message.hasOwnProperty("userName"))
                object.userName = message.userName;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.isPostDeleted != null && message.hasOwnProperty("isPostDeleted"))
                object.isPostDeleted = message.isPostDeleted;
            if (message.ptype != null && message.hasOwnProperty("ptype"))
                object.ptype = message.ptype;
            if (message._abstract != null && message.hasOwnProperty("_abstract"))
                object._abstract = message._abstract;
            if (message.abstractThread && message.abstractThread.length) {
                object.abstractThread = [];
                for (let j = 0; j < message.abstractThread.length; ++j)
                    object.abstractThread[j] = $root.tieba.Abstract.toObject(message.abstractThread[j], options);
            }
            if (message.media && message.media.length) {
                object.media = [];
                for (let j = 0; j < message.media.length; ++j)
                    object.media[j] = $root.tieba.Media.toObject(message.media[j], options);
            }
            if (message.replyNum != null && message.hasOwnProperty("replyNum"))
                object.replyNum = message.replyNum;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
            if (message.userPortrait != null && message.hasOwnProperty("userPortrait"))
                object.userPortrait = message.userPortrait;
            if (message.postType != null && message.hasOwnProperty("postType"))
                object.postType = message.postType;
            if (message.lbsInfo != null && message.hasOwnProperty("lbsInfo"))
                object.lbsInfo = $root.tieba.LbsInfo.toObject(message.lbsInfo, options);
            if (message.quote != null && message.hasOwnProperty("quote"))
                object.quote = $root.tieba.Quote.toObject(message.quote, options);
            if (message.voiceInfo && message.voiceInfo.length) {
                object.voiceInfo = [];
                for (let j = 0; j < message.voiceInfo.length; ++j)
                    object.voiceInfo[j] = $root.tieba.Voice.toObject(message.voiceInfo[j], options);
            }
            if (message.anchorInfo != null && message.hasOwnProperty("anchorInfo"))
                object.anchorInfo = $root.tieba.AnchorInfo.toObject(message.anchorInfo, options);
            if (message.hidePost != null && message.hasOwnProperty("hidePost"))
                object.hidePost = message.hidePost;
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                if (typeof message.threadType === "number")
                    object.threadType = options.longs === String ? String(message.threadType) : message.threadType;
                else
                    object.threadType = options.longs === String ? $util.Long.prototype.toString.call(message.threadType) : options.longs === Number ? new $util.LongBits(message.threadType.low >>> 0, message.threadType.high >>> 0).toNumber(true) : message.threadType;
            if (message.twzhiboInfo != null && message.hasOwnProperty("twzhiboInfo"))
                object.twzhiboInfo = $root.tieba.ZhiBoInfoTW.toObject(message.twzhiboInfo, options);
            if (message.pollInfo != null && message.hasOwnProperty("pollInfo"))
                object.pollInfo = $root.tieba.PollInfo.toObject(message.pollInfo, options);
            if (message.videoInfo != null && message.hasOwnProperty("videoInfo"))
                object.videoInfo = $root.tieba.VideoInfo.toObject(message.videoInfo, options);
            if (message.isDeal != null && message.hasOwnProperty("isDeal"))
                object.isDeal = message.isDeal;
            if (message.dealInfo != null && message.hasOwnProperty("dealInfo"))
                object.dealInfo = $root.tieba.DealInfo.toObject(message.dealInfo, options);
            if (message.multipleForumList && message.multipleForumList.length) {
                object.multipleForumList = [];
                for (let j = 0; j < message.multipleForumList.length; ++j)
                    object.multipleForumList[j] = $root.tieba.MultipleForum.toObject(message.multipleForumList[j], options);
            }
            if (message.freqNum != null && message.hasOwnProperty("freqNum"))
                object.freqNum = message.freqNum;
            if (message.vForumId != null && message.hasOwnProperty("vForumId"))
                if (typeof message.vForumId === "number")
                    object.vForumId = options.longs === String ? String(message.vForumId) : message.vForumId;
                else
                    object.vForumId = options.longs === String ? $util.Long.prototype.toString.call(message.vForumId) : options.longs === Number ? new $util.LongBits(message.vForumId.low >>> 0, message.vForumId.high >>> 0).toNumber(true) : message.vForumId;
            if (message.nameShow != null && message.hasOwnProperty("nameShow"))
                object.nameShow = message.nameShow;
            if (message.alaInfo != null && message.hasOwnProperty("alaInfo"))
                object.alaInfo = $root.tieba.AlaLiveInfo.toObject(message.alaInfo, options);
            if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
                object.agreeNum = message.agreeNum;
            if (message.viewNum != null && message.hasOwnProperty("viewNum"))
                object.viewNum = message.viewNum;
            if (message.shareNum != null && message.hasOwnProperty("shareNum"))
                object.shareNum = message.shareNum;
            if (message.agree != null && message.hasOwnProperty("agree"))
                object.agree = $root.tieba.Agree.toObject(message.agree, options);
            if (message.isRemain != null && message.hasOwnProperty("isRemain"))
                object.isRemain = message.isRemain;
            if (message.originThreadInfo != null && message.hasOwnProperty("originThreadInfo"))
                object.originThreadInfo = $root.tieba.OriginThreadInfo.toObject(message.originThreadInfo, options);
            if (message.isViewYear != null && message.hasOwnProperty("isViewYear"))
                object.isViewYear = message.isViewYear;
            if (message.isShareThread != null && message.hasOwnProperty("isShareThread"))
                object.isShareThread = message.isShareThread;
            if (message.richTitle && message.richTitle.length) {
                object.richTitle = [];
                for (let j = 0; j < message.richTitle.length; ++j)
                    object.richTitle[j] = $root.tieba.PbContent.toObject(message.richTitle[j], options);
            }
            if (message.richAbstract && message.richAbstract.length) {
                object.richAbstract = [];
                for (let j = 0; j < message.richAbstract.length; ++j)
                    object.richAbstract[j] = $root.tieba.PbContent.toObject(message.richAbstract[j], options);
            }
            if (message.isNtitle != null && message.hasOwnProperty("isNtitle"))
                object.isNtitle = message.isNtitle;
            if (message.articleCover != null && message.hasOwnProperty("articleCover"))
                object.articleCover = message.articleCover;
            if (message.firstPostContent && message.firstPostContent.length) {
                object.firstPostContent = [];
                for (let j = 0; j < message.firstPostContent.length; ++j)
                    object.firstPostContent[j] = $root.tieba.PbContent.toObject(message.firstPostContent[j], options);
            }
            if (message.baijiahaoInfo != null && message.hasOwnProperty("baijiahaoInfo"))
                object.baijiahaoInfo = $root.tieba.BaijiahaoInfo.toObject(message.baijiahaoInfo, options);
            if (message.wonderfulPostInfo != null && message.hasOwnProperty("wonderfulPostInfo"))
                object.wonderfulPostInfo = message.wonderfulPostInfo;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.tieba.Item.toObject(message.item, options);
            if (message.itemStar && message.itemStar.length) {
                object.itemStar = [];
                for (let j = 0; j < message.itemStar.length; ++j)
                    object.itemStar[j] = $root.tieba.HeadItem.toObject(message.itemStar[j], options);
            }
            if (message.pbLinkInfo && message.pbLinkInfo.length) {
                object.pbLinkInfo = [];
                for (let j = 0; j < message.pbLinkInfo.length; ++j)
                    object.pbLinkInfo[j] = $root.tieba.PbLinkInfo.toObject(message.pbLinkInfo[j], options);
            }
            if (message.privSets && message.privSets.length) {
                object.privSets = [];
                for (let j = 0; j < message.privSets.length; ++j)
                    object.privSets[j] = $root.tieba.PrivSets.toObject(message.privSets[j], options);
            }
            if (message.isAuthorView != null && message.hasOwnProperty("isAuthorView"))
                object.isAuthorView = message.isAuthorView;
            if (message.isManager != null && message.hasOwnProperty("isManager"))
                object.isManager = message.isManager;
            if (message.isOriginManager != null && message.hasOwnProperty("isOriginManager"))
                object.isOriginManager = message.isOriginManager;
            if (message.goodTypes != null && message.hasOwnProperty("goodTypes"))
                object.goodTypes = message.goodTypes;
            if (message.topTypes != null && message.hasOwnProperty("topTypes"))
                object.topTypes = message.topTypes;
            if (message.userPostPerm != null && message.hasOwnProperty("userPostPerm"))
                object.userPostPerm = $root.tieba.UserPostPerm.toObject(message.userPostPerm, options);
            if (message.targetScheme != null && message.hasOwnProperty("targetScheme"))
                object.targetScheme = message.targetScheme;
            return object;
        };

        /**
         * Converts this PostInfoList to JSON.
         * @function toJSON
         * @memberof tieba.PostInfoList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostInfoList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PostInfoList
         * @function getTypeUrl
         * @memberof tieba.PostInfoList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PostInfoList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.PostInfoList";
        };

        return PostInfoList;
    })();

    tieba.AnchorInfo = (function() {

        /**
         * Properties of an AnchorInfo.
         * @memberof tieba
         * @interface IAnchorInfo
         * @property {string|null} [portrait] AnchorInfo portrait
         * @property {string|null} [name] AnchorInfo name
         * @property {number|null} [startTime] AnchorInfo startTime
         * @property {number|null} [status] AnchorInfo status
         * @property {number|Long|null} [authorId] AnchorInfo authorId
         * @property {string|null} [authorName] AnchorInfo authorName
         * @property {number|null} [listeners] AnchorInfo listeners
         * @property {number|null} [likers] AnchorInfo likers
         * @property {number|Long|null} [groupId] AnchorInfo groupId
         * @property {string|null} [intro] AnchorInfo intro
         * @property {string|null} [publisherPortrait] AnchorInfo publisherPortrait
         * @property {string|null} [publisherName] AnchorInfo publisherName
         * @property {number|Long|null} [publisherId] AnchorInfo publisherId
         * @property {string|null} [forumName] AnchorInfo forumName
         * @property {number|null} [fromType] AnchorInfo fromType
         * @property {number|null} [isVip] AnchorInfo isVip
         * @property {number|null} [labelId] AnchorInfo labelId
         * @property {string|null} [labelName] AnchorInfo labelName
         * @property {number|null} [type] AnchorInfo type
         * @property {tieba.IZhiBoInfoTW|null} [twzhiboInfo] AnchorInfo twzhiboInfo
         */

        /**
         * Constructs a new AnchorInfo.
         * @memberof tieba
         * @classdesc Represents an AnchorInfo.
         * @implements IAnchorInfo
         * @constructor
         * @param {tieba.IAnchorInfo=} [properties] Properties to set
         */
        function AnchorInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnchorInfo portrait.
         * @member {string} portrait
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.portrait = "";

        /**
         * AnchorInfo name.
         * @member {string} name
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.name = "";

        /**
         * AnchorInfo startTime.
         * @member {number} startTime
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.startTime = 0;

        /**
         * AnchorInfo status.
         * @member {number} status
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.status = 0;

        /**
         * AnchorInfo authorId.
         * @member {number|Long} authorId
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.authorId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnchorInfo authorName.
         * @member {string} authorName
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.authorName = "";

        /**
         * AnchorInfo listeners.
         * @member {number} listeners
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.listeners = 0;

        /**
         * AnchorInfo likers.
         * @member {number} likers
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.likers = 0;

        /**
         * AnchorInfo groupId.
         * @member {number|Long} groupId
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnchorInfo intro.
         * @member {string} intro
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.intro = "";

        /**
         * AnchorInfo publisherPortrait.
         * @member {string} publisherPortrait
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.publisherPortrait = "";

        /**
         * AnchorInfo publisherName.
         * @member {string} publisherName
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.publisherName = "";

        /**
         * AnchorInfo publisherId.
         * @member {number|Long} publisherId
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.publisherId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnchorInfo forumName.
         * @member {string} forumName
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.forumName = "";

        /**
         * AnchorInfo fromType.
         * @member {number} fromType
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.fromType = 0;

        /**
         * AnchorInfo isVip.
         * @member {number} isVip
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.isVip = 0;

        /**
         * AnchorInfo labelId.
         * @member {number} labelId
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.labelId = 0;

        /**
         * AnchorInfo labelName.
         * @member {string} labelName
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.labelName = "";

        /**
         * AnchorInfo type.
         * @member {number} type
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.type = 0;

        /**
         * AnchorInfo twzhiboInfo.
         * @member {tieba.IZhiBoInfoTW|null|undefined} twzhiboInfo
         * @memberof tieba.AnchorInfo
         * @instance
         */
        AnchorInfo.prototype.twzhiboInfo = null;

        /**
         * Creates a new AnchorInfo instance using the specified properties.
         * @function create
         * @memberof tieba.AnchorInfo
         * @static
         * @param {tieba.IAnchorInfo=} [properties] Properties to set
         * @returns {tieba.AnchorInfo} AnchorInfo instance
         */
        AnchorInfo.create = function create(properties) {
            return new AnchorInfo(properties);
        };

        /**
         * Encodes the specified AnchorInfo message. Does not implicitly {@link tieba.AnchorInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.AnchorInfo
         * @static
         * @param {tieba.IAnchorInfo} message AnchorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnchorInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.portrait);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.startTime);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            if (message.authorId != null && Object.hasOwnProperty.call(message, "authorId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.authorId);
            if (message.authorName != null && Object.hasOwnProperty.call(message, "authorName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.authorName);
            if (message.listeners != null && Object.hasOwnProperty.call(message, "listeners"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.listeners);
            if (message.likers != null && Object.hasOwnProperty.call(message, "likers"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.likers);
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.groupId);
            if (message.intro != null && Object.hasOwnProperty.call(message, "intro"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.intro);
            if (message.publisherPortrait != null && Object.hasOwnProperty.call(message, "publisherPortrait"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.publisherPortrait);
            if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.publisherName);
            if (message.publisherId != null && Object.hasOwnProperty.call(message, "publisherId"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.publisherId);
            if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.forumName);
            if (message.fromType != null && Object.hasOwnProperty.call(message, "fromType"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.fromType);
            if (message.isVip != null && Object.hasOwnProperty.call(message, "isVip"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.isVip);
            if (message.labelId != null && Object.hasOwnProperty.call(message, "labelId"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.labelId);
            if (message.labelName != null && Object.hasOwnProperty.call(message, "labelName"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.labelName);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.type);
            if (message.twzhiboInfo != null && Object.hasOwnProperty.call(message, "twzhiboInfo"))
                $root.tieba.ZhiBoInfoTW.encode(message.twzhiboInfo, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AnchorInfo message, length delimited. Does not implicitly {@link tieba.AnchorInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.AnchorInfo
         * @static
         * @param {tieba.IAnchorInfo} message AnchorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnchorInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnchorInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.AnchorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.AnchorInfo} AnchorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnchorInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.AnchorInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.portrait = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.startTime = reader.int32();
                        break;
                    }
                case 4: {
                        message.status = reader.int32();
                        break;
                    }
                case 5: {
                        message.authorId = reader.int64();
                        break;
                    }
                case 6: {
                        message.authorName = reader.string();
                        break;
                    }
                case 7: {
                        message.listeners = reader.int32();
                        break;
                    }
                case 8: {
                        message.likers = reader.int32();
                        break;
                    }
                case 9: {
                        message.groupId = reader.int64();
                        break;
                    }
                case 10: {
                        message.intro = reader.string();
                        break;
                    }
                case 11: {
                        message.publisherPortrait = reader.string();
                        break;
                    }
                case 12: {
                        message.publisherName = reader.string();
                        break;
                    }
                case 13: {
                        message.publisherId = reader.int64();
                        break;
                    }
                case 14: {
                        message.forumName = reader.string();
                        break;
                    }
                case 15: {
                        message.fromType = reader.int32();
                        break;
                    }
                case 16: {
                        message.isVip = reader.int32();
                        break;
                    }
                case 17: {
                        message.labelId = reader.int32();
                        break;
                    }
                case 18: {
                        message.labelName = reader.string();
                        break;
                    }
                case 19: {
                        message.type = reader.int32();
                        break;
                    }
                case 20: {
                        message.twzhiboInfo = $root.tieba.ZhiBoInfoTW.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnchorInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.AnchorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.AnchorInfo} AnchorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnchorInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnchorInfo message.
         * @function verify
         * @memberof tieba.AnchorInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnchorInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                if (!$util.isString(message.portrait))
                    return "portrait: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime))
                    return "startTime: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.authorId != null && message.hasOwnProperty("authorId"))
                if (!$util.isInteger(message.authorId) && !(message.authorId && $util.isInteger(message.authorId.low) && $util.isInteger(message.authorId.high)))
                    return "authorId: integer|Long expected";
            if (message.authorName != null && message.hasOwnProperty("authorName"))
                if (!$util.isString(message.authorName))
                    return "authorName: string expected";
            if (message.listeners != null && message.hasOwnProperty("listeners"))
                if (!$util.isInteger(message.listeners))
                    return "listeners: integer expected";
            if (message.likers != null && message.hasOwnProperty("likers"))
                if (!$util.isInteger(message.likers))
                    return "likers: integer expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                    return "groupId: integer|Long expected";
            if (message.intro != null && message.hasOwnProperty("intro"))
                if (!$util.isString(message.intro))
                    return "intro: string expected";
            if (message.publisherPortrait != null && message.hasOwnProperty("publisherPortrait"))
                if (!$util.isString(message.publisherPortrait))
                    return "publisherPortrait: string expected";
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                if (!$util.isString(message.publisherName))
                    return "publisherName: string expected";
            if (message.publisherId != null && message.hasOwnProperty("publisherId"))
                if (!$util.isInteger(message.publisherId) && !(message.publisherId && $util.isInteger(message.publisherId.low) && $util.isInteger(message.publisherId.high)))
                    return "publisherId: integer|Long expected";
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                if (!$util.isString(message.forumName))
                    return "forumName: string expected";
            if (message.fromType != null && message.hasOwnProperty("fromType"))
                if (!$util.isInteger(message.fromType))
                    return "fromType: integer expected";
            if (message.isVip != null && message.hasOwnProperty("isVip"))
                if (!$util.isInteger(message.isVip))
                    return "isVip: integer expected";
            if (message.labelId != null && message.hasOwnProperty("labelId"))
                if (!$util.isInteger(message.labelId))
                    return "labelId: integer expected";
            if (message.labelName != null && message.hasOwnProperty("labelName"))
                if (!$util.isString(message.labelName))
                    return "labelName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.twzhiboInfo != null && message.hasOwnProperty("twzhiboInfo")) {
                let error = $root.tieba.ZhiBoInfoTW.verify(message.twzhiboInfo);
                if (error)
                    return "twzhiboInfo." + error;
            }
            return null;
        };

        /**
         * Creates an AnchorInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.AnchorInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.AnchorInfo} AnchorInfo
         */
        AnchorInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.AnchorInfo)
                return object;
            let message = new $root.tieba.AnchorInfo();
            if (object.portrait != null)
                message.portrait = String(object.portrait);
            if (object.name != null)
                message.name = String(object.name);
            if (object.startTime != null)
                message.startTime = object.startTime | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.authorId != null)
                if ($util.Long)
                    (message.authorId = $util.Long.fromValue(object.authorId)).unsigned = false;
                else if (typeof object.authorId === "string")
                    message.authorId = parseInt(object.authorId, 10);
                else if (typeof object.authorId === "number")
                    message.authorId = object.authorId;
                else if (typeof object.authorId === "object")
                    message.authorId = new $util.LongBits(object.authorId.low >>> 0, object.authorId.high >>> 0).toNumber();
            if (object.authorName != null)
                message.authorName = String(object.authorName);
            if (object.listeners != null)
                message.listeners = object.listeners | 0;
            if (object.likers != null)
                message.likers = object.likers | 0;
            if (object.groupId != null)
                if ($util.Long)
                    (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = false;
                else if (typeof object.groupId === "string")
                    message.groupId = parseInt(object.groupId, 10);
                else if (typeof object.groupId === "number")
                    message.groupId = object.groupId;
                else if (typeof object.groupId === "object")
                    message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber();
            if (object.intro != null)
                message.intro = String(object.intro);
            if (object.publisherPortrait != null)
                message.publisherPortrait = String(object.publisherPortrait);
            if (object.publisherName != null)
                message.publisherName = String(object.publisherName);
            if (object.publisherId != null)
                if ($util.Long)
                    (message.publisherId = $util.Long.fromValue(object.publisherId)).unsigned = false;
                else if (typeof object.publisherId === "string")
                    message.publisherId = parseInt(object.publisherId, 10);
                else if (typeof object.publisherId === "number")
                    message.publisherId = object.publisherId;
                else if (typeof object.publisherId === "object")
                    message.publisherId = new $util.LongBits(object.publisherId.low >>> 0, object.publisherId.high >>> 0).toNumber();
            if (object.forumName != null)
                message.forumName = String(object.forumName);
            if (object.fromType != null)
                message.fromType = object.fromType | 0;
            if (object.isVip != null)
                message.isVip = object.isVip | 0;
            if (object.labelId != null)
                message.labelId = object.labelId | 0;
            if (object.labelName != null)
                message.labelName = String(object.labelName);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.twzhiboInfo != null) {
                if (typeof object.twzhiboInfo !== "object")
                    throw TypeError(".tieba.AnchorInfo.twzhiboInfo: object expected");
                message.twzhiboInfo = $root.tieba.ZhiBoInfoTW.fromObject(object.twzhiboInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from an AnchorInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.AnchorInfo
         * @static
         * @param {tieba.AnchorInfo} message AnchorInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnchorInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.portrait = "";
                object.name = "";
                object.startTime = 0;
                object.status = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.authorId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.authorId = options.longs === String ? "0" : 0;
                object.authorName = "";
                object.listeners = 0;
                object.likers = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.groupId = options.longs === String ? "0" : 0;
                object.intro = "";
                object.publisherPortrait = "";
                object.publisherName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.publisherId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publisherId = options.longs === String ? "0" : 0;
                object.forumName = "";
                object.fromType = 0;
                object.isVip = 0;
                object.labelId = 0;
                object.labelName = "";
                object.type = 0;
                object.twzhiboInfo = null;
            }
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                object.portrait = message.portrait;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                object.startTime = message.startTime;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.authorId != null && message.hasOwnProperty("authorId"))
                if (typeof message.authorId === "number")
                    object.authorId = options.longs === String ? String(message.authorId) : message.authorId;
                else
                    object.authorId = options.longs === String ? $util.Long.prototype.toString.call(message.authorId) : options.longs === Number ? new $util.LongBits(message.authorId.low >>> 0, message.authorId.high >>> 0).toNumber() : message.authorId;
            if (message.authorName != null && message.hasOwnProperty("authorName"))
                object.authorName = message.authorName;
            if (message.listeners != null && message.hasOwnProperty("listeners"))
                object.listeners = message.listeners;
            if (message.likers != null && message.hasOwnProperty("likers"))
                object.likers = message.likers;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (typeof message.groupId === "number")
                    object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                else
                    object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber() : message.groupId;
            if (message.intro != null && message.hasOwnProperty("intro"))
                object.intro = message.intro;
            if (message.publisherPortrait != null && message.hasOwnProperty("publisherPortrait"))
                object.publisherPortrait = message.publisherPortrait;
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                object.publisherName = message.publisherName;
            if (message.publisherId != null && message.hasOwnProperty("publisherId"))
                if (typeof message.publisherId === "number")
                    object.publisherId = options.longs === String ? String(message.publisherId) : message.publisherId;
                else
                    object.publisherId = options.longs === String ? $util.Long.prototype.toString.call(message.publisherId) : options.longs === Number ? new $util.LongBits(message.publisherId.low >>> 0, message.publisherId.high >>> 0).toNumber() : message.publisherId;
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                object.forumName = message.forumName;
            if (message.fromType != null && message.hasOwnProperty("fromType"))
                object.fromType = message.fromType;
            if (message.isVip != null && message.hasOwnProperty("isVip"))
                object.isVip = message.isVip;
            if (message.labelId != null && message.hasOwnProperty("labelId"))
                object.labelId = message.labelId;
            if (message.labelName != null && message.hasOwnProperty("labelName"))
                object.labelName = message.labelName;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.twzhiboInfo != null && message.hasOwnProperty("twzhiboInfo"))
                object.twzhiboInfo = $root.tieba.ZhiBoInfoTW.toObject(message.twzhiboInfo, options);
            return object;
        };

        /**
         * Converts this AnchorInfo to JSON.
         * @function toJSON
         * @memberof tieba.AnchorInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnchorInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AnchorInfo
         * @function getTypeUrl
         * @memberof tieba.AnchorInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AnchorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.AnchorInfo";
        };

        return AnchorInfo;
    })();

    tieba.ZhiBoInfoTW = (function() {

        /**
         * Properties of a ZhiBoInfoTW.
         * @memberof tieba
         * @interface IZhiBoInfoTW
         * @property {number|Long|null} [threadId] ZhiBoInfoTW threadId
         * @property {string|null} [livecoverSrc] ZhiBoInfoTW livecoverSrc
         * @property {string|null} [livecoverSrcBsize] ZhiBoInfoTW livecoverSrcBsize
         * @property {number|null} [postNum] ZhiBoInfoTW postNum
         * @property {number|null} [replyNum] ZhiBoInfoTW replyNum
         * @property {tieba.IZan|null} [zan] ZhiBoInfoTW zan
         * @property {string|null} [forumName] ZhiBoInfoTW forumName
         * @property {number|Long|null} [forumId] ZhiBoInfoTW forumId
         * @property {number|Long|null} [lastModifiedTime] ZhiBoInfoTW lastModifiedTime
         * @property {string|null} [title] ZhiBoInfoTW title
         * @property {string|null} [content] ZhiBoInfoTW content
         * @property {tieba.IUser|null} [user] ZhiBoInfoTW user
         * @property {tieba.IHotTWThreadInfo|null} [hotTwInfo] ZhiBoInfoTW hotTwInfo
         * @property {Array.<tieba.ILabelInfo>|null} [labelInfo] ZhiBoInfoTW labelInfo
         * @property {string|null} [livecoverSrcStatus] ZhiBoInfoTW livecoverSrcStatus
         * @property {tieba.INoticeInfo|null} [noticeInfo] ZhiBoInfoTW noticeInfo
         * @property {number|null} [isHeadline] ZhiBoInfoTW isHeadline
         * @property {tieba.ILiveCoverStatus|null} [livecoverStatus] ZhiBoInfoTW livecoverStatus
         * @property {number|null} [freqNum] ZhiBoInfoTW freqNum
         * @property {number|null} [copythreadRemind] ZhiBoInfoTW copythreadRemind
         * @property {number|null} [isCopytwzhibo] ZhiBoInfoTW isCopytwzhibo
         * @property {string|null} [fieldEx] ZhiBoInfoTW fieldEx
         */

        /**
         * Constructs a new ZhiBoInfoTW.
         * @memberof tieba
         * @classdesc Represents a ZhiBoInfoTW.
         * @implements IZhiBoInfoTW
         * @constructor
         * @param {tieba.IZhiBoInfoTW=} [properties] Properties to set
         */
        function ZhiBoInfoTW(properties) {
            this.labelInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZhiBoInfoTW threadId.
         * @member {number|Long} threadId
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.threadId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ZhiBoInfoTW livecoverSrc.
         * @member {string} livecoverSrc
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.livecoverSrc = "";

        /**
         * ZhiBoInfoTW livecoverSrcBsize.
         * @member {string} livecoverSrcBsize
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.livecoverSrcBsize = "";

        /**
         * ZhiBoInfoTW postNum.
         * @member {number} postNum
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.postNum = 0;

        /**
         * ZhiBoInfoTW replyNum.
         * @member {number} replyNum
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.replyNum = 0;

        /**
         * ZhiBoInfoTW zan.
         * @member {tieba.IZan|null|undefined} zan
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.zan = null;

        /**
         * ZhiBoInfoTW forumName.
         * @member {string} forumName
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.forumName = "";

        /**
         * ZhiBoInfoTW forumId.
         * @member {number|Long} forumId
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.forumId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ZhiBoInfoTW lastModifiedTime.
         * @member {number|Long} lastModifiedTime
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.lastModifiedTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ZhiBoInfoTW title.
         * @member {string} title
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.title = "";

        /**
         * ZhiBoInfoTW content.
         * @member {string} content
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.content = "";

        /**
         * ZhiBoInfoTW user.
         * @member {tieba.IUser|null|undefined} user
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.user = null;

        /**
         * ZhiBoInfoTW hotTwInfo.
         * @member {tieba.IHotTWThreadInfo|null|undefined} hotTwInfo
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.hotTwInfo = null;

        /**
         * ZhiBoInfoTW labelInfo.
         * @member {Array.<tieba.ILabelInfo>} labelInfo
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.labelInfo = $util.emptyArray;

        /**
         * ZhiBoInfoTW livecoverSrcStatus.
         * @member {string} livecoverSrcStatus
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.livecoverSrcStatus = "";

        /**
         * ZhiBoInfoTW noticeInfo.
         * @member {tieba.INoticeInfo|null|undefined} noticeInfo
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.noticeInfo = null;

        /**
         * ZhiBoInfoTW isHeadline.
         * @member {number} isHeadline
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.isHeadline = 0;

        /**
         * ZhiBoInfoTW livecoverStatus.
         * @member {tieba.ILiveCoverStatus|null|undefined} livecoverStatus
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.livecoverStatus = null;

        /**
         * ZhiBoInfoTW freqNum.
         * @member {number} freqNum
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.freqNum = 0;

        /**
         * ZhiBoInfoTW copythreadRemind.
         * @member {number} copythreadRemind
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.copythreadRemind = 0;

        /**
         * ZhiBoInfoTW isCopytwzhibo.
         * @member {number} isCopytwzhibo
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.isCopytwzhibo = 0;

        /**
         * ZhiBoInfoTW fieldEx.
         * @member {string} fieldEx
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         */
        ZhiBoInfoTW.prototype.fieldEx = "";

        /**
         * Creates a new ZhiBoInfoTW instance using the specified properties.
         * @function create
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {tieba.IZhiBoInfoTW=} [properties] Properties to set
         * @returns {tieba.ZhiBoInfoTW} ZhiBoInfoTW instance
         */
        ZhiBoInfoTW.create = function create(properties) {
            return new ZhiBoInfoTW(properties);
        };

        /**
         * Encodes the specified ZhiBoInfoTW message. Does not implicitly {@link tieba.ZhiBoInfoTW.verify|verify} messages.
         * @function encode
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {tieba.IZhiBoInfoTW} message ZhiBoInfoTW message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZhiBoInfoTW.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.threadId);
            if (message.livecoverSrc != null && Object.hasOwnProperty.call(message, "livecoverSrc"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.livecoverSrc);
            if (message.livecoverSrcBsize != null && Object.hasOwnProperty.call(message, "livecoverSrcBsize"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.livecoverSrcBsize);
            if (message.postNum != null && Object.hasOwnProperty.call(message, "postNum"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.postNum);
            if (message.replyNum != null && Object.hasOwnProperty.call(message, "replyNum"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.replyNum);
            if (message.zan != null && Object.hasOwnProperty.call(message, "zan"))
                $root.tieba.Zan.encode(message.zan, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.forumName);
            if (message.forumId != null && Object.hasOwnProperty.call(message, "forumId"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.forumId);
            if (message.lastModifiedTime != null && Object.hasOwnProperty.call(message, "lastModifiedTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.lastModifiedTime);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.title);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.content);
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                $root.tieba.User.encode(message.user, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.hotTwInfo != null && Object.hasOwnProperty.call(message, "hotTwInfo"))
                $root.tieba.HotTWThreadInfo.encode(message.hotTwInfo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.labelInfo != null && message.labelInfo.length)
                for (let i = 0; i < message.labelInfo.length; ++i)
                    $root.tieba.LabelInfo.encode(message.labelInfo[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.livecoverSrcStatus != null && Object.hasOwnProperty.call(message, "livecoverSrcStatus"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.livecoverSrcStatus);
            if (message.noticeInfo != null && Object.hasOwnProperty.call(message, "noticeInfo"))
                $root.tieba.NoticeInfo.encode(message.noticeInfo, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.isHeadline != null && Object.hasOwnProperty.call(message, "isHeadline"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.isHeadline);
            if (message.livecoverStatus != null && Object.hasOwnProperty.call(message, "livecoverStatus"))
                $root.tieba.LiveCoverStatus.encode(message.livecoverStatus, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.freqNum != null && Object.hasOwnProperty.call(message, "freqNum"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.freqNum);
            if (message.copythreadRemind != null && Object.hasOwnProperty.call(message, "copythreadRemind"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.copythreadRemind);
            if (message.isCopytwzhibo != null && Object.hasOwnProperty.call(message, "isCopytwzhibo"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.isCopytwzhibo);
            if (message.fieldEx != null && Object.hasOwnProperty.call(message, "fieldEx"))
                writer.uint32(/* id 22, wireType 2 =*/178).string(message.fieldEx);
            return writer;
        };

        /**
         * Encodes the specified ZhiBoInfoTW message, length delimited. Does not implicitly {@link tieba.ZhiBoInfoTW.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {tieba.IZhiBoInfoTW} message ZhiBoInfoTW message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZhiBoInfoTW.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZhiBoInfoTW message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.ZhiBoInfoTW} ZhiBoInfoTW
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZhiBoInfoTW.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.ZhiBoInfoTW();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.threadId = reader.uint64();
                        break;
                    }
                case 2: {
                        message.livecoverSrc = reader.string();
                        break;
                    }
                case 3: {
                        message.livecoverSrcBsize = reader.string();
                        break;
                    }
                case 4: {
                        message.postNum = reader.uint32();
                        break;
                    }
                case 5: {
                        message.replyNum = reader.uint32();
                        break;
                    }
                case 6: {
                        message.zan = $root.tieba.Zan.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.forumName = reader.string();
                        break;
                    }
                case 8: {
                        message.forumId = reader.uint64();
                        break;
                    }
                case 9: {
                        message.lastModifiedTime = reader.uint64();
                        break;
                    }
                case 10: {
                        message.title = reader.string();
                        break;
                    }
                case 11: {
                        message.content = reader.string();
                        break;
                    }
                case 12: {
                        message.user = $root.tieba.User.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.hotTwInfo = $root.tieba.HotTWThreadInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        if (!(message.labelInfo && message.labelInfo.length))
                            message.labelInfo = [];
                        message.labelInfo.push($root.tieba.LabelInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 15: {
                        message.livecoverSrcStatus = reader.string();
                        break;
                    }
                case 16: {
                        message.noticeInfo = $root.tieba.NoticeInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.isHeadline = reader.int32();
                        break;
                    }
                case 18: {
                        message.livecoverStatus = $root.tieba.LiveCoverStatus.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.freqNum = reader.uint32();
                        break;
                    }
                case 20: {
                        message.copythreadRemind = reader.uint32();
                        break;
                    }
                case 21: {
                        message.isCopytwzhibo = reader.uint32();
                        break;
                    }
                case 22: {
                        message.fieldEx = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZhiBoInfoTW message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.ZhiBoInfoTW} ZhiBoInfoTW
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZhiBoInfoTW.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZhiBoInfoTW message.
         * @function verify
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZhiBoInfoTW.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                    return "threadId: integer|Long expected";
            if (message.livecoverSrc != null && message.hasOwnProperty("livecoverSrc"))
                if (!$util.isString(message.livecoverSrc))
                    return "livecoverSrc: string expected";
            if (message.livecoverSrcBsize != null && message.hasOwnProperty("livecoverSrcBsize"))
                if (!$util.isString(message.livecoverSrcBsize))
                    return "livecoverSrcBsize: string expected";
            if (message.postNum != null && message.hasOwnProperty("postNum"))
                if (!$util.isInteger(message.postNum))
                    return "postNum: integer expected";
            if (message.replyNum != null && message.hasOwnProperty("replyNum"))
                if (!$util.isInteger(message.replyNum))
                    return "replyNum: integer expected";
            if (message.zan != null && message.hasOwnProperty("zan")) {
                let error = $root.tieba.Zan.verify(message.zan);
                if (error)
                    return "zan." + error;
            }
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                if (!$util.isString(message.forumName))
                    return "forumName: string expected";
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (!$util.isInteger(message.forumId) && !(message.forumId && $util.isInteger(message.forumId.low) && $util.isInteger(message.forumId.high)))
                    return "forumId: integer|Long expected";
            if (message.lastModifiedTime != null && message.hasOwnProperty("lastModifiedTime"))
                if (!$util.isInteger(message.lastModifiedTime) && !(message.lastModifiedTime && $util.isInteger(message.lastModifiedTime.low) && $util.isInteger(message.lastModifiedTime.high)))
                    return "lastModifiedTime: integer|Long expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.user != null && message.hasOwnProperty("user")) {
                let error = $root.tieba.User.verify(message.user);
                if (error)
                    return "user." + error;
            }
            if (message.hotTwInfo != null && message.hasOwnProperty("hotTwInfo")) {
                let error = $root.tieba.HotTWThreadInfo.verify(message.hotTwInfo);
                if (error)
                    return "hotTwInfo." + error;
            }
            if (message.labelInfo != null && message.hasOwnProperty("labelInfo")) {
                if (!Array.isArray(message.labelInfo))
                    return "labelInfo: array expected";
                for (let i = 0; i < message.labelInfo.length; ++i) {
                    let error = $root.tieba.LabelInfo.verify(message.labelInfo[i]);
                    if (error)
                        return "labelInfo." + error;
                }
            }
            if (message.livecoverSrcStatus != null && message.hasOwnProperty("livecoverSrcStatus"))
                if (!$util.isString(message.livecoverSrcStatus))
                    return "livecoverSrcStatus: string expected";
            if (message.noticeInfo != null && message.hasOwnProperty("noticeInfo")) {
                let error = $root.tieba.NoticeInfo.verify(message.noticeInfo);
                if (error)
                    return "noticeInfo." + error;
            }
            if (message.isHeadline != null && message.hasOwnProperty("isHeadline"))
                if (!$util.isInteger(message.isHeadline))
                    return "isHeadline: integer expected";
            if (message.livecoverStatus != null && message.hasOwnProperty("livecoverStatus")) {
                let error = $root.tieba.LiveCoverStatus.verify(message.livecoverStatus);
                if (error)
                    return "livecoverStatus." + error;
            }
            if (message.freqNum != null && message.hasOwnProperty("freqNum"))
                if (!$util.isInteger(message.freqNum))
                    return "freqNum: integer expected";
            if (message.copythreadRemind != null && message.hasOwnProperty("copythreadRemind"))
                if (!$util.isInteger(message.copythreadRemind))
                    return "copythreadRemind: integer expected";
            if (message.isCopytwzhibo != null && message.hasOwnProperty("isCopytwzhibo"))
                if (!$util.isInteger(message.isCopytwzhibo))
                    return "isCopytwzhibo: integer expected";
            if (message.fieldEx != null && message.hasOwnProperty("fieldEx"))
                if (!$util.isString(message.fieldEx))
                    return "fieldEx: string expected";
            return null;
        };

        /**
         * Creates a ZhiBoInfoTW message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.ZhiBoInfoTW} ZhiBoInfoTW
         */
        ZhiBoInfoTW.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.ZhiBoInfoTW)
                return object;
            let message = new $root.tieba.ZhiBoInfoTW();
            if (object.threadId != null)
                if ($util.Long)
                    (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = true;
                else if (typeof object.threadId === "string")
                    message.threadId = parseInt(object.threadId, 10);
                else if (typeof object.threadId === "number")
                    message.threadId = object.threadId;
                else if (typeof object.threadId === "object")
                    message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber(true);
            if (object.livecoverSrc != null)
                message.livecoverSrc = String(object.livecoverSrc);
            if (object.livecoverSrcBsize != null)
                message.livecoverSrcBsize = String(object.livecoverSrcBsize);
            if (object.postNum != null)
                message.postNum = object.postNum >>> 0;
            if (object.replyNum != null)
                message.replyNum = object.replyNum >>> 0;
            if (object.zan != null) {
                if (typeof object.zan !== "object")
                    throw TypeError(".tieba.ZhiBoInfoTW.zan: object expected");
                message.zan = $root.tieba.Zan.fromObject(object.zan);
            }
            if (object.forumName != null)
                message.forumName = String(object.forumName);
            if (object.forumId != null)
                if ($util.Long)
                    (message.forumId = $util.Long.fromValue(object.forumId)).unsigned = true;
                else if (typeof object.forumId === "string")
                    message.forumId = parseInt(object.forumId, 10);
                else if (typeof object.forumId === "number")
                    message.forumId = object.forumId;
                else if (typeof object.forumId === "object")
                    message.forumId = new $util.LongBits(object.forumId.low >>> 0, object.forumId.high >>> 0).toNumber(true);
            if (object.lastModifiedTime != null)
                if ($util.Long)
                    (message.lastModifiedTime = $util.Long.fromValue(object.lastModifiedTime)).unsigned = true;
                else if (typeof object.lastModifiedTime === "string")
                    message.lastModifiedTime = parseInt(object.lastModifiedTime, 10);
                else if (typeof object.lastModifiedTime === "number")
                    message.lastModifiedTime = object.lastModifiedTime;
                else if (typeof object.lastModifiedTime === "object")
                    message.lastModifiedTime = new $util.LongBits(object.lastModifiedTime.low >>> 0, object.lastModifiedTime.high >>> 0).toNumber(true);
            if (object.title != null)
                message.title = String(object.title);
            if (object.content != null)
                message.content = String(object.content);
            if (object.user != null) {
                if (typeof object.user !== "object")
                    throw TypeError(".tieba.ZhiBoInfoTW.user: object expected");
                message.user = $root.tieba.User.fromObject(object.user);
            }
            if (object.hotTwInfo != null) {
                if (typeof object.hotTwInfo !== "object")
                    throw TypeError(".tieba.ZhiBoInfoTW.hotTwInfo: object expected");
                message.hotTwInfo = $root.tieba.HotTWThreadInfo.fromObject(object.hotTwInfo);
            }
            if (object.labelInfo) {
                if (!Array.isArray(object.labelInfo))
                    throw TypeError(".tieba.ZhiBoInfoTW.labelInfo: array expected");
                message.labelInfo = [];
                for (let i = 0; i < object.labelInfo.length; ++i) {
                    if (typeof object.labelInfo[i] !== "object")
                        throw TypeError(".tieba.ZhiBoInfoTW.labelInfo: object expected");
                    message.labelInfo[i] = $root.tieba.LabelInfo.fromObject(object.labelInfo[i]);
                }
            }
            if (object.livecoverSrcStatus != null)
                message.livecoverSrcStatus = String(object.livecoverSrcStatus);
            if (object.noticeInfo != null) {
                if (typeof object.noticeInfo !== "object")
                    throw TypeError(".tieba.ZhiBoInfoTW.noticeInfo: object expected");
                message.noticeInfo = $root.tieba.NoticeInfo.fromObject(object.noticeInfo);
            }
            if (object.isHeadline != null)
                message.isHeadline = object.isHeadline | 0;
            if (object.livecoverStatus != null) {
                if (typeof object.livecoverStatus !== "object")
                    throw TypeError(".tieba.ZhiBoInfoTW.livecoverStatus: object expected");
                message.livecoverStatus = $root.tieba.LiveCoverStatus.fromObject(object.livecoverStatus);
            }
            if (object.freqNum != null)
                message.freqNum = object.freqNum >>> 0;
            if (object.copythreadRemind != null)
                message.copythreadRemind = object.copythreadRemind >>> 0;
            if (object.isCopytwzhibo != null)
                message.isCopytwzhibo = object.isCopytwzhibo >>> 0;
            if (object.fieldEx != null)
                message.fieldEx = String(object.fieldEx);
            return message;
        };

        /**
         * Creates a plain object from a ZhiBoInfoTW message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {tieba.ZhiBoInfoTW} message ZhiBoInfoTW
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZhiBoInfoTW.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.labelInfo = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.threadId = options.longs === String ? "0" : 0;
                object.livecoverSrc = "";
                object.livecoverSrcBsize = "";
                object.postNum = 0;
                object.replyNum = 0;
                object.zan = null;
                object.forumName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.forumId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.forumId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lastModifiedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastModifiedTime = options.longs === String ? "0" : 0;
                object.title = "";
                object.content = "";
                object.user = null;
                object.hotTwInfo = null;
                object.livecoverSrcStatus = "";
                object.noticeInfo = null;
                object.isHeadline = 0;
                object.livecoverStatus = null;
                object.freqNum = 0;
                object.copythreadRemind = 0;
                object.isCopytwzhibo = 0;
                object.fieldEx = "";
            }
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (typeof message.threadId === "number")
                    object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                else
                    object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber(true) : message.threadId;
            if (message.livecoverSrc != null && message.hasOwnProperty("livecoverSrc"))
                object.livecoverSrc = message.livecoverSrc;
            if (message.livecoverSrcBsize != null && message.hasOwnProperty("livecoverSrcBsize"))
                object.livecoverSrcBsize = message.livecoverSrcBsize;
            if (message.postNum != null && message.hasOwnProperty("postNum"))
                object.postNum = message.postNum;
            if (message.replyNum != null && message.hasOwnProperty("replyNum"))
                object.replyNum = message.replyNum;
            if (message.zan != null && message.hasOwnProperty("zan"))
                object.zan = $root.tieba.Zan.toObject(message.zan, options);
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                object.forumName = message.forumName;
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (typeof message.forumId === "number")
                    object.forumId = options.longs === String ? String(message.forumId) : message.forumId;
                else
                    object.forumId = options.longs === String ? $util.Long.prototype.toString.call(message.forumId) : options.longs === Number ? new $util.LongBits(message.forumId.low >>> 0, message.forumId.high >>> 0).toNumber(true) : message.forumId;
            if (message.lastModifiedTime != null && message.hasOwnProperty("lastModifiedTime"))
                if (typeof message.lastModifiedTime === "number")
                    object.lastModifiedTime = options.longs === String ? String(message.lastModifiedTime) : message.lastModifiedTime;
                else
                    object.lastModifiedTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastModifiedTime) : options.longs === Number ? new $util.LongBits(message.lastModifiedTime.low >>> 0, message.lastModifiedTime.high >>> 0).toNumber(true) : message.lastModifiedTime;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = $root.tieba.User.toObject(message.user, options);
            if (message.hotTwInfo != null && message.hasOwnProperty("hotTwInfo"))
                object.hotTwInfo = $root.tieba.HotTWThreadInfo.toObject(message.hotTwInfo, options);
            if (message.labelInfo && message.labelInfo.length) {
                object.labelInfo = [];
                for (let j = 0; j < message.labelInfo.length; ++j)
                    object.labelInfo[j] = $root.tieba.LabelInfo.toObject(message.labelInfo[j], options);
            }
            if (message.livecoverSrcStatus != null && message.hasOwnProperty("livecoverSrcStatus"))
                object.livecoverSrcStatus = message.livecoverSrcStatus;
            if (message.noticeInfo != null && message.hasOwnProperty("noticeInfo"))
                object.noticeInfo = $root.tieba.NoticeInfo.toObject(message.noticeInfo, options);
            if (message.isHeadline != null && message.hasOwnProperty("isHeadline"))
                object.isHeadline = message.isHeadline;
            if (message.livecoverStatus != null && message.hasOwnProperty("livecoverStatus"))
                object.livecoverStatus = $root.tieba.LiveCoverStatus.toObject(message.livecoverStatus, options);
            if (message.freqNum != null && message.hasOwnProperty("freqNum"))
                object.freqNum = message.freqNum;
            if (message.copythreadRemind != null && message.hasOwnProperty("copythreadRemind"))
                object.copythreadRemind = message.copythreadRemind;
            if (message.isCopytwzhibo != null && message.hasOwnProperty("isCopytwzhibo"))
                object.isCopytwzhibo = message.isCopytwzhibo;
            if (message.fieldEx != null && message.hasOwnProperty("fieldEx"))
                object.fieldEx = message.fieldEx;
            return object;
        };

        /**
         * Converts this ZhiBoInfoTW to JSON.
         * @function toJSON
         * @memberof tieba.ZhiBoInfoTW
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZhiBoInfoTW.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ZhiBoInfoTW
         * @function getTypeUrl
         * @memberof tieba.ZhiBoInfoTW
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ZhiBoInfoTW.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.ZhiBoInfoTW";
        };

        return ZhiBoInfoTW;
    })();

    tieba.HotTWThreadInfo = (function() {

        /**
         * Properties of a HotTWThreadInfo.
         * @memberof tieba
         * @interface IHotTWThreadInfo
         * @property {Array.<tieba.IUser>|null} [userList] HotTWThreadInfo userList
         * @property {number|null} [fansCount] HotTWThreadInfo fansCount
         */

        /**
         * Constructs a new HotTWThreadInfo.
         * @memberof tieba
         * @classdesc Represents a HotTWThreadInfo.
         * @implements IHotTWThreadInfo
         * @constructor
         * @param {tieba.IHotTWThreadInfo=} [properties] Properties to set
         */
        function HotTWThreadInfo(properties) {
            this.userList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HotTWThreadInfo userList.
         * @member {Array.<tieba.IUser>} userList
         * @memberof tieba.HotTWThreadInfo
         * @instance
         */
        HotTWThreadInfo.prototype.userList = $util.emptyArray;

        /**
         * HotTWThreadInfo fansCount.
         * @member {number} fansCount
         * @memberof tieba.HotTWThreadInfo
         * @instance
         */
        HotTWThreadInfo.prototype.fansCount = 0;

        /**
         * Creates a new HotTWThreadInfo instance using the specified properties.
         * @function create
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {tieba.IHotTWThreadInfo=} [properties] Properties to set
         * @returns {tieba.HotTWThreadInfo} HotTWThreadInfo instance
         */
        HotTWThreadInfo.create = function create(properties) {
            return new HotTWThreadInfo(properties);
        };

        /**
         * Encodes the specified HotTWThreadInfo message. Does not implicitly {@link tieba.HotTWThreadInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {tieba.IHotTWThreadInfo} message HotTWThreadInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HotTWThreadInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userList != null && message.userList.length)
                for (let i = 0; i < message.userList.length; ++i)
                    $root.tieba.User.encode(message.userList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.fansCount != null && Object.hasOwnProperty.call(message, "fansCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fansCount);
            return writer;
        };

        /**
         * Encodes the specified HotTWThreadInfo message, length delimited. Does not implicitly {@link tieba.HotTWThreadInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {tieba.IHotTWThreadInfo} message HotTWThreadInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HotTWThreadInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HotTWThreadInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.HotTWThreadInfo} HotTWThreadInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HotTWThreadInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.HotTWThreadInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.userList && message.userList.length))
                            message.userList = [];
                        message.userList.push($root.tieba.User.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.fansCount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HotTWThreadInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.HotTWThreadInfo} HotTWThreadInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HotTWThreadInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HotTWThreadInfo message.
         * @function verify
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HotTWThreadInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userList != null && message.hasOwnProperty("userList")) {
                if (!Array.isArray(message.userList))
                    return "userList: array expected";
                for (let i = 0; i < message.userList.length; ++i) {
                    let error = $root.tieba.User.verify(message.userList[i]);
                    if (error)
                        return "userList." + error;
                }
            }
            if (message.fansCount != null && message.hasOwnProperty("fansCount"))
                if (!$util.isInteger(message.fansCount))
                    return "fansCount: integer expected";
            return null;
        };

        /**
         * Creates a HotTWThreadInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.HotTWThreadInfo} HotTWThreadInfo
         */
        HotTWThreadInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.HotTWThreadInfo)
                return object;
            let message = new $root.tieba.HotTWThreadInfo();
            if (object.userList) {
                if (!Array.isArray(object.userList))
                    throw TypeError(".tieba.HotTWThreadInfo.userList: array expected");
                message.userList = [];
                for (let i = 0; i < object.userList.length; ++i) {
                    if (typeof object.userList[i] !== "object")
                        throw TypeError(".tieba.HotTWThreadInfo.userList: object expected");
                    message.userList[i] = $root.tieba.User.fromObject(object.userList[i]);
                }
            }
            if (object.fansCount != null)
                message.fansCount = object.fansCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HotTWThreadInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {tieba.HotTWThreadInfo} message HotTWThreadInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HotTWThreadInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.userList = [];
            if (options.defaults)
                object.fansCount = 0;
            if (message.userList && message.userList.length) {
                object.userList = [];
                for (let j = 0; j < message.userList.length; ++j)
                    object.userList[j] = $root.tieba.User.toObject(message.userList[j], options);
            }
            if (message.fansCount != null && message.hasOwnProperty("fansCount"))
                object.fansCount = message.fansCount;
            return object;
        };

        /**
         * Converts this HotTWThreadInfo to JSON.
         * @function toJSON
         * @memberof tieba.HotTWThreadInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HotTWThreadInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for HotTWThreadInfo
         * @function getTypeUrl
         * @memberof tieba.HotTWThreadInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HotTWThreadInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.HotTWThreadInfo";
        };

        return HotTWThreadInfo;
    })();

    tieba.User = (function() {

        /**
         * Properties of a User.
         * @memberof tieba
         * @interface IUser
         * @property {number|null} [isLogin] User isLogin
         * @property {number|Long|null} [id] User id
         * @property {string|null} [name] User name
         * @property {string|null} [nameShow] User nameShow
         * @property {string|null} [portrait] User portrait
         * @property {number|null} [noUn] User noUn
         * @property {number|null} [type] User type
         * @property {number|null} [userhide] User userhide
         * @property {number|null} [isManager] User isManager
         * @property {string|null} [rank] User rank
         * @property {string|null} [bimgUrl] User bimgUrl
         * @property {number|null} [meizhiLevel] User meizhiLevel
         * @property {number|null} [isVerify] User isVerify
         * @property {number|null} [isInterestman] User isInterestman
         * @property {Array.<tieba.IIcon>|null} [iconinfo] User iconinfo
         * @property {number|null} [userType] User userType
         * @property {number|null} [isCoreuser] User isCoreuser
         * @property {number|null} [isHuinibuke] User isHuinibuke
         * @property {string|null} [iosBimgFormat] User iosBimgFormat
         * @property {number|null} [levelId] User levelId
         * @property {number|null} [isLike] User isLike
         * @property {number|null} [isBawu] User isBawu
         * @property {string|null} [bawuType] User bawuType
         * @property {string|null} [portraith] User portraith
         * @property {string|null} [ip] User ip
         * @property {string|null} [BDUSS] User BDUSS
         * @property {number|null} [fansNum] User fansNum
         * @property {number|null} [concernNum] User concernNum
         * @property {number|null} [sex] User sex
         * @property {number|null} [myLikeNum] User myLikeNum
         * @property {string|null} [intro] User intro
         * @property {number|null} [hasConcerned] User hasConcerned
         * @property {string|null} [passwd] User passwd
         * @property {number|null} [postNum] User postNum
         * @property {string|null} [tbAge] User tbAge
         * @property {number|null} [isMem] User isMem
         * @property {number|null} [bimgEndTime] User bimgEndTime
         * @property {number|null} [gender] User gender
         * @property {number|null} [isMask] User isMask
         * @property {Array.<tieba.IUserPics>|null} [userPics] User userPics
         * @property {tieba.IPrivSets|null} [privSets] User privSets
         * @property {number|null} [isFriend] User isFriend
         * @property {Array.<tieba.ILikeForumInfo>|null} [likeForum] User likeForum
         * @property {number|null} [giftNum] User giftNum
         * @property {number|null} [isSelectTail] User isSelectTail
         * @property {number|null} [isGuanfang] User isGuanfang
         * @property {number|null} [bookmarkCount] User bookmarkCount
         * @property {number|null} [bookmarkNewCount] User bookmarkNewCount
         * @property {Array.<tieba.ISimpleUser>|null} [muteUser] User muteUser
         * @property {number|Long|null} [friendNum] User friendNum
         * @property {string|null} [fansNickname] User fansNickname
         * @property {string|null} [bgPic] User bgPic
         * @property {tieba.IGodInfo|null} [godData] User godData
         * @property {number|null} [heavyUser] User heavyUser
         * @property {number|null} [visitorNum] User visitorNum
         * @property {number|null} [totalVisitorNum] User totalVisitorNum
         * @property {number|null} [nicknameUpdateTime] User nicknameUpdateTime
         * @property {number|null} [threadNum] User threadNum
         * @property {number|null} [agreeNum] User agreeNum
         * @property {number|null} [leftCallNum] User leftCallNum
         * @property {number|null} [isInvited] User isInvited
         * @property {number|null} [isFans] User isFans
         * @property {number|null} [privThread] User privThread
         * @property {number|null} [isVideobiggie] User isVideobiggie
         * @property {number|null} [isShowRedpacket] User isShowRedpacket
         * @property {tieba.IBirthdayInfo|null} [birthdayInfo] User birthdayInfo
         * @property {number|null} [canModifyAvatar] User canModifyAvatar
         * @property {string|null} [modifyAvatarDesc] User modifyAvatarDesc
         * @property {number|null} [influence] User influence
         * @property {string|null} [levelInfluence] User levelInfluence
         * @property {tieba.INewGodInfo|null} [newGodData] User newGodData
         * @property {tieba.IBawuThrones|null} [bawuThrones] User bawuThrones
         * @property {tieba.IBazhuSign|null} [bazhuGrade] User bazhuGrade
         * @property {number|null} [isDefaultAvatar] User isDefaultAvatar
         * @property {number|null} [favoriteNum] User favoriteNum
         * @property {number|null} [totalAgreeNum] User totalAgreeNum
         * @property {string|null} [tiebaUid] User tiebaUid
         * @property {string|null} [levelName] User levelName
         * @property {string|null} [ipAddress] User ipAddress
         * @property {number|null} [isNicknameEditing] User isNicknameEditing
         * @property {string|null} [editingNickname] User editingNickname
         * @property {string|null} [displayIntro] User displayIntro
         * @property {Array.<string>|null} [newIconUrl] User newIconUrl
         * @property {string|null} [dynamicUrl] User dynamicUrl
         */

        /**
         * Constructs a new User.
         * @memberof tieba
         * @classdesc Represents a User.
         * @implements IUser
         * @constructor
         * @param {tieba.IUser=} [properties] Properties to set
         */
        function User(properties) {
            this.iconinfo = [];
            this.userPics = [];
            this.likeForum = [];
            this.muteUser = [];
            this.newIconUrl = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * User isLogin.
         * @member {number} isLogin
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isLogin = 0;

        /**
         * User id.
         * @member {number|Long} id
         * @memberof tieba.User
         * @instance
         */
        User.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * User name.
         * @member {string} name
         * @memberof tieba.User
         * @instance
         */
        User.prototype.name = "";

        /**
         * User nameShow.
         * @member {string} nameShow
         * @memberof tieba.User
         * @instance
         */
        User.prototype.nameShow = "";

        /**
         * User portrait.
         * @member {string} portrait
         * @memberof tieba.User
         * @instance
         */
        User.prototype.portrait = "";

        /**
         * User noUn.
         * @member {number} noUn
         * @memberof tieba.User
         * @instance
         */
        User.prototype.noUn = 0;

        /**
         * User type.
         * @member {number} type
         * @memberof tieba.User
         * @instance
         */
        User.prototype.type = 0;

        /**
         * User userhide.
         * @member {number} userhide
         * @memberof tieba.User
         * @instance
         */
        User.prototype.userhide = 0;

        /**
         * User isManager.
         * @member {number} isManager
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isManager = 0;

        /**
         * User rank.
         * @member {string} rank
         * @memberof tieba.User
         * @instance
         */
        User.prototype.rank = "";

        /**
         * User bimgUrl.
         * @member {string} bimgUrl
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bimgUrl = "";

        /**
         * User meizhiLevel.
         * @member {number} meizhiLevel
         * @memberof tieba.User
         * @instance
         */
        User.prototype.meizhiLevel = 0;

        /**
         * User isVerify.
         * @member {number} isVerify
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isVerify = 0;

        /**
         * User isInterestman.
         * @member {number} isInterestman
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isInterestman = 0;

        /**
         * User iconinfo.
         * @member {Array.<tieba.IIcon>} iconinfo
         * @memberof tieba.User
         * @instance
         */
        User.prototype.iconinfo = $util.emptyArray;

        /**
         * User userType.
         * @member {number} userType
         * @memberof tieba.User
         * @instance
         */
        User.prototype.userType = 0;

        /**
         * User isCoreuser.
         * @member {number} isCoreuser
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isCoreuser = 0;

        /**
         * User isHuinibuke.
         * @member {number} isHuinibuke
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isHuinibuke = 0;

        /**
         * User iosBimgFormat.
         * @member {string} iosBimgFormat
         * @memberof tieba.User
         * @instance
         */
        User.prototype.iosBimgFormat = "";

        /**
         * User levelId.
         * @member {number} levelId
         * @memberof tieba.User
         * @instance
         */
        User.prototype.levelId = 0;

        /**
         * User isLike.
         * @member {number} isLike
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isLike = 0;

        /**
         * User isBawu.
         * @member {number} isBawu
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isBawu = 0;

        /**
         * User bawuType.
         * @member {string} bawuType
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bawuType = "";

        /**
         * User portraith.
         * @member {string} portraith
         * @memberof tieba.User
         * @instance
         */
        User.prototype.portraith = "";

        /**
         * User ip.
         * @member {string} ip
         * @memberof tieba.User
         * @instance
         */
        User.prototype.ip = "";

        /**
         * User BDUSS.
         * @member {string} BDUSS
         * @memberof tieba.User
         * @instance
         */
        User.prototype.BDUSS = "";

        /**
         * User fansNum.
         * @member {number} fansNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.fansNum = 0;

        /**
         * User concernNum.
         * @member {number} concernNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.concernNum = 0;

        /**
         * User sex.
         * @member {number} sex
         * @memberof tieba.User
         * @instance
         */
        User.prototype.sex = 0;

        /**
         * User myLikeNum.
         * @member {number} myLikeNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.myLikeNum = 0;

        /**
         * User intro.
         * @member {string} intro
         * @memberof tieba.User
         * @instance
         */
        User.prototype.intro = "";

        /**
         * User hasConcerned.
         * @member {number} hasConcerned
         * @memberof tieba.User
         * @instance
         */
        User.prototype.hasConcerned = 0;

        /**
         * User passwd.
         * @member {string} passwd
         * @memberof tieba.User
         * @instance
         */
        User.prototype.passwd = "";

        /**
         * User postNum.
         * @member {number} postNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.postNum = 0;

        /**
         * User tbAge.
         * @member {string} tbAge
         * @memberof tieba.User
         * @instance
         */
        User.prototype.tbAge = "";

        /**
         * User isMem.
         * @member {number} isMem
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isMem = 0;

        /**
         * User bimgEndTime.
         * @member {number} bimgEndTime
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bimgEndTime = 0;

        /**
         * User gender.
         * @member {number} gender
         * @memberof tieba.User
         * @instance
         */
        User.prototype.gender = 0;

        /**
         * User isMask.
         * @member {number} isMask
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isMask = 0;

        /**
         * User userPics.
         * @member {Array.<tieba.IUserPics>} userPics
         * @memberof tieba.User
         * @instance
         */
        User.prototype.userPics = $util.emptyArray;

        /**
         * User privSets.
         * @member {tieba.IPrivSets|null|undefined} privSets
         * @memberof tieba.User
         * @instance
         */
        User.prototype.privSets = null;

        /**
         * User isFriend.
         * @member {number} isFriend
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isFriend = 0;

        /**
         * User likeForum.
         * @member {Array.<tieba.ILikeForumInfo>} likeForum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.likeForum = $util.emptyArray;

        /**
         * User giftNum.
         * @member {number} giftNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.giftNum = 0;

        /**
         * User isSelectTail.
         * @member {number} isSelectTail
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isSelectTail = 0;

        /**
         * User isGuanfang.
         * @member {number} isGuanfang
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isGuanfang = 0;

        /**
         * User bookmarkCount.
         * @member {number} bookmarkCount
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bookmarkCount = 0;

        /**
         * User bookmarkNewCount.
         * @member {number} bookmarkNewCount
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bookmarkNewCount = 0;

        /**
         * User muteUser.
         * @member {Array.<tieba.ISimpleUser>} muteUser
         * @memberof tieba.User
         * @instance
         */
        User.prototype.muteUser = $util.emptyArray;

        /**
         * User friendNum.
         * @member {number|Long} friendNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.friendNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * User fansNickname.
         * @member {string} fansNickname
         * @memberof tieba.User
         * @instance
         */
        User.prototype.fansNickname = "";

        /**
         * User bgPic.
         * @member {string} bgPic
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bgPic = "";

        /**
         * User godData.
         * @member {tieba.IGodInfo|null|undefined} godData
         * @memberof tieba.User
         * @instance
         */
        User.prototype.godData = null;

        /**
         * User heavyUser.
         * @member {number} heavyUser
         * @memberof tieba.User
         * @instance
         */
        User.prototype.heavyUser = 0;

        /**
         * User visitorNum.
         * @member {number} visitorNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.visitorNum = 0;

        /**
         * User totalVisitorNum.
         * @member {number} totalVisitorNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.totalVisitorNum = 0;

        /**
         * User nicknameUpdateTime.
         * @member {number} nicknameUpdateTime
         * @memberof tieba.User
         * @instance
         */
        User.prototype.nicknameUpdateTime = 0;

        /**
         * User threadNum.
         * @member {number} threadNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.threadNum = 0;

        /**
         * User agreeNum.
         * @member {number} agreeNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.agreeNum = 0;

        /**
         * User leftCallNum.
         * @member {number} leftCallNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.leftCallNum = 0;

        /**
         * User isInvited.
         * @member {number} isInvited
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isInvited = 0;

        /**
         * User isFans.
         * @member {number} isFans
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isFans = 0;

        /**
         * User privThread.
         * @member {number} privThread
         * @memberof tieba.User
         * @instance
         */
        User.prototype.privThread = 0;

        /**
         * User isVideobiggie.
         * @member {number} isVideobiggie
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isVideobiggie = 0;

        /**
         * User isShowRedpacket.
         * @member {number} isShowRedpacket
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isShowRedpacket = 0;

        /**
         * User birthdayInfo.
         * @member {tieba.IBirthdayInfo|null|undefined} birthdayInfo
         * @memberof tieba.User
         * @instance
         */
        User.prototype.birthdayInfo = null;

        /**
         * User canModifyAvatar.
         * @member {number} canModifyAvatar
         * @memberof tieba.User
         * @instance
         */
        User.prototype.canModifyAvatar = 0;

        /**
         * User modifyAvatarDesc.
         * @member {string} modifyAvatarDesc
         * @memberof tieba.User
         * @instance
         */
        User.prototype.modifyAvatarDesc = "";

        /**
         * User influence.
         * @member {number} influence
         * @memberof tieba.User
         * @instance
         */
        User.prototype.influence = 0;

        /**
         * User levelInfluence.
         * @member {string} levelInfluence
         * @memberof tieba.User
         * @instance
         */
        User.prototype.levelInfluence = "";

        /**
         * User newGodData.
         * @member {tieba.INewGodInfo|null|undefined} newGodData
         * @memberof tieba.User
         * @instance
         */
        User.prototype.newGodData = null;

        /**
         * User bawuThrones.
         * @member {tieba.IBawuThrones|null|undefined} bawuThrones
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bawuThrones = null;

        /**
         * User bazhuGrade.
         * @member {tieba.IBazhuSign|null|undefined} bazhuGrade
         * @memberof tieba.User
         * @instance
         */
        User.prototype.bazhuGrade = null;

        /**
         * User isDefaultAvatar.
         * @member {number} isDefaultAvatar
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isDefaultAvatar = 0;

        /**
         * User favoriteNum.
         * @member {number} favoriteNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.favoriteNum = 0;

        /**
         * User totalAgreeNum.
         * @member {number} totalAgreeNum
         * @memberof tieba.User
         * @instance
         */
        User.prototype.totalAgreeNum = 0;

        /**
         * User tiebaUid.
         * @member {string} tiebaUid
         * @memberof tieba.User
         * @instance
         */
        User.prototype.tiebaUid = "";

        /**
         * User levelName.
         * @member {string} levelName
         * @memberof tieba.User
         * @instance
         */
        User.prototype.levelName = "";

        /**
         * User ipAddress.
         * @member {string} ipAddress
         * @memberof tieba.User
         * @instance
         */
        User.prototype.ipAddress = "";

        /**
         * User isNicknameEditing.
         * @member {number} isNicknameEditing
         * @memberof tieba.User
         * @instance
         */
        User.prototype.isNicknameEditing = 0;

        /**
         * User editingNickname.
         * @member {string} editingNickname
         * @memberof tieba.User
         * @instance
         */
        User.prototype.editingNickname = "";

        /**
         * User displayIntro.
         * @member {string} displayIntro
         * @memberof tieba.User
         * @instance
         */
        User.prototype.displayIntro = "";

        /**
         * User newIconUrl.
         * @member {Array.<string>} newIconUrl
         * @memberof tieba.User
         * @instance
         */
        User.prototype.newIconUrl = $util.emptyArray;

        /**
         * User dynamicUrl.
         * @member {string} dynamicUrl
         * @memberof tieba.User
         * @instance
         */
        User.prototype.dynamicUrl = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        // Virtual OneOf for proto3 optional field
        Object.defineProperty(User.prototype, "_newGodData", {
            get: $util.oneOfGetter($oneOfFields = ["newGodData"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new User instance using the specified properties.
         * @function create
         * @memberof tieba.User
         * @static
         * @param {tieba.IUser=} [properties] Properties to set
         * @returns {tieba.User} User instance
         */
        User.create = function create(properties) {
            return new User(properties);
        };

        /**
         * Encodes the specified User message. Does not implicitly {@link tieba.User.verify|verify} messages.
         * @function encode
         * @memberof tieba.User
         * @static
         * @param {tieba.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isLogin != null && Object.hasOwnProperty.call(message, "isLogin"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isLogin);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.nameShow != null && Object.hasOwnProperty.call(message, "nameShow"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nameShow);
            if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.portrait);
            if (message.noUn != null && Object.hasOwnProperty.call(message, "noUn"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.noUn);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
            if (message.userhide != null && Object.hasOwnProperty.call(message, "userhide"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.userhide);
            if (message.isManager != null && Object.hasOwnProperty.call(message, "isManager"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.isManager);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.rank);
            if (message.bimgUrl != null && Object.hasOwnProperty.call(message, "bimgUrl"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.bimgUrl);
            if (message.meizhiLevel != null && Object.hasOwnProperty.call(message, "meizhiLevel"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.meizhiLevel);
            if (message.isVerify != null && Object.hasOwnProperty.call(message, "isVerify"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.isVerify);
            if (message.isInterestman != null && Object.hasOwnProperty.call(message, "isInterestman"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.isInterestman);
            if (message.iconinfo != null && message.iconinfo.length)
                for (let i = 0; i < message.iconinfo.length; ++i)
                    $root.tieba.Icon.encode(message.iconinfo[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.userType != null && Object.hasOwnProperty.call(message, "userType"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.userType);
            if (message.isCoreuser != null && Object.hasOwnProperty.call(message, "isCoreuser"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.isCoreuser);
            if (message.isHuinibuke != null && Object.hasOwnProperty.call(message, "isHuinibuke"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.isHuinibuke);
            if (message.iosBimgFormat != null && Object.hasOwnProperty.call(message, "iosBimgFormat"))
                writer.uint32(/* id 22, wireType 2 =*/178).string(message.iosBimgFormat);
            if (message.levelId != null && Object.hasOwnProperty.call(message, "levelId"))
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.levelId);
            if (message.isLike != null && Object.hasOwnProperty.call(message, "isLike"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.isLike);
            if (message.isBawu != null && Object.hasOwnProperty.call(message, "isBawu"))
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.isBawu);
            if (message.bawuType != null && Object.hasOwnProperty.call(message, "bawuType"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.bawuType);
            if (message.portraith != null && Object.hasOwnProperty.call(message, "portraith"))
                writer.uint32(/* id 27, wireType 2 =*/218).string(message.portraith);
            if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                writer.uint32(/* id 28, wireType 2 =*/226).string(message.ip);
            if (message.BDUSS != null && Object.hasOwnProperty.call(message, "BDUSS"))
                writer.uint32(/* id 29, wireType 2 =*/234).string(message.BDUSS);
            if (message.fansNum != null && Object.hasOwnProperty.call(message, "fansNum"))
                writer.uint32(/* id 30, wireType 0 =*/240).int32(message.fansNum);
            if (message.concernNum != null && Object.hasOwnProperty.call(message, "concernNum"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.concernNum);
            if (message.sex != null && Object.hasOwnProperty.call(message, "sex"))
                writer.uint32(/* id 32, wireType 0 =*/256).int32(message.sex);
            if (message.myLikeNum != null && Object.hasOwnProperty.call(message, "myLikeNum"))
                writer.uint32(/* id 33, wireType 0 =*/264).int32(message.myLikeNum);
            if (message.intro != null && Object.hasOwnProperty.call(message, "intro"))
                writer.uint32(/* id 34, wireType 2 =*/274).string(message.intro);
            if (message.hasConcerned != null && Object.hasOwnProperty.call(message, "hasConcerned"))
                writer.uint32(/* id 35, wireType 0 =*/280).int32(message.hasConcerned);
            if (message.passwd != null && Object.hasOwnProperty.call(message, "passwd"))
                writer.uint32(/* id 36, wireType 2 =*/290).string(message.passwd);
            if (message.postNum != null && Object.hasOwnProperty.call(message, "postNum"))
                writer.uint32(/* id 37, wireType 0 =*/296).int32(message.postNum);
            if (message.tbAge != null && Object.hasOwnProperty.call(message, "tbAge"))
                writer.uint32(/* id 38, wireType 2 =*/306).string(message.tbAge);
            if (message.isMem != null && Object.hasOwnProperty.call(message, "isMem"))
                writer.uint32(/* id 39, wireType 0 =*/312).int32(message.isMem);
            if (message.bimgEndTime != null && Object.hasOwnProperty.call(message, "bimgEndTime"))
                writer.uint32(/* id 40, wireType 0 =*/320).int32(message.bimgEndTime);
            if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                writer.uint32(/* id 42, wireType 0 =*/336).int32(message.gender);
            if (message.isMask != null && Object.hasOwnProperty.call(message, "isMask"))
                writer.uint32(/* id 43, wireType 0 =*/344).int32(message.isMask);
            if (message.userPics != null && message.userPics.length)
                for (let i = 0; i < message.userPics.length; ++i)
                    $root.tieba.UserPics.encode(message.userPics[i], writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.privSets != null && Object.hasOwnProperty.call(message, "privSets"))
                $root.tieba.PrivSets.encode(message.privSets, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.isFriend != null && Object.hasOwnProperty.call(message, "isFriend"))
                writer.uint32(/* id 46, wireType 0 =*/368).int32(message.isFriend);
            if (message.likeForum != null && message.likeForum.length)
                for (let i = 0; i < message.likeForum.length; ++i)
                    $root.tieba.LikeForumInfo.encode(message.likeForum[i], writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
            if (message.giftNum != null && Object.hasOwnProperty.call(message, "giftNum"))
                writer.uint32(/* id 49, wireType 0 =*/392).int32(message.giftNum);
            if (message.isSelectTail != null && Object.hasOwnProperty.call(message, "isSelectTail"))
                writer.uint32(/* id 51, wireType 0 =*/408).int32(message.isSelectTail);
            if (message.isGuanfang != null && Object.hasOwnProperty.call(message, "isGuanfang"))
                writer.uint32(/* id 52, wireType 0 =*/416).int32(message.isGuanfang);
            if (message.bookmarkCount != null && Object.hasOwnProperty.call(message, "bookmarkCount"))
                writer.uint32(/* id 53, wireType 0 =*/424).int32(message.bookmarkCount);
            if (message.bookmarkNewCount != null && Object.hasOwnProperty.call(message, "bookmarkNewCount"))
                writer.uint32(/* id 54, wireType 0 =*/432).int32(message.bookmarkNewCount);
            if (message.muteUser != null && message.muteUser.length)
                for (let i = 0; i < message.muteUser.length; ++i)
                    $root.tieba.SimpleUser.encode(message.muteUser[i], writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
            if (message.friendNum != null && Object.hasOwnProperty.call(message, "friendNum"))
                writer.uint32(/* id 56, wireType 0 =*/448).int64(message.friendNum);
            if (message.fansNickname != null && Object.hasOwnProperty.call(message, "fansNickname"))
                writer.uint32(/* id 57, wireType 2 =*/458).string(message.fansNickname);
            if (message.bgPic != null && Object.hasOwnProperty.call(message, "bgPic"))
                writer.uint32(/* id 58, wireType 2 =*/466).string(message.bgPic);
            if (message.godData != null && Object.hasOwnProperty.call(message, "godData"))
                $root.tieba.GodInfo.encode(message.godData, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
            if (message.heavyUser != null && Object.hasOwnProperty.call(message, "heavyUser"))
                writer.uint32(/* id 63, wireType 0 =*/504).int32(message.heavyUser);
            if (message.visitorNum != null && Object.hasOwnProperty.call(message, "visitorNum"))
                writer.uint32(/* id 75, wireType 0 =*/600).int32(message.visitorNum);
            if (message.totalVisitorNum != null && Object.hasOwnProperty.call(message, "totalVisitorNum"))
                writer.uint32(/* id 76, wireType 0 =*/608).int32(message.totalVisitorNum);
            if (message.nicknameUpdateTime != null && Object.hasOwnProperty.call(message, "nicknameUpdateTime"))
                writer.uint32(/* id 86, wireType 0 =*/688).int32(message.nicknameUpdateTime);
            if (message.threadNum != null && Object.hasOwnProperty.call(message, "threadNum"))
                writer.uint32(/* id 87, wireType 0 =*/696).int32(message.threadNum);
            if (message.agreeNum != null && Object.hasOwnProperty.call(message, "agreeNum"))
                writer.uint32(/* id 88, wireType 0 =*/704).int32(message.agreeNum);
            if (message.leftCallNum != null && Object.hasOwnProperty.call(message, "leftCallNum"))
                writer.uint32(/* id 89, wireType 0 =*/712).int32(message.leftCallNum);
            if (message.isInvited != null && Object.hasOwnProperty.call(message, "isInvited"))
                writer.uint32(/* id 90, wireType 0 =*/720).int32(message.isInvited);
            if (message.isFans != null && Object.hasOwnProperty.call(message, "isFans"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.isFans);
            if (message.privThread != null && Object.hasOwnProperty.call(message, "privThread"))
                writer.uint32(/* id 92, wireType 0 =*/736).int32(message.privThread);
            if (message.isVideobiggie != null && Object.hasOwnProperty.call(message, "isVideobiggie"))
                writer.uint32(/* id 93, wireType 0 =*/744).int32(message.isVideobiggie);
            if (message.isShowRedpacket != null && Object.hasOwnProperty.call(message, "isShowRedpacket"))
                writer.uint32(/* id 94, wireType 0 =*/752).int32(message.isShowRedpacket);
            if (message.birthdayInfo != null && Object.hasOwnProperty.call(message, "birthdayInfo"))
                $root.tieba.BirthdayInfo.encode(message.birthdayInfo, writer.uint32(/* id 96, wireType 2 =*/770).fork()).ldelim();
            if (message.canModifyAvatar != null && Object.hasOwnProperty.call(message, "canModifyAvatar"))
                writer.uint32(/* id 97, wireType 0 =*/776).int32(message.canModifyAvatar);
            if (message.modifyAvatarDesc != null && Object.hasOwnProperty.call(message, "modifyAvatarDesc"))
                writer.uint32(/* id 98, wireType 2 =*/786).string(message.modifyAvatarDesc);
            if (message.influence != null && Object.hasOwnProperty.call(message, "influence"))
                writer.uint32(/* id 99, wireType 0 =*/792).int32(message.influence);
            if (message.levelInfluence != null && Object.hasOwnProperty.call(message, "levelInfluence"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.levelInfluence);
            if (message.newGodData != null && Object.hasOwnProperty.call(message, "newGodData"))
                $root.tieba.NewGodInfo.encode(message.newGodData, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.bawuThrones != null && Object.hasOwnProperty.call(message, "bawuThrones"))
                $root.tieba.BawuThrones.encode(message.bawuThrones, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
            if (message.bazhuGrade != null && Object.hasOwnProperty.call(message, "bazhuGrade"))
                $root.tieba.BazhuSign.encode(message.bazhuGrade, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
            if (message.isDefaultAvatar != null && Object.hasOwnProperty.call(message, "isDefaultAvatar"))
                writer.uint32(/* id 106, wireType 0 =*/848).int32(message.isDefaultAvatar);
            if (message.favoriteNum != null && Object.hasOwnProperty.call(message, "favoriteNum"))
                writer.uint32(/* id 109, wireType 0 =*/872).int32(message.favoriteNum);
            if (message.totalAgreeNum != null && Object.hasOwnProperty.call(message, "totalAgreeNum"))
                writer.uint32(/* id 118, wireType 0 =*/944).uint32(message.totalAgreeNum);
            if (message.tiebaUid != null && Object.hasOwnProperty.call(message, "tiebaUid"))
                writer.uint32(/* id 120, wireType 2 =*/962).string(message.tiebaUid);
            if (message.levelName != null && Object.hasOwnProperty.call(message, "levelName"))
                writer.uint32(/* id 125, wireType 2 =*/1002).string(message.levelName);
            if (message.ipAddress != null && Object.hasOwnProperty.call(message, "ipAddress"))
                writer.uint32(/* id 127, wireType 2 =*/1018).string(message.ipAddress);
            if (message.isNicknameEditing != null && Object.hasOwnProperty.call(message, "isNicknameEditing"))
                writer.uint32(/* id 128, wireType 0 =*/1024).int32(message.isNicknameEditing);
            if (message.editingNickname != null && Object.hasOwnProperty.call(message, "editingNickname"))
                writer.uint32(/* id 129, wireType 2 =*/1034).string(message.editingNickname);
            if (message.displayIntro != null && Object.hasOwnProperty.call(message, "displayIntro"))
                writer.uint32(/* id 138, wireType 2 =*/1106).string(message.displayIntro);
            if (message.newIconUrl != null && message.newIconUrl.length)
                for (let i = 0; i < message.newIconUrl.length; ++i)
                    writer.uint32(/* id 139, wireType 2 =*/1114).string(message.newIconUrl[i]);
            if (message.dynamicUrl != null && Object.hasOwnProperty.call(message, "dynamicUrl"))
                writer.uint32(/* id 140, wireType 2 =*/1122).string(message.dynamicUrl);
            return writer;
        };

        /**
         * Encodes the specified User message, length delimited. Does not implicitly {@link tieba.User.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.User
         * @static
         * @param {tieba.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a User message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.User();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isLogin = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int64();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.nameShow = reader.string();
                        break;
                    }
                case 5: {
                        message.portrait = reader.string();
                        break;
                    }
                case 6: {
                        message.noUn = reader.int32();
                        break;
                    }
                case 7: {
                        message.type = reader.int32();
                        break;
                    }
                case 9: {
                        message.userhide = reader.int32();
                        break;
                    }
                case 11: {
                        message.isManager = reader.int32();
                        break;
                    }
                case 12: {
                        message.rank = reader.string();
                        break;
                    }
                case 13: {
                        message.bimgUrl = reader.string();
                        break;
                    }
                case 14: {
                        message.meizhiLevel = reader.int32();
                        break;
                    }
                case 15: {
                        message.isVerify = reader.int32();
                        break;
                    }
                case 16: {
                        message.isInterestman = reader.int32();
                        break;
                    }
                case 17: {
                        if (!(message.iconinfo && message.iconinfo.length))
                            message.iconinfo = [];
                        message.iconinfo.push($root.tieba.Icon.decode(reader, reader.uint32()));
                        break;
                    }
                case 19: {
                        message.userType = reader.int32();
                        break;
                    }
                case 20: {
                        message.isCoreuser = reader.int32();
                        break;
                    }
                case 21: {
                        message.isHuinibuke = reader.int32();
                        break;
                    }
                case 22: {
                        message.iosBimgFormat = reader.string();
                        break;
                    }
                case 23: {
                        message.levelId = reader.int32();
                        break;
                    }
                case 24: {
                        message.isLike = reader.int32();
                        break;
                    }
                case 25: {
                        message.isBawu = reader.int32();
                        break;
                    }
                case 26: {
                        message.bawuType = reader.string();
                        break;
                    }
                case 27: {
                        message.portraith = reader.string();
                        break;
                    }
                case 28: {
                        message.ip = reader.string();
                        break;
                    }
                case 29: {
                        message.BDUSS = reader.string();
                        break;
                    }
                case 30: {
                        message.fansNum = reader.int32();
                        break;
                    }
                case 31: {
                        message.concernNum = reader.int32();
                        break;
                    }
                case 32: {
                        message.sex = reader.int32();
                        break;
                    }
                case 33: {
                        message.myLikeNum = reader.int32();
                        break;
                    }
                case 34: {
                        message.intro = reader.string();
                        break;
                    }
                case 35: {
                        message.hasConcerned = reader.int32();
                        break;
                    }
                case 36: {
                        message.passwd = reader.string();
                        break;
                    }
                case 37: {
                        message.postNum = reader.int32();
                        break;
                    }
                case 38: {
                        message.tbAge = reader.string();
                        break;
                    }
                case 39: {
                        message.isMem = reader.int32();
                        break;
                    }
                case 40: {
                        message.bimgEndTime = reader.int32();
                        break;
                    }
                case 42: {
                        message.gender = reader.int32();
                        break;
                    }
                case 43: {
                        message.isMask = reader.int32();
                        break;
                    }
                case 44: {
                        if (!(message.userPics && message.userPics.length))
                            message.userPics = [];
                        message.userPics.push($root.tieba.UserPics.decode(reader, reader.uint32()));
                        break;
                    }
                case 45: {
                        message.privSets = $root.tieba.PrivSets.decode(reader, reader.uint32());
                        break;
                    }
                case 46: {
                        message.isFriend = reader.int32();
                        break;
                    }
                case 47: {
                        if (!(message.likeForum && message.likeForum.length))
                            message.likeForum = [];
                        message.likeForum.push($root.tieba.LikeForumInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 49: {
                        message.giftNum = reader.int32();
                        break;
                    }
                case 51: {
                        message.isSelectTail = reader.int32();
                        break;
                    }
                case 52: {
                        message.isGuanfang = reader.int32();
                        break;
                    }
                case 53: {
                        message.bookmarkCount = reader.int32();
                        break;
                    }
                case 54: {
                        message.bookmarkNewCount = reader.int32();
                        break;
                    }
                case 55: {
                        if (!(message.muteUser && message.muteUser.length))
                            message.muteUser = [];
                        message.muteUser.push($root.tieba.SimpleUser.decode(reader, reader.uint32()));
                        break;
                    }
                case 56: {
                        message.friendNum = reader.int64();
                        break;
                    }
                case 57: {
                        message.fansNickname = reader.string();
                        break;
                    }
                case 58: {
                        message.bgPic = reader.string();
                        break;
                    }
                case 62: {
                        message.godData = $root.tieba.GodInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 63: {
                        message.heavyUser = reader.int32();
                        break;
                    }
                case 75: {
                        message.visitorNum = reader.int32();
                        break;
                    }
                case 76: {
                        message.totalVisitorNum = reader.int32();
                        break;
                    }
                case 86: {
                        message.nicknameUpdateTime = reader.int32();
                        break;
                    }
                case 87: {
                        message.threadNum = reader.int32();
                        break;
                    }
                case 88: {
                        message.agreeNum = reader.int32();
                        break;
                    }
                case 89: {
                        message.leftCallNum = reader.int32();
                        break;
                    }
                case 90: {
                        message.isInvited = reader.int32();
                        break;
                    }
                case 91: {
                        message.isFans = reader.int32();
                        break;
                    }
                case 92: {
                        message.privThread = reader.int32();
                        break;
                    }
                case 93: {
                        message.isVideobiggie = reader.int32();
                        break;
                    }
                case 94: {
                        message.isShowRedpacket = reader.int32();
                        break;
                    }
                case 96: {
                        message.birthdayInfo = $root.tieba.BirthdayInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 97: {
                        message.canModifyAvatar = reader.int32();
                        break;
                    }
                case 98: {
                        message.modifyAvatarDesc = reader.string();
                        break;
                    }
                case 99: {
                        message.influence = reader.int32();
                        break;
                    }
                case 100: {
                        message.levelInfluence = reader.string();
                        break;
                    }
                case 101: {
                        message.newGodData = $root.tieba.NewGodInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 103: {
                        message.bawuThrones = $root.tieba.BawuThrones.decode(reader, reader.uint32());
                        break;
                    }
                case 105: {
                        message.bazhuGrade = $root.tieba.BazhuSign.decode(reader, reader.uint32());
                        break;
                    }
                case 106: {
                        message.isDefaultAvatar = reader.int32();
                        break;
                    }
                case 109: {
                        message.favoriteNum = reader.int32();
                        break;
                    }
                case 118: {
                        message.totalAgreeNum = reader.uint32();
                        break;
                    }
                case 120: {
                        message.tiebaUid = reader.string();
                        break;
                    }
                case 125: {
                        message.levelName = reader.string();
                        break;
                    }
                case 127: {
                        message.ipAddress = reader.string();
                        break;
                    }
                case 128: {
                        message.isNicknameEditing = reader.int32();
                        break;
                    }
                case 129: {
                        message.editingNickname = reader.string();
                        break;
                    }
                case 138: {
                        message.displayIntro = reader.string();
                        break;
                    }
                case 139: {
                        if (!(message.newIconUrl && message.newIconUrl.length))
                            message.newIconUrl = [];
                        message.newIconUrl.push(reader.string());
                        break;
                    }
                case 140: {
                        message.dynamicUrl = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a User message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a User message.
         * @function verify
         * @memberof tieba.User
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        User.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.isLogin != null && message.hasOwnProperty("isLogin"))
                if (!$util.isInteger(message.isLogin))
                    return "isLogin: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.nameShow != null && message.hasOwnProperty("nameShow"))
                if (!$util.isString(message.nameShow))
                    return "nameShow: string expected";
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                if (!$util.isString(message.portrait))
                    return "portrait: string expected";
            if (message.noUn != null && message.hasOwnProperty("noUn"))
                if (!$util.isInteger(message.noUn))
                    return "noUn: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.userhide != null && message.hasOwnProperty("userhide"))
                if (!$util.isInteger(message.userhide))
                    return "userhide: integer expected";
            if (message.isManager != null && message.hasOwnProperty("isManager"))
                if (!$util.isInteger(message.isManager))
                    return "isManager: integer expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isString(message.rank))
                    return "rank: string expected";
            if (message.bimgUrl != null && message.hasOwnProperty("bimgUrl"))
                if (!$util.isString(message.bimgUrl))
                    return "bimgUrl: string expected";
            if (message.meizhiLevel != null && message.hasOwnProperty("meizhiLevel"))
                if (!$util.isInteger(message.meizhiLevel))
                    return "meizhiLevel: integer expected";
            if (message.isVerify != null && message.hasOwnProperty("isVerify"))
                if (!$util.isInteger(message.isVerify))
                    return "isVerify: integer expected";
            if (message.isInterestman != null && message.hasOwnProperty("isInterestman"))
                if (!$util.isInteger(message.isInterestman))
                    return "isInterestman: integer expected";
            if (message.iconinfo != null && message.hasOwnProperty("iconinfo")) {
                if (!Array.isArray(message.iconinfo))
                    return "iconinfo: array expected";
                for (let i = 0; i < message.iconinfo.length; ++i) {
                    let error = $root.tieba.Icon.verify(message.iconinfo[i]);
                    if (error)
                        return "iconinfo." + error;
                }
            }
            if (message.userType != null && message.hasOwnProperty("userType"))
                if (!$util.isInteger(message.userType))
                    return "userType: integer expected";
            if (message.isCoreuser != null && message.hasOwnProperty("isCoreuser"))
                if (!$util.isInteger(message.isCoreuser))
                    return "isCoreuser: integer expected";
            if (message.isHuinibuke != null && message.hasOwnProperty("isHuinibuke"))
                if (!$util.isInteger(message.isHuinibuke))
                    return "isHuinibuke: integer expected";
            if (message.iosBimgFormat != null && message.hasOwnProperty("iosBimgFormat"))
                if (!$util.isString(message.iosBimgFormat))
                    return "iosBimgFormat: string expected";
            if (message.levelId != null && message.hasOwnProperty("levelId"))
                if (!$util.isInteger(message.levelId))
                    return "levelId: integer expected";
            if (message.isLike != null && message.hasOwnProperty("isLike"))
                if (!$util.isInteger(message.isLike))
                    return "isLike: integer expected";
            if (message.isBawu != null && message.hasOwnProperty("isBawu"))
                if (!$util.isInteger(message.isBawu))
                    return "isBawu: integer expected";
            if (message.bawuType != null && message.hasOwnProperty("bawuType"))
                if (!$util.isString(message.bawuType))
                    return "bawuType: string expected";
            if (message.portraith != null && message.hasOwnProperty("portraith"))
                if (!$util.isString(message.portraith))
                    return "portraith: string expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            if (message.BDUSS != null && message.hasOwnProperty("BDUSS"))
                if (!$util.isString(message.BDUSS))
                    return "BDUSS: string expected";
            if (message.fansNum != null && message.hasOwnProperty("fansNum"))
                if (!$util.isInteger(message.fansNum))
                    return "fansNum: integer expected";
            if (message.concernNum != null && message.hasOwnProperty("concernNum"))
                if (!$util.isInteger(message.concernNum))
                    return "concernNum: integer expected";
            if (message.sex != null && message.hasOwnProperty("sex"))
                if (!$util.isInteger(message.sex))
                    return "sex: integer expected";
            if (message.myLikeNum != null && message.hasOwnProperty("myLikeNum"))
                if (!$util.isInteger(message.myLikeNum))
                    return "myLikeNum: integer expected";
            if (message.intro != null && message.hasOwnProperty("intro"))
                if (!$util.isString(message.intro))
                    return "intro: string expected";
            if (message.hasConcerned != null && message.hasOwnProperty("hasConcerned"))
                if (!$util.isInteger(message.hasConcerned))
                    return "hasConcerned: integer expected";
            if (message.passwd != null && message.hasOwnProperty("passwd"))
                if (!$util.isString(message.passwd))
                    return "passwd: string expected";
            if (message.postNum != null && message.hasOwnProperty("postNum"))
                if (!$util.isInteger(message.postNum))
                    return "postNum: integer expected";
            if (message.tbAge != null && message.hasOwnProperty("tbAge"))
                if (!$util.isString(message.tbAge))
                    return "tbAge: string expected";
            if (message.isMem != null && message.hasOwnProperty("isMem"))
                if (!$util.isInteger(message.isMem))
                    return "isMem: integer expected";
            if (message.bimgEndTime != null && message.hasOwnProperty("bimgEndTime"))
                if (!$util.isInteger(message.bimgEndTime))
                    return "bimgEndTime: integer expected";
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            if (message.isMask != null && message.hasOwnProperty("isMask"))
                if (!$util.isInteger(message.isMask))
                    return "isMask: integer expected";
            if (message.userPics != null && message.hasOwnProperty("userPics")) {
                if (!Array.isArray(message.userPics))
                    return "userPics: array expected";
                for (let i = 0; i < message.userPics.length; ++i) {
                    let error = $root.tieba.UserPics.verify(message.userPics[i]);
                    if (error)
                        return "userPics." + error;
                }
            }
            if (message.privSets != null && message.hasOwnProperty("privSets")) {
                let error = $root.tieba.PrivSets.verify(message.privSets);
                if (error)
                    return "privSets." + error;
            }
            if (message.isFriend != null && message.hasOwnProperty("isFriend"))
                if (!$util.isInteger(message.isFriend))
                    return "isFriend: integer expected";
            if (message.likeForum != null && message.hasOwnProperty("likeForum")) {
                if (!Array.isArray(message.likeForum))
                    return "likeForum: array expected";
                for (let i = 0; i < message.likeForum.length; ++i) {
                    let error = $root.tieba.LikeForumInfo.verify(message.likeForum[i]);
                    if (error)
                        return "likeForum." + error;
                }
            }
            if (message.giftNum != null && message.hasOwnProperty("giftNum"))
                if (!$util.isInteger(message.giftNum))
                    return "giftNum: integer expected";
            if (message.isSelectTail != null && message.hasOwnProperty("isSelectTail"))
                if (!$util.isInteger(message.isSelectTail))
                    return "isSelectTail: integer expected";
            if (message.isGuanfang != null && message.hasOwnProperty("isGuanfang"))
                if (!$util.isInteger(message.isGuanfang))
                    return "isGuanfang: integer expected";
            if (message.bookmarkCount != null && message.hasOwnProperty("bookmarkCount"))
                if (!$util.isInteger(message.bookmarkCount))
                    return "bookmarkCount: integer expected";
            if (message.bookmarkNewCount != null && message.hasOwnProperty("bookmarkNewCount"))
                if (!$util.isInteger(message.bookmarkNewCount))
                    return "bookmarkNewCount: integer expected";
            if (message.muteUser != null && message.hasOwnProperty("muteUser")) {
                if (!Array.isArray(message.muteUser))
                    return "muteUser: array expected";
                for (let i = 0; i < message.muteUser.length; ++i) {
                    let error = $root.tieba.SimpleUser.verify(message.muteUser[i]);
                    if (error)
                        return "muteUser." + error;
                }
            }
            if (message.friendNum != null && message.hasOwnProperty("friendNum"))
                if (!$util.isInteger(message.friendNum) && !(message.friendNum && $util.isInteger(message.friendNum.low) && $util.isInteger(message.friendNum.high)))
                    return "friendNum: integer|Long expected";
            if (message.fansNickname != null && message.hasOwnProperty("fansNickname"))
                if (!$util.isString(message.fansNickname))
                    return "fansNickname: string expected";
            if (message.bgPic != null && message.hasOwnProperty("bgPic"))
                if (!$util.isString(message.bgPic))
                    return "bgPic: string expected";
            if (message.godData != null && message.hasOwnProperty("godData")) {
                let error = $root.tieba.GodInfo.verify(message.godData);
                if (error)
                    return "godData." + error;
            }
            if (message.heavyUser != null && message.hasOwnProperty("heavyUser"))
                if (!$util.isInteger(message.heavyUser))
                    return "heavyUser: integer expected";
            if (message.visitorNum != null && message.hasOwnProperty("visitorNum"))
                if (!$util.isInteger(message.visitorNum))
                    return "visitorNum: integer expected";
            if (message.totalVisitorNum != null && message.hasOwnProperty("totalVisitorNum"))
                if (!$util.isInteger(message.totalVisitorNum))
                    return "totalVisitorNum: integer expected";
            if (message.nicknameUpdateTime != null && message.hasOwnProperty("nicknameUpdateTime"))
                if (!$util.isInteger(message.nicknameUpdateTime))
                    return "nicknameUpdateTime: integer expected";
            if (message.threadNum != null && message.hasOwnProperty("threadNum"))
                if (!$util.isInteger(message.threadNum))
                    return "threadNum: integer expected";
            if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
                if (!$util.isInteger(message.agreeNum))
                    return "agreeNum: integer expected";
            if (message.leftCallNum != null && message.hasOwnProperty("leftCallNum"))
                if (!$util.isInteger(message.leftCallNum))
                    return "leftCallNum: integer expected";
            if (message.isInvited != null && message.hasOwnProperty("isInvited"))
                if (!$util.isInteger(message.isInvited))
                    return "isInvited: integer expected";
            if (message.isFans != null && message.hasOwnProperty("isFans"))
                if (!$util.isInteger(message.isFans))
                    return "isFans: integer expected";
            if (message.privThread != null && message.hasOwnProperty("privThread"))
                if (!$util.isInteger(message.privThread))
                    return "privThread: integer expected";
            if (message.isVideobiggie != null && message.hasOwnProperty("isVideobiggie"))
                if (!$util.isInteger(message.isVideobiggie))
                    return "isVideobiggie: integer expected";
            if (message.isShowRedpacket != null && message.hasOwnProperty("isShowRedpacket"))
                if (!$util.isInteger(message.isShowRedpacket))
                    return "isShowRedpacket: integer expected";
            if (message.birthdayInfo != null && message.hasOwnProperty("birthdayInfo")) {
                let error = $root.tieba.BirthdayInfo.verify(message.birthdayInfo);
                if (error)
                    return "birthdayInfo." + error;
            }
            if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
                if (!$util.isInteger(message.canModifyAvatar))
                    return "canModifyAvatar: integer expected";
            if (message.modifyAvatarDesc != null && message.hasOwnProperty("modifyAvatarDesc"))
                if (!$util.isString(message.modifyAvatarDesc))
                    return "modifyAvatarDesc: string expected";
            if (message.influence != null && message.hasOwnProperty("influence"))
                if (!$util.isInteger(message.influence))
                    return "influence: integer expected";
            if (message.levelInfluence != null && message.hasOwnProperty("levelInfluence"))
                if (!$util.isString(message.levelInfluence))
                    return "levelInfluence: string expected";
            if (message.newGodData != null && message.hasOwnProperty("newGodData")) {
                properties._newGodData = 1;
                {
                    let error = $root.tieba.NewGodInfo.verify(message.newGodData);
                    if (error)
                        return "newGodData." + error;
                }
            }
            if (message.bawuThrones != null && message.hasOwnProperty("bawuThrones")) {
                let error = $root.tieba.BawuThrones.verify(message.bawuThrones);
                if (error)
                    return "bawuThrones." + error;
            }
            if (message.bazhuGrade != null && message.hasOwnProperty("bazhuGrade")) {
                let error = $root.tieba.BazhuSign.verify(message.bazhuGrade);
                if (error)
                    return "bazhuGrade." + error;
            }
            if (message.isDefaultAvatar != null && message.hasOwnProperty("isDefaultAvatar"))
                if (!$util.isInteger(message.isDefaultAvatar))
                    return "isDefaultAvatar: integer expected";
            if (message.favoriteNum != null && message.hasOwnProperty("favoriteNum"))
                if (!$util.isInteger(message.favoriteNum))
                    return "favoriteNum: integer expected";
            if (message.totalAgreeNum != null && message.hasOwnProperty("totalAgreeNum"))
                if (!$util.isInteger(message.totalAgreeNum))
                    return "totalAgreeNum: integer expected";
            if (message.tiebaUid != null && message.hasOwnProperty("tiebaUid"))
                if (!$util.isString(message.tiebaUid))
                    return "tiebaUid: string expected";
            if (message.levelName != null && message.hasOwnProperty("levelName"))
                if (!$util.isString(message.levelName))
                    return "levelName: string expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            if (message.isNicknameEditing != null && message.hasOwnProperty("isNicknameEditing"))
                if (!$util.isInteger(message.isNicknameEditing))
                    return "isNicknameEditing: integer expected";
            if (message.editingNickname != null && message.hasOwnProperty("editingNickname"))
                if (!$util.isString(message.editingNickname))
                    return "editingNickname: string expected";
            if (message.displayIntro != null && message.hasOwnProperty("displayIntro"))
                if (!$util.isString(message.displayIntro))
                    return "displayIntro: string expected";
            if (message.newIconUrl != null && message.hasOwnProperty("newIconUrl")) {
                if (!Array.isArray(message.newIconUrl))
                    return "newIconUrl: array expected";
                for (let i = 0; i < message.newIconUrl.length; ++i)
                    if (!$util.isString(message.newIconUrl[i]))
                        return "newIconUrl: string[] expected";
            }
            if (message.dynamicUrl != null && message.hasOwnProperty("dynamicUrl"))
                if (!$util.isString(message.dynamicUrl))
                    return "dynamicUrl: string expected";
            return null;
        };

        /**
         * Creates a User message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.User
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.User} User
         */
        User.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.User)
                return object;
            let message = new $root.tieba.User();
            if (object.isLogin != null)
                message.isLogin = object.isLogin | 0;
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.nameShow != null)
                message.nameShow = String(object.nameShow);
            if (object.portrait != null)
                message.portrait = String(object.portrait);
            if (object.noUn != null)
                message.noUn = object.noUn | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.userhide != null)
                message.userhide = object.userhide | 0;
            if (object.isManager != null)
                message.isManager = object.isManager | 0;
            if (object.rank != null)
                message.rank = String(object.rank);
            if (object.bimgUrl != null)
                message.bimgUrl = String(object.bimgUrl);
            if (object.meizhiLevel != null)
                message.meizhiLevel = object.meizhiLevel | 0;
            if (object.isVerify != null)
                message.isVerify = object.isVerify | 0;
            if (object.isInterestman != null)
                message.isInterestman = object.isInterestman | 0;
            if (object.iconinfo) {
                if (!Array.isArray(object.iconinfo))
                    throw TypeError(".tieba.User.iconinfo: array expected");
                message.iconinfo = [];
                for (let i = 0; i < object.iconinfo.length; ++i) {
                    if (typeof object.iconinfo[i] !== "object")
                        throw TypeError(".tieba.User.iconinfo: object expected");
                    message.iconinfo[i] = $root.tieba.Icon.fromObject(object.iconinfo[i]);
                }
            }
            if (object.userType != null)
                message.userType = object.userType | 0;
            if (object.isCoreuser != null)
                message.isCoreuser = object.isCoreuser | 0;
            if (object.isHuinibuke != null)
                message.isHuinibuke = object.isHuinibuke | 0;
            if (object.iosBimgFormat != null)
                message.iosBimgFormat = String(object.iosBimgFormat);
            if (object.levelId != null)
                message.levelId = object.levelId | 0;
            if (object.isLike != null)
                message.isLike = object.isLike | 0;
            if (object.isBawu != null)
                message.isBawu = object.isBawu | 0;
            if (object.bawuType != null)
                message.bawuType = String(object.bawuType);
            if (object.portraith != null)
                message.portraith = String(object.portraith);
            if (object.ip != null)
                message.ip = String(object.ip);
            if (object.BDUSS != null)
                message.BDUSS = String(object.BDUSS);
            if (object.fansNum != null)
                message.fansNum = object.fansNum | 0;
            if (object.concernNum != null)
                message.concernNum = object.concernNum | 0;
            if (object.sex != null)
                message.sex = object.sex | 0;
            if (object.myLikeNum != null)
                message.myLikeNum = object.myLikeNum | 0;
            if (object.intro != null)
                message.intro = String(object.intro);
            if (object.hasConcerned != null)
                message.hasConcerned = object.hasConcerned | 0;
            if (object.passwd != null)
                message.passwd = String(object.passwd);
            if (object.postNum != null)
                message.postNum = object.postNum | 0;
            if (object.tbAge != null)
                message.tbAge = String(object.tbAge);
            if (object.isMem != null)
                message.isMem = object.isMem | 0;
            if (object.bimgEndTime != null)
                message.bimgEndTime = object.bimgEndTime | 0;
            if (object.gender != null)
                message.gender = object.gender | 0;
            if (object.isMask != null)
                message.isMask = object.isMask | 0;
            if (object.userPics) {
                if (!Array.isArray(object.userPics))
                    throw TypeError(".tieba.User.userPics: array expected");
                message.userPics = [];
                for (let i = 0; i < object.userPics.length; ++i) {
                    if (typeof object.userPics[i] !== "object")
                        throw TypeError(".tieba.User.userPics: object expected");
                    message.userPics[i] = $root.tieba.UserPics.fromObject(object.userPics[i]);
                }
            }
            if (object.privSets != null) {
                if (typeof object.privSets !== "object")
                    throw TypeError(".tieba.User.privSets: object expected");
                message.privSets = $root.tieba.PrivSets.fromObject(object.privSets);
            }
            if (object.isFriend != null)
                message.isFriend = object.isFriend | 0;
            if (object.likeForum) {
                if (!Array.isArray(object.likeForum))
                    throw TypeError(".tieba.User.likeForum: array expected");
                message.likeForum = [];
                for (let i = 0; i < object.likeForum.length; ++i) {
                    if (typeof object.likeForum[i] !== "object")
                        throw TypeError(".tieba.User.likeForum: object expected");
                    message.likeForum[i] = $root.tieba.LikeForumInfo.fromObject(object.likeForum[i]);
                }
            }
            if (object.giftNum != null)
                message.giftNum = object.giftNum | 0;
            if (object.isSelectTail != null)
                message.isSelectTail = object.isSelectTail | 0;
            if (object.isGuanfang != null)
                message.isGuanfang = object.isGuanfang | 0;
            if (object.bookmarkCount != null)
                message.bookmarkCount = object.bookmarkCount | 0;
            if (object.bookmarkNewCount != null)
                message.bookmarkNewCount = object.bookmarkNewCount | 0;
            if (object.muteUser) {
                if (!Array.isArray(object.muteUser))
                    throw TypeError(".tieba.User.muteUser: array expected");
                message.muteUser = [];
                for (let i = 0; i < object.muteUser.length; ++i) {
                    if (typeof object.muteUser[i] !== "object")
                        throw TypeError(".tieba.User.muteUser: object expected");
                    message.muteUser[i] = $root.tieba.SimpleUser.fromObject(object.muteUser[i]);
                }
            }
            if (object.friendNum != null)
                if ($util.Long)
                    (message.friendNum = $util.Long.fromValue(object.friendNum)).unsigned = false;
                else if (typeof object.friendNum === "string")
                    message.friendNum = parseInt(object.friendNum, 10);
                else if (typeof object.friendNum === "number")
                    message.friendNum = object.friendNum;
                else if (typeof object.friendNum === "object")
                    message.friendNum = new $util.LongBits(object.friendNum.low >>> 0, object.friendNum.high >>> 0).toNumber();
            if (object.fansNickname != null)
                message.fansNickname = String(object.fansNickname);
            if (object.bgPic != null)
                message.bgPic = String(object.bgPic);
            if (object.godData != null) {
                if (typeof object.godData !== "object")
                    throw TypeError(".tieba.User.godData: object expected");
                message.godData = $root.tieba.GodInfo.fromObject(object.godData);
            }
            if (object.heavyUser != null)
                message.heavyUser = object.heavyUser | 0;
            if (object.visitorNum != null)
                message.visitorNum = object.visitorNum | 0;
            if (object.totalVisitorNum != null)
                message.totalVisitorNum = object.totalVisitorNum | 0;
            if (object.nicknameUpdateTime != null)
                message.nicknameUpdateTime = object.nicknameUpdateTime | 0;
            if (object.threadNum != null)
                message.threadNum = object.threadNum | 0;
            if (object.agreeNum != null)
                message.agreeNum = object.agreeNum | 0;
            if (object.leftCallNum != null)
                message.leftCallNum = object.leftCallNum | 0;
            if (object.isInvited != null)
                message.isInvited = object.isInvited | 0;
            if (object.isFans != null)
                message.isFans = object.isFans | 0;
            if (object.privThread != null)
                message.privThread = object.privThread | 0;
            if (object.isVideobiggie != null)
                message.isVideobiggie = object.isVideobiggie | 0;
            if (object.isShowRedpacket != null)
                message.isShowRedpacket = object.isShowRedpacket | 0;
            if (object.birthdayInfo != null) {
                if (typeof object.birthdayInfo !== "object")
                    throw TypeError(".tieba.User.birthdayInfo: object expected");
                message.birthdayInfo = $root.tieba.BirthdayInfo.fromObject(object.birthdayInfo);
            }
            if (object.canModifyAvatar != null)
                message.canModifyAvatar = object.canModifyAvatar | 0;
            if (object.modifyAvatarDesc != null)
                message.modifyAvatarDesc = String(object.modifyAvatarDesc);
            if (object.influence != null)
                message.influence = object.influence | 0;
            if (object.levelInfluence != null)
                message.levelInfluence = String(object.levelInfluence);
            if (object.newGodData != null) {
                if (typeof object.newGodData !== "object")
                    throw TypeError(".tieba.User.newGodData: object expected");
                message.newGodData = $root.tieba.NewGodInfo.fromObject(object.newGodData);
            }
            if (object.bawuThrones != null) {
                if (typeof object.bawuThrones !== "object")
                    throw TypeError(".tieba.User.bawuThrones: object expected");
                message.bawuThrones = $root.tieba.BawuThrones.fromObject(object.bawuThrones);
            }
            if (object.bazhuGrade != null) {
                if (typeof object.bazhuGrade !== "object")
                    throw TypeError(".tieba.User.bazhuGrade: object expected");
                message.bazhuGrade = $root.tieba.BazhuSign.fromObject(object.bazhuGrade);
            }
            if (object.isDefaultAvatar != null)
                message.isDefaultAvatar = object.isDefaultAvatar | 0;
            if (object.favoriteNum != null)
                message.favoriteNum = object.favoriteNum | 0;
            if (object.totalAgreeNum != null)
                message.totalAgreeNum = object.totalAgreeNum >>> 0;
            if (object.tiebaUid != null)
                message.tiebaUid = String(object.tiebaUid);
            if (object.levelName != null)
                message.levelName = String(object.levelName);
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            if (object.isNicknameEditing != null)
                message.isNicknameEditing = object.isNicknameEditing | 0;
            if (object.editingNickname != null)
                message.editingNickname = String(object.editingNickname);
            if (object.displayIntro != null)
                message.displayIntro = String(object.displayIntro);
            if (object.newIconUrl) {
                if (!Array.isArray(object.newIconUrl))
                    throw TypeError(".tieba.User.newIconUrl: array expected");
                message.newIconUrl = [];
                for (let i = 0; i < object.newIconUrl.length; ++i)
                    message.newIconUrl[i] = String(object.newIconUrl[i]);
            }
            if (object.dynamicUrl != null)
                message.dynamicUrl = String(object.dynamicUrl);
            return message;
        };

        /**
         * Creates a plain object from a User message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.User
         * @static
         * @param {tieba.User} message User
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        User.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.iconinfo = [];
                object.userPics = [];
                object.likeForum = [];
                object.muteUser = [];
                object.newIconUrl = [];
            }
            if (options.defaults) {
                object.isLogin = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
                object.nameShow = "";
                object.portrait = "";
                object.noUn = 0;
                object.type = 0;
                object.userhide = 0;
                object.isManager = 0;
                object.rank = "";
                object.bimgUrl = "";
                object.meizhiLevel = 0;
                object.isVerify = 0;
                object.isInterestman = 0;
                object.userType = 0;
                object.isCoreuser = 0;
                object.isHuinibuke = 0;
                object.iosBimgFormat = "";
                object.levelId = 0;
                object.isLike = 0;
                object.isBawu = 0;
                object.bawuType = "";
                object.portraith = "";
                object.ip = "";
                object.BDUSS = "";
                object.fansNum = 0;
                object.concernNum = 0;
                object.sex = 0;
                object.myLikeNum = 0;
                object.intro = "";
                object.hasConcerned = 0;
                object.passwd = "";
                object.postNum = 0;
                object.tbAge = "";
                object.isMem = 0;
                object.bimgEndTime = 0;
                object.gender = 0;
                object.isMask = 0;
                object.privSets = null;
                object.isFriend = 0;
                object.giftNum = 0;
                object.isSelectTail = 0;
                object.isGuanfang = 0;
                object.bookmarkCount = 0;
                object.bookmarkNewCount = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.friendNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.friendNum = options.longs === String ? "0" : 0;
                object.fansNickname = "";
                object.bgPic = "";
                object.godData = null;
                object.heavyUser = 0;
                object.visitorNum = 0;
                object.totalVisitorNum = 0;
                object.nicknameUpdateTime = 0;
                object.threadNum = 0;
                object.agreeNum = 0;
                object.leftCallNum = 0;
                object.isInvited = 0;
                object.isFans = 0;
                object.privThread = 0;
                object.isVideobiggie = 0;
                object.isShowRedpacket = 0;
                object.birthdayInfo = null;
                object.canModifyAvatar = 0;
                object.modifyAvatarDesc = "";
                object.influence = 0;
                object.levelInfluence = "";
                object.bawuThrones = null;
                object.bazhuGrade = null;
                object.isDefaultAvatar = 0;
                object.favoriteNum = 0;
                object.totalAgreeNum = 0;
                object.tiebaUid = "";
                object.levelName = "";
                object.ipAddress = "";
                object.isNicknameEditing = 0;
                object.editingNickname = "";
                object.displayIntro = "";
                object.dynamicUrl = "";
            }
            if (message.isLogin != null && message.hasOwnProperty("isLogin"))
                object.isLogin = message.isLogin;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.nameShow != null && message.hasOwnProperty("nameShow"))
                object.nameShow = message.nameShow;
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                object.portrait = message.portrait;
            if (message.noUn != null && message.hasOwnProperty("noUn"))
                object.noUn = message.noUn;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.userhide != null && message.hasOwnProperty("userhide"))
                object.userhide = message.userhide;
            if (message.isManager != null && message.hasOwnProperty("isManager"))
                object.isManager = message.isManager;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.bimgUrl != null && message.hasOwnProperty("bimgUrl"))
                object.bimgUrl = message.bimgUrl;
            if (message.meizhiLevel != null && message.hasOwnProperty("meizhiLevel"))
                object.meizhiLevel = message.meizhiLevel;
            if (message.isVerify != null && message.hasOwnProperty("isVerify"))
                object.isVerify = message.isVerify;
            if (message.isInterestman != null && message.hasOwnProperty("isInterestman"))
                object.isInterestman = message.isInterestman;
            if (message.iconinfo && message.iconinfo.length) {
                object.iconinfo = [];
                for (let j = 0; j < message.iconinfo.length; ++j)
                    object.iconinfo[j] = $root.tieba.Icon.toObject(message.iconinfo[j], options);
            }
            if (message.userType != null && message.hasOwnProperty("userType"))
                object.userType = message.userType;
            if (message.isCoreuser != null && message.hasOwnProperty("isCoreuser"))
                object.isCoreuser = message.isCoreuser;
            if (message.isHuinibuke != null && message.hasOwnProperty("isHuinibuke"))
                object.isHuinibuke = message.isHuinibuke;
            if (message.iosBimgFormat != null && message.hasOwnProperty("iosBimgFormat"))
                object.iosBimgFormat = message.iosBimgFormat;
            if (message.levelId != null && message.hasOwnProperty("levelId"))
                object.levelId = message.levelId;
            if (message.isLike != null && message.hasOwnProperty("isLike"))
                object.isLike = message.isLike;
            if (message.isBawu != null && message.hasOwnProperty("isBawu"))
                object.isBawu = message.isBawu;
            if (message.bawuType != null && message.hasOwnProperty("bawuType"))
                object.bawuType = message.bawuType;
            if (message.portraith != null && message.hasOwnProperty("portraith"))
                object.portraith = message.portraith;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.BDUSS != null && message.hasOwnProperty("BDUSS"))
                object.BDUSS = message.BDUSS;
            if (message.fansNum != null && message.hasOwnProperty("fansNum"))
                object.fansNum = message.fansNum;
            if (message.concernNum != null && message.hasOwnProperty("concernNum"))
                object.concernNum = message.concernNum;
            if (message.sex != null && message.hasOwnProperty("sex"))
                object.sex = message.sex;
            if (message.myLikeNum != null && message.hasOwnProperty("myLikeNum"))
                object.myLikeNum = message.myLikeNum;
            if (message.intro != null && message.hasOwnProperty("intro"))
                object.intro = message.intro;
            if (message.hasConcerned != null && message.hasOwnProperty("hasConcerned"))
                object.hasConcerned = message.hasConcerned;
            if (message.passwd != null && message.hasOwnProperty("passwd"))
                object.passwd = message.passwd;
            if (message.postNum != null && message.hasOwnProperty("postNum"))
                object.postNum = message.postNum;
            if (message.tbAge != null && message.hasOwnProperty("tbAge"))
                object.tbAge = message.tbAge;
            if (message.isMem != null && message.hasOwnProperty("isMem"))
                object.isMem = message.isMem;
            if (message.bimgEndTime != null && message.hasOwnProperty("bimgEndTime"))
                object.bimgEndTime = message.bimgEndTime;
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.isMask != null && message.hasOwnProperty("isMask"))
                object.isMask = message.isMask;
            if (message.userPics && message.userPics.length) {
                object.userPics = [];
                for (let j = 0; j < message.userPics.length; ++j)
                    object.userPics[j] = $root.tieba.UserPics.toObject(message.userPics[j], options);
            }
            if (message.privSets != null && message.hasOwnProperty("privSets"))
                object.privSets = $root.tieba.PrivSets.toObject(message.privSets, options);
            if (message.isFriend != null && message.hasOwnProperty("isFriend"))
                object.isFriend = message.isFriend;
            if (message.likeForum && message.likeForum.length) {
                object.likeForum = [];
                for (let j = 0; j < message.likeForum.length; ++j)
                    object.likeForum[j] = $root.tieba.LikeForumInfo.toObject(message.likeForum[j], options);
            }
            if (message.giftNum != null && message.hasOwnProperty("giftNum"))
                object.giftNum = message.giftNum;
            if (message.isSelectTail != null && message.hasOwnProperty("isSelectTail"))
                object.isSelectTail = message.isSelectTail;
            if (message.isGuanfang != null && message.hasOwnProperty("isGuanfang"))
                object.isGuanfang = message.isGuanfang;
            if (message.bookmarkCount != null && message.hasOwnProperty("bookmarkCount"))
                object.bookmarkCount = message.bookmarkCount;
            if (message.bookmarkNewCount != null && message.hasOwnProperty("bookmarkNewCount"))
                object.bookmarkNewCount = message.bookmarkNewCount;
            if (message.muteUser && message.muteUser.length) {
                object.muteUser = [];
                for (let j = 0; j < message.muteUser.length; ++j)
                    object.muteUser[j] = $root.tieba.SimpleUser.toObject(message.muteUser[j], options);
            }
            if (message.friendNum != null && message.hasOwnProperty("friendNum"))
                if (typeof message.friendNum === "number")
                    object.friendNum = options.longs === String ? String(message.friendNum) : message.friendNum;
                else
                    object.friendNum = options.longs === String ? $util.Long.prototype.toString.call(message.friendNum) : options.longs === Number ? new $util.LongBits(message.friendNum.low >>> 0, message.friendNum.high >>> 0).toNumber() : message.friendNum;
            if (message.fansNickname != null && message.hasOwnProperty("fansNickname"))
                object.fansNickname = message.fansNickname;
            if (message.bgPic != null && message.hasOwnProperty("bgPic"))
                object.bgPic = message.bgPic;
            if (message.godData != null && message.hasOwnProperty("godData"))
                object.godData = $root.tieba.GodInfo.toObject(message.godData, options);
            if (message.heavyUser != null && message.hasOwnProperty("heavyUser"))
                object.heavyUser = message.heavyUser;
            if (message.visitorNum != null && message.hasOwnProperty("visitorNum"))
                object.visitorNum = message.visitorNum;
            if (message.totalVisitorNum != null && message.hasOwnProperty("totalVisitorNum"))
                object.totalVisitorNum = message.totalVisitorNum;
            if (message.nicknameUpdateTime != null && message.hasOwnProperty("nicknameUpdateTime"))
                object.nicknameUpdateTime = message.nicknameUpdateTime;
            if (message.threadNum != null && message.hasOwnProperty("threadNum"))
                object.threadNum = message.threadNum;
            if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
                object.agreeNum = message.agreeNum;
            if (message.leftCallNum != null && message.hasOwnProperty("leftCallNum"))
                object.leftCallNum = message.leftCallNum;
            if (message.isInvited != null && message.hasOwnProperty("isInvited"))
                object.isInvited = message.isInvited;
            if (message.isFans != null && message.hasOwnProperty("isFans"))
                object.isFans = message.isFans;
            if (message.privThread != null && message.hasOwnProperty("privThread"))
                object.privThread = message.privThread;
            if (message.isVideobiggie != null && message.hasOwnProperty("isVideobiggie"))
                object.isVideobiggie = message.isVideobiggie;
            if (message.isShowRedpacket != null && message.hasOwnProperty("isShowRedpacket"))
                object.isShowRedpacket = message.isShowRedpacket;
            if (message.birthdayInfo != null && message.hasOwnProperty("birthdayInfo"))
                object.birthdayInfo = $root.tieba.BirthdayInfo.toObject(message.birthdayInfo, options);
            if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
                object.canModifyAvatar = message.canModifyAvatar;
            if (message.modifyAvatarDesc != null && message.hasOwnProperty("modifyAvatarDesc"))
                object.modifyAvatarDesc = message.modifyAvatarDesc;
            if (message.influence != null && message.hasOwnProperty("influence"))
                object.influence = message.influence;
            if (message.levelInfluence != null && message.hasOwnProperty("levelInfluence"))
                object.levelInfluence = message.levelInfluence;
            if (message.newGodData != null && message.hasOwnProperty("newGodData")) {
                object.newGodData = $root.tieba.NewGodInfo.toObject(message.newGodData, options);
                if (options.oneofs)
                    object._newGodData = "newGodData";
            }
            if (message.bawuThrones != null && message.hasOwnProperty("bawuThrones"))
                object.bawuThrones = $root.tieba.BawuThrones.toObject(message.bawuThrones, options);
            if (message.bazhuGrade != null && message.hasOwnProperty("bazhuGrade"))
                object.bazhuGrade = $root.tieba.BazhuSign.toObject(message.bazhuGrade, options);
            if (message.isDefaultAvatar != null && message.hasOwnProperty("isDefaultAvatar"))
                object.isDefaultAvatar = message.isDefaultAvatar;
            if (message.favoriteNum != null && message.hasOwnProperty("favoriteNum"))
                object.favoriteNum = message.favoriteNum;
            if (message.totalAgreeNum != null && message.hasOwnProperty("totalAgreeNum"))
                object.totalAgreeNum = message.totalAgreeNum;
            if (message.tiebaUid != null && message.hasOwnProperty("tiebaUid"))
                object.tiebaUid = message.tiebaUid;
            if (message.levelName != null && message.hasOwnProperty("levelName"))
                object.levelName = message.levelName;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            if (message.isNicknameEditing != null && message.hasOwnProperty("isNicknameEditing"))
                object.isNicknameEditing = message.isNicknameEditing;
            if (message.editingNickname != null && message.hasOwnProperty("editingNickname"))
                object.editingNickname = message.editingNickname;
            if (message.displayIntro != null && message.hasOwnProperty("displayIntro"))
                object.displayIntro = message.displayIntro;
            if (message.newIconUrl && message.newIconUrl.length) {
                object.newIconUrl = [];
                for (let j = 0; j < message.newIconUrl.length; ++j)
                    object.newIconUrl[j] = message.newIconUrl[j];
            }
            if (message.dynamicUrl != null && message.hasOwnProperty("dynamicUrl"))
                object.dynamicUrl = message.dynamicUrl;
            return object;
        };

        /**
         * Converts this User to JSON.
         * @function toJSON
         * @memberof tieba.User
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        User.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for User
         * @function getTypeUrl
         * @memberof tieba.User
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.User";
        };

        return User;
    })();

    tieba.BawuThrones = (function() {

        /**
         * Properties of a BawuThrones.
         * @memberof tieba
         * @interface IBawuThrones
         * @property {number|null} [totalRecommendNum] BawuThrones totalRecommendNum
         * @property {number|null} [usedRecommendNum] BawuThrones usedRecommendNum
         * @property {string|null} [bazhuLevel] BawuThrones bazhuLevel
         * @property {number|null} [usedBcastCnt] BawuThrones usedBcastCnt
         * @property {number|null} [totalBcastCnt] BawuThrones totalBcastCnt
         * @property {number|null} [newestBcastPv] BawuThrones newestBcastPv
         * @property {number|null} [hasSendBcast] BawuThrones hasSendBcast
         * @property {number|null} [newestBcastPushuserCnt] BawuThrones newestBcastPushuserCnt
         */

        /**
         * Constructs a new BawuThrones.
         * @memberof tieba
         * @classdesc Represents a BawuThrones.
         * @implements IBawuThrones
         * @constructor
         * @param {tieba.IBawuThrones=} [properties] Properties to set
         */
        function BawuThrones(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BawuThrones totalRecommendNum.
         * @member {number} totalRecommendNum
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.totalRecommendNum = 0;

        /**
         * BawuThrones usedRecommendNum.
         * @member {number} usedRecommendNum
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.usedRecommendNum = 0;

        /**
         * BawuThrones bazhuLevel.
         * @member {string} bazhuLevel
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.bazhuLevel = "";

        /**
         * BawuThrones usedBcastCnt.
         * @member {number} usedBcastCnt
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.usedBcastCnt = 0;

        /**
         * BawuThrones totalBcastCnt.
         * @member {number} totalBcastCnt
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.totalBcastCnt = 0;

        /**
         * BawuThrones newestBcastPv.
         * @member {number} newestBcastPv
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.newestBcastPv = 0;

        /**
         * BawuThrones hasSendBcast.
         * @member {number} hasSendBcast
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.hasSendBcast = 0;

        /**
         * BawuThrones newestBcastPushuserCnt.
         * @member {number} newestBcastPushuserCnt
         * @memberof tieba.BawuThrones
         * @instance
         */
        BawuThrones.prototype.newestBcastPushuserCnt = 0;

        /**
         * Creates a new BawuThrones instance using the specified properties.
         * @function create
         * @memberof tieba.BawuThrones
         * @static
         * @param {tieba.IBawuThrones=} [properties] Properties to set
         * @returns {tieba.BawuThrones} BawuThrones instance
         */
        BawuThrones.create = function create(properties) {
            return new BawuThrones(properties);
        };

        /**
         * Encodes the specified BawuThrones message. Does not implicitly {@link tieba.BawuThrones.verify|verify} messages.
         * @function encode
         * @memberof tieba.BawuThrones
         * @static
         * @param {tieba.IBawuThrones} message BawuThrones message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BawuThrones.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalRecommendNum != null && Object.hasOwnProperty.call(message, "totalRecommendNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.totalRecommendNum);
            if (message.usedRecommendNum != null && Object.hasOwnProperty.call(message, "usedRecommendNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.usedRecommendNum);
            if (message.bazhuLevel != null && Object.hasOwnProperty.call(message, "bazhuLevel"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.bazhuLevel);
            if (message.usedBcastCnt != null && Object.hasOwnProperty.call(message, "usedBcastCnt"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.usedBcastCnt);
            if (message.totalBcastCnt != null && Object.hasOwnProperty.call(message, "totalBcastCnt"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.totalBcastCnt);
            if (message.newestBcastPv != null && Object.hasOwnProperty.call(message, "newestBcastPv"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.newestBcastPv);
            if (message.hasSendBcast != null && Object.hasOwnProperty.call(message, "hasSendBcast"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.hasSendBcast);
            if (message.newestBcastPushuserCnt != null && Object.hasOwnProperty.call(message, "newestBcastPushuserCnt"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.newestBcastPushuserCnt);
            return writer;
        };

        /**
         * Encodes the specified BawuThrones message, length delimited. Does not implicitly {@link tieba.BawuThrones.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.BawuThrones
         * @static
         * @param {tieba.IBawuThrones} message BawuThrones message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BawuThrones.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BawuThrones message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.BawuThrones
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.BawuThrones} BawuThrones
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BawuThrones.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.BawuThrones();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.totalRecommendNum = reader.int32();
                        break;
                    }
                case 2: {
                        message.usedRecommendNum = reader.int32();
                        break;
                    }
                case 3: {
                        message.bazhuLevel = reader.string();
                        break;
                    }
                case 4: {
                        message.usedBcastCnt = reader.int32();
                        break;
                    }
                case 5: {
                        message.totalBcastCnt = reader.int32();
                        break;
                    }
                case 6: {
                        message.newestBcastPv = reader.int32();
                        break;
                    }
                case 7: {
                        message.hasSendBcast = reader.int32();
                        break;
                    }
                case 8: {
                        message.newestBcastPushuserCnt = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BawuThrones message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.BawuThrones
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.BawuThrones} BawuThrones
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BawuThrones.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BawuThrones message.
         * @function verify
         * @memberof tieba.BawuThrones
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BawuThrones.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalRecommendNum != null && message.hasOwnProperty("totalRecommendNum"))
                if (!$util.isInteger(message.totalRecommendNum))
                    return "totalRecommendNum: integer expected";
            if (message.usedRecommendNum != null && message.hasOwnProperty("usedRecommendNum"))
                if (!$util.isInteger(message.usedRecommendNum))
                    return "usedRecommendNum: integer expected";
            if (message.bazhuLevel != null && message.hasOwnProperty("bazhuLevel"))
                if (!$util.isString(message.bazhuLevel))
                    return "bazhuLevel: string expected";
            if (message.usedBcastCnt != null && message.hasOwnProperty("usedBcastCnt"))
                if (!$util.isInteger(message.usedBcastCnt))
                    return "usedBcastCnt: integer expected";
            if (message.totalBcastCnt != null && message.hasOwnProperty("totalBcastCnt"))
                if (!$util.isInteger(message.totalBcastCnt))
                    return "totalBcastCnt: integer expected";
            if (message.newestBcastPv != null && message.hasOwnProperty("newestBcastPv"))
                if (!$util.isInteger(message.newestBcastPv))
                    return "newestBcastPv: integer expected";
            if (message.hasSendBcast != null && message.hasOwnProperty("hasSendBcast"))
                if (!$util.isInteger(message.hasSendBcast))
                    return "hasSendBcast: integer expected";
            if (message.newestBcastPushuserCnt != null && message.hasOwnProperty("newestBcastPushuserCnt"))
                if (!$util.isInteger(message.newestBcastPushuserCnt))
                    return "newestBcastPushuserCnt: integer expected";
            return null;
        };

        /**
         * Creates a BawuThrones message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.BawuThrones
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.BawuThrones} BawuThrones
         */
        BawuThrones.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.BawuThrones)
                return object;
            let message = new $root.tieba.BawuThrones();
            if (object.totalRecommendNum != null)
                message.totalRecommendNum = object.totalRecommendNum | 0;
            if (object.usedRecommendNum != null)
                message.usedRecommendNum = object.usedRecommendNum | 0;
            if (object.bazhuLevel != null)
                message.bazhuLevel = String(object.bazhuLevel);
            if (object.usedBcastCnt != null)
                message.usedBcastCnt = object.usedBcastCnt | 0;
            if (object.totalBcastCnt != null)
                message.totalBcastCnt = object.totalBcastCnt | 0;
            if (object.newestBcastPv != null)
                message.newestBcastPv = object.newestBcastPv | 0;
            if (object.hasSendBcast != null)
                message.hasSendBcast = object.hasSendBcast | 0;
            if (object.newestBcastPushuserCnt != null)
                message.newestBcastPushuserCnt = object.newestBcastPushuserCnt | 0;
            return message;
        };

        /**
         * Creates a plain object from a BawuThrones message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.BawuThrones
         * @static
         * @param {tieba.BawuThrones} message BawuThrones
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BawuThrones.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.totalRecommendNum = 0;
                object.usedRecommendNum = 0;
                object.bazhuLevel = "";
                object.usedBcastCnt = 0;
                object.totalBcastCnt = 0;
                object.newestBcastPv = 0;
                object.hasSendBcast = 0;
                object.newestBcastPushuserCnt = 0;
            }
            if (message.totalRecommendNum != null && message.hasOwnProperty("totalRecommendNum"))
                object.totalRecommendNum = message.totalRecommendNum;
            if (message.usedRecommendNum != null && message.hasOwnProperty("usedRecommendNum"))
                object.usedRecommendNum = message.usedRecommendNum;
            if (message.bazhuLevel != null && message.hasOwnProperty("bazhuLevel"))
                object.bazhuLevel = message.bazhuLevel;
            if (message.usedBcastCnt != null && message.hasOwnProperty("usedBcastCnt"))
                object.usedBcastCnt = message.usedBcastCnt;
            if (message.totalBcastCnt != null && message.hasOwnProperty("totalBcastCnt"))
                object.totalBcastCnt = message.totalBcastCnt;
            if (message.newestBcastPv != null && message.hasOwnProperty("newestBcastPv"))
                object.newestBcastPv = message.newestBcastPv;
            if (message.hasSendBcast != null && message.hasOwnProperty("hasSendBcast"))
                object.hasSendBcast = message.hasSendBcast;
            if (message.newestBcastPushuserCnt != null && message.hasOwnProperty("newestBcastPushuserCnt"))
                object.newestBcastPushuserCnt = message.newestBcastPushuserCnt;
            return object;
        };

        /**
         * Converts this BawuThrones to JSON.
         * @function toJSON
         * @memberof tieba.BawuThrones
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BawuThrones.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BawuThrones
         * @function getTypeUrl
         * @memberof tieba.BawuThrones
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BawuThrones.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.BawuThrones";
        };

        return BawuThrones;
    })();

    tieba.BazhuSign = (function() {

        /**
         * Properties of a BazhuSign.
         * @memberof tieba
         * @interface IBazhuSign
         * @property {string|null} [desc] BazhuSign desc
         * @property {string|null} [level] BazhuSign level
         */

        /**
         * Constructs a new BazhuSign.
         * @memberof tieba
         * @classdesc Represents a BazhuSign.
         * @implements IBazhuSign
         * @constructor
         * @param {tieba.IBazhuSign=} [properties] Properties to set
         */
        function BazhuSign(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BazhuSign desc.
         * @member {string} desc
         * @memberof tieba.BazhuSign
         * @instance
         */
        BazhuSign.prototype.desc = "";

        /**
         * BazhuSign level.
         * @member {string} level
         * @memberof tieba.BazhuSign
         * @instance
         */
        BazhuSign.prototype.level = "";

        /**
         * Creates a new BazhuSign instance using the specified properties.
         * @function create
         * @memberof tieba.BazhuSign
         * @static
         * @param {tieba.IBazhuSign=} [properties] Properties to set
         * @returns {tieba.BazhuSign} BazhuSign instance
         */
        BazhuSign.create = function create(properties) {
            return new BazhuSign(properties);
        };

        /**
         * Encodes the specified BazhuSign message. Does not implicitly {@link tieba.BazhuSign.verify|verify} messages.
         * @function encode
         * @memberof tieba.BazhuSign
         * @static
         * @param {tieba.IBazhuSign} message BazhuSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BazhuSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.desc);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.level);
            return writer;
        };

        /**
         * Encodes the specified BazhuSign message, length delimited. Does not implicitly {@link tieba.BazhuSign.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.BazhuSign
         * @static
         * @param {tieba.IBazhuSign} message BazhuSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BazhuSign.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BazhuSign message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.BazhuSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.BazhuSign} BazhuSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BazhuSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.BazhuSign();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.desc = reader.string();
                        break;
                    }
                case 2: {
                        message.level = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BazhuSign message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.BazhuSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.BazhuSign} BazhuSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BazhuSign.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BazhuSign message.
         * @function verify
         * @memberof tieba.BazhuSign
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BazhuSign.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.desc != null && message.hasOwnProperty("desc"))
                if (!$util.isString(message.desc))
                    return "desc: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isString(message.level))
                    return "level: string expected";
            return null;
        };

        /**
         * Creates a BazhuSign message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.BazhuSign
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.BazhuSign} BazhuSign
         */
        BazhuSign.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.BazhuSign)
                return object;
            let message = new $root.tieba.BazhuSign();
            if (object.desc != null)
                message.desc = String(object.desc);
            if (object.level != null)
                message.level = String(object.level);
            return message;
        };

        /**
         * Creates a plain object from a BazhuSign message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.BazhuSign
         * @static
         * @param {tieba.BazhuSign} message BazhuSign
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BazhuSign.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.desc = "";
                object.level = "";
            }
            if (message.desc != null && message.hasOwnProperty("desc"))
                object.desc = message.desc;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            return object;
        };

        /**
         * Converts this BazhuSign to JSON.
         * @function toJSON
         * @memberof tieba.BazhuSign
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BazhuSign.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BazhuSign
         * @function getTypeUrl
         * @memberof tieba.BazhuSign
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BazhuSign.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.BazhuSign";
        };

        return BazhuSign;
    })();

    tieba.BirthdayInfo = (function() {

        /**
         * Properties of a BirthdayInfo.
         * @memberof tieba
         * @interface IBirthdayInfo
         * @property {number|Long|null} [birthdayTime] BirthdayInfo birthdayTime
         * @property {number|null} [birthdayShowStatus] BirthdayInfo birthdayShowStatus
         * @property {string|null} [constellation] BirthdayInfo constellation
         * @property {number|null} [age] BirthdayInfo age
         */

        /**
         * Constructs a new BirthdayInfo.
         * @memberof tieba
         * @classdesc Represents a BirthdayInfo.
         * @implements IBirthdayInfo
         * @constructor
         * @param {tieba.IBirthdayInfo=} [properties] Properties to set
         */
        function BirthdayInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BirthdayInfo birthdayTime.
         * @member {number|Long} birthdayTime
         * @memberof tieba.BirthdayInfo
         * @instance
         */
        BirthdayInfo.prototype.birthdayTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BirthdayInfo birthdayShowStatus.
         * @member {number} birthdayShowStatus
         * @memberof tieba.BirthdayInfo
         * @instance
         */
        BirthdayInfo.prototype.birthdayShowStatus = 0;

        /**
         * BirthdayInfo constellation.
         * @member {string} constellation
         * @memberof tieba.BirthdayInfo
         * @instance
         */
        BirthdayInfo.prototype.constellation = "";

        /**
         * BirthdayInfo age.
         * @member {number} age
         * @memberof tieba.BirthdayInfo
         * @instance
         */
        BirthdayInfo.prototype.age = 0;

        /**
         * Creates a new BirthdayInfo instance using the specified properties.
         * @function create
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {tieba.IBirthdayInfo=} [properties] Properties to set
         * @returns {tieba.BirthdayInfo} BirthdayInfo instance
         */
        BirthdayInfo.create = function create(properties) {
            return new BirthdayInfo(properties);
        };

        /**
         * Encodes the specified BirthdayInfo message. Does not implicitly {@link tieba.BirthdayInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {tieba.IBirthdayInfo} message BirthdayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BirthdayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.birthdayTime != null && Object.hasOwnProperty.call(message, "birthdayTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.birthdayTime);
            if (message.birthdayShowStatus != null && Object.hasOwnProperty.call(message, "birthdayShowStatus"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.birthdayShowStatus);
            if (message.constellation != null && Object.hasOwnProperty.call(message, "constellation"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.constellation);
            if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.age);
            return writer;
        };

        /**
         * Encodes the specified BirthdayInfo message, length delimited. Does not implicitly {@link tieba.BirthdayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {tieba.IBirthdayInfo} message BirthdayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BirthdayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BirthdayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.BirthdayInfo} BirthdayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BirthdayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.BirthdayInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.birthdayTime = reader.int64();
                        break;
                    }
                case 2: {
                        message.birthdayShowStatus = reader.uint32();
                        break;
                    }
                case 3: {
                        message.constellation = reader.string();
                        break;
                    }
                case 4: {
                        message.age = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BirthdayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.BirthdayInfo} BirthdayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BirthdayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BirthdayInfo message.
         * @function verify
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BirthdayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.birthdayTime != null && message.hasOwnProperty("birthdayTime"))
                if (!$util.isInteger(message.birthdayTime) && !(message.birthdayTime && $util.isInteger(message.birthdayTime.low) && $util.isInteger(message.birthdayTime.high)))
                    return "birthdayTime: integer|Long expected";
            if (message.birthdayShowStatus != null && message.hasOwnProperty("birthdayShowStatus"))
                if (!$util.isInteger(message.birthdayShowStatus))
                    return "birthdayShowStatus: integer expected";
            if (message.constellation != null && message.hasOwnProperty("constellation"))
                if (!$util.isString(message.constellation))
                    return "constellation: string expected";
            if (message.age != null && message.hasOwnProperty("age"))
                if (!$util.isInteger(message.age))
                    return "age: integer expected";
            return null;
        };

        /**
         * Creates a BirthdayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.BirthdayInfo} BirthdayInfo
         */
        BirthdayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.BirthdayInfo)
                return object;
            let message = new $root.tieba.BirthdayInfo();
            if (object.birthdayTime != null)
                if ($util.Long)
                    (message.birthdayTime = $util.Long.fromValue(object.birthdayTime)).unsigned = false;
                else if (typeof object.birthdayTime === "string")
                    message.birthdayTime = parseInt(object.birthdayTime, 10);
                else if (typeof object.birthdayTime === "number")
                    message.birthdayTime = object.birthdayTime;
                else if (typeof object.birthdayTime === "object")
                    message.birthdayTime = new $util.LongBits(object.birthdayTime.low >>> 0, object.birthdayTime.high >>> 0).toNumber();
            if (object.birthdayShowStatus != null)
                message.birthdayShowStatus = object.birthdayShowStatus >>> 0;
            if (object.constellation != null)
                message.constellation = String(object.constellation);
            if (object.age != null)
                message.age = object.age >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BirthdayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {tieba.BirthdayInfo} message BirthdayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BirthdayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.birthdayTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.birthdayTime = options.longs === String ? "0" : 0;
                object.birthdayShowStatus = 0;
                object.constellation = "";
                object.age = 0;
            }
            if (message.birthdayTime != null && message.hasOwnProperty("birthdayTime"))
                if (typeof message.birthdayTime === "number")
                    object.birthdayTime = options.longs === String ? String(message.birthdayTime) : message.birthdayTime;
                else
                    object.birthdayTime = options.longs === String ? $util.Long.prototype.toString.call(message.birthdayTime) : options.longs === Number ? new $util.LongBits(message.birthdayTime.low >>> 0, message.birthdayTime.high >>> 0).toNumber() : message.birthdayTime;
            if (message.birthdayShowStatus != null && message.hasOwnProperty("birthdayShowStatus"))
                object.birthdayShowStatus = message.birthdayShowStatus;
            if (message.constellation != null && message.hasOwnProperty("constellation"))
                object.constellation = message.constellation;
            if (message.age != null && message.hasOwnProperty("age"))
                object.age = message.age;
            return object;
        };

        /**
         * Converts this BirthdayInfo to JSON.
         * @function toJSON
         * @memberof tieba.BirthdayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BirthdayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BirthdayInfo
         * @function getTypeUrl
         * @memberof tieba.BirthdayInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BirthdayInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.BirthdayInfo";
        };

        return BirthdayInfo;
    })();

    tieba.GodInfo = (function() {

        /**
         * Properties of a GodInfo.
         * @memberof tieba
         * @interface IGodInfo
         * @property {number|Long|null} [id] GodInfo id
         * @property {string|null} [intro] GodInfo intro
         * @property {number|null} [type] GodInfo type
         * @property {number|Long|null} [fid] GodInfo fid
         * @property {number|null} [followed] GodInfo followed
         * @property {string|null} [recommendReason] GodInfo recommendReason
         * @property {string|null} [forumName] GodInfo forumName
         * @property {number|null} [canSendMsg] GodInfo canSendMsg
         * @property {string|null} [prefix] GodInfo prefix
         */

        /**
         * Constructs a new GodInfo.
         * @memberof tieba
         * @classdesc Represents a GodInfo.
         * @implements IGodInfo
         * @constructor
         * @param {tieba.IGodInfo=} [properties] Properties to set
         */
        function GodInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GodInfo id.
         * @member {number|Long} id
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GodInfo intro.
         * @member {string} intro
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.intro = "";

        /**
         * GodInfo type.
         * @member {number} type
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.type = 0;

        /**
         * GodInfo fid.
         * @member {number|Long} fid
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.fid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GodInfo followed.
         * @member {number} followed
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.followed = 0;

        /**
         * GodInfo recommendReason.
         * @member {string} recommendReason
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.recommendReason = "";

        /**
         * GodInfo forumName.
         * @member {string} forumName
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.forumName = "";

        /**
         * GodInfo canSendMsg.
         * @member {number} canSendMsg
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.canSendMsg = 0;

        /**
         * GodInfo prefix.
         * @member {string} prefix
         * @memberof tieba.GodInfo
         * @instance
         */
        GodInfo.prototype.prefix = "";

        /**
         * Creates a new GodInfo instance using the specified properties.
         * @function create
         * @memberof tieba.GodInfo
         * @static
         * @param {tieba.IGodInfo=} [properties] Properties to set
         * @returns {tieba.GodInfo} GodInfo instance
         */
        GodInfo.create = function create(properties) {
            return new GodInfo(properties);
        };

        /**
         * Encodes the specified GodInfo message. Does not implicitly {@link tieba.GodInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.GodInfo
         * @static
         * @param {tieba.IGodInfo} message GodInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GodInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.intro != null && Object.hasOwnProperty.call(message, "intro"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.intro);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.fid != null && Object.hasOwnProperty.call(message, "fid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fid);
            if (message.followed != null && Object.hasOwnProperty.call(message, "followed"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.followed);
            if (message.recommendReason != null && Object.hasOwnProperty.call(message, "recommendReason"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.recommendReason);
            if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.forumName);
            if (message.canSendMsg != null && Object.hasOwnProperty.call(message, "canSendMsg"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.canSendMsg);
            if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.prefix);
            return writer;
        };

        /**
         * Encodes the specified GodInfo message, length delimited. Does not implicitly {@link tieba.GodInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.GodInfo
         * @static
         * @param {tieba.IGodInfo} message GodInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GodInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GodInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.GodInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.GodInfo} GodInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GodInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.GodInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int64();
                        break;
                    }
                case 2: {
                        message.intro = reader.string();
                        break;
                    }
                case 3: {
                        message.type = reader.int32();
                        break;
                    }
                case 4: {
                        message.fid = reader.int64();
                        break;
                    }
                case 5: {
                        message.followed = reader.int32();
                        break;
                    }
                case 6: {
                        message.recommendReason = reader.string();
                        break;
                    }
                case 7: {
                        message.forumName = reader.string();
                        break;
                    }
                case 8: {
                        message.canSendMsg = reader.int32();
                        break;
                    }
                case 9: {
                        message.prefix = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GodInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.GodInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.GodInfo} GodInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GodInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GodInfo message.
         * @function verify
         * @memberof tieba.GodInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GodInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.intro != null && message.hasOwnProperty("intro"))
                if (!$util.isString(message.intro))
                    return "intro: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.fid != null && message.hasOwnProperty("fid"))
                if (!$util.isInteger(message.fid) && !(message.fid && $util.isInteger(message.fid.low) && $util.isInteger(message.fid.high)))
                    return "fid: integer|Long expected";
            if (message.followed != null && message.hasOwnProperty("followed"))
                if (!$util.isInteger(message.followed))
                    return "followed: integer expected";
            if (message.recommendReason != null && message.hasOwnProperty("recommendReason"))
                if (!$util.isString(message.recommendReason))
                    return "recommendReason: string expected";
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                if (!$util.isString(message.forumName))
                    return "forumName: string expected";
            if (message.canSendMsg != null && message.hasOwnProperty("canSendMsg"))
                if (!$util.isInteger(message.canSendMsg))
                    return "canSendMsg: integer expected";
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                if (!$util.isString(message.prefix))
                    return "prefix: string expected";
            return null;
        };

        /**
         * Creates a GodInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.GodInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.GodInfo} GodInfo
         */
        GodInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.GodInfo)
                return object;
            let message = new $root.tieba.GodInfo();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.intro != null)
                message.intro = String(object.intro);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.fid != null)
                if ($util.Long)
                    (message.fid = $util.Long.fromValue(object.fid)).unsigned = false;
                else if (typeof object.fid === "string")
                    message.fid = parseInt(object.fid, 10);
                else if (typeof object.fid === "number")
                    message.fid = object.fid;
                else if (typeof object.fid === "object")
                    message.fid = new $util.LongBits(object.fid.low >>> 0, object.fid.high >>> 0).toNumber();
            if (object.followed != null)
                message.followed = object.followed | 0;
            if (object.recommendReason != null)
                message.recommendReason = String(object.recommendReason);
            if (object.forumName != null)
                message.forumName = String(object.forumName);
            if (object.canSendMsg != null)
                message.canSendMsg = object.canSendMsg | 0;
            if (object.prefix != null)
                message.prefix = String(object.prefix);
            return message;
        };

        /**
         * Creates a plain object from a GodInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.GodInfo
         * @static
         * @param {tieba.GodInfo} message GodInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GodInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.intro = "";
                object.type = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fid = options.longs === String ? "0" : 0;
                object.followed = 0;
                object.recommendReason = "";
                object.forumName = "";
                object.canSendMsg = 0;
                object.prefix = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.intro != null && message.hasOwnProperty("intro"))
                object.intro = message.intro;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.fid != null && message.hasOwnProperty("fid"))
                if (typeof message.fid === "number")
                    object.fid = options.longs === String ? String(message.fid) : message.fid;
                else
                    object.fid = options.longs === String ? $util.Long.prototype.toString.call(message.fid) : options.longs === Number ? new $util.LongBits(message.fid.low >>> 0, message.fid.high >>> 0).toNumber() : message.fid;
            if (message.followed != null && message.hasOwnProperty("followed"))
                object.followed = message.followed;
            if (message.recommendReason != null && message.hasOwnProperty("recommendReason"))
                object.recommendReason = message.recommendReason;
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                object.forumName = message.forumName;
            if (message.canSendMsg != null && message.hasOwnProperty("canSendMsg"))
                object.canSendMsg = message.canSendMsg;
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                object.prefix = message.prefix;
            return object;
        };

        /**
         * Converts this GodInfo to JSON.
         * @function toJSON
         * @memberof tieba.GodInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GodInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GodInfo
         * @function getTypeUrl
         * @memberof tieba.GodInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GodInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.GodInfo";
        };

        return GodInfo;
    })();

    tieba.Icon = (function() {

        /**
         * Properties of an Icon.
         * @memberof tieba
         * @interface IIcon
         * @property {string|null} [name] Icon name
         * @property {number|null} [weight] Icon weight
         * @property {string|null} [url] Icon url
         * @property {string|null} [icon] Icon icon
         * @property {number|null} [value] Icon value
         * @property {tieba.ITerminal|null} [terminal] Icon terminal
         * @property {tieba.IPosition|null} [position] Icon position
         * @property {Array.<string>|null} [spriteInfo] Icon spriteInfo
         */

        /**
         * Constructs a new Icon.
         * @memberof tieba
         * @classdesc Represents an Icon.
         * @implements IIcon
         * @constructor
         * @param {tieba.IIcon=} [properties] Properties to set
         */
        function Icon(properties) {
            this.spriteInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Icon name.
         * @member {string} name
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.name = "";

        /**
         * Icon weight.
         * @member {number} weight
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.weight = 0;

        /**
         * Icon url.
         * @member {string} url
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.url = "";

        /**
         * Icon icon.
         * @member {string} icon
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.icon = "";

        /**
         * Icon value.
         * @member {number} value
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.value = 0;

        /**
         * Icon terminal.
         * @member {tieba.ITerminal|null|undefined} terminal
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.terminal = null;

        /**
         * Icon position.
         * @member {tieba.IPosition|null|undefined} position
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.position = null;

        /**
         * Icon spriteInfo.
         * @member {Array.<string>} spriteInfo
         * @memberof tieba.Icon
         * @instance
         */
        Icon.prototype.spriteInfo = $util.emptyArray;

        /**
         * Creates a new Icon instance using the specified properties.
         * @function create
         * @memberof tieba.Icon
         * @static
         * @param {tieba.IIcon=} [properties] Properties to set
         * @returns {tieba.Icon} Icon instance
         */
        Icon.create = function create(properties) {
            return new Icon(properties);
        };

        /**
         * Encodes the specified Icon message. Does not implicitly {@link tieba.Icon.verify|verify} messages.
         * @function encode
         * @memberof tieba.Icon
         * @static
         * @param {tieba.IIcon} message Icon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Icon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.weight);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
            if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.icon);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.value);
            if (message.terminal != null && Object.hasOwnProperty.call(message, "terminal"))
                $root.tieba.Terminal.encode(message.terminal, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.tieba.Position.encode(message.position, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spriteInfo != null && message.spriteInfo.length)
                for (let i = 0; i < message.spriteInfo.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.spriteInfo[i]);
            return writer;
        };

        /**
         * Encodes the specified Icon message, length delimited. Does not implicitly {@link tieba.Icon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Icon
         * @static
         * @param {tieba.IIcon} message Icon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Icon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Icon message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Icon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Icon} Icon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Icon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Icon();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.weight = reader.int32();
                        break;
                    }
                case 3: {
                        message.url = reader.string();
                        break;
                    }
                case 4: {
                        message.icon = reader.string();
                        break;
                    }
                case 5: {
                        message.value = reader.int32();
                        break;
                    }
                case 6: {
                        message.terminal = $root.tieba.Terminal.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.position = $root.tieba.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        if (!(message.spriteInfo && message.spriteInfo.length))
                            message.spriteInfo = [];
                        message.spriteInfo.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Icon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Icon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Icon} Icon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Icon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Icon message.
         * @function verify
         * @memberof tieba.Icon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Icon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.icon != null && message.hasOwnProperty("icon"))
                if (!$util.isString(message.icon))
                    return "icon: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.terminal != null && message.hasOwnProperty("terminal")) {
                let error = $root.tieba.Terminal.verify(message.terminal);
                if (error)
                    return "terminal." + error;
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.tieba.Position.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.spriteInfo != null && message.hasOwnProperty("spriteInfo")) {
                if (!Array.isArray(message.spriteInfo))
                    return "spriteInfo: array expected";
                for (let i = 0; i < message.spriteInfo.length; ++i)
                    if (!$util.isString(message.spriteInfo[i]))
                        return "spriteInfo: string[] expected";
            }
            return null;
        };

        /**
         * Creates an Icon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Icon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Icon} Icon
         */
        Icon.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Icon)
                return object;
            let message = new $root.tieba.Icon();
            if (object.name != null)
                message.name = String(object.name);
            if (object.weight != null)
                message.weight = object.weight | 0;
            if (object.url != null)
                message.url = String(object.url);
            if (object.icon != null)
                message.icon = String(object.icon);
            if (object.value != null)
                message.value = object.value | 0;
            if (object.terminal != null) {
                if (typeof object.terminal !== "object")
                    throw TypeError(".tieba.Icon.terminal: object expected");
                message.terminal = $root.tieba.Terminal.fromObject(object.terminal);
            }
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".tieba.Icon.position: object expected");
                message.position = $root.tieba.Position.fromObject(object.position);
            }
            if (object.spriteInfo) {
                if (!Array.isArray(object.spriteInfo))
                    throw TypeError(".tieba.Icon.spriteInfo: array expected");
                message.spriteInfo = [];
                for (let i = 0; i < object.spriteInfo.length; ++i)
                    message.spriteInfo[i] = String(object.spriteInfo[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an Icon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Icon
         * @static
         * @param {tieba.Icon} message Icon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Icon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.spriteInfo = [];
            if (options.defaults) {
                object.name = "";
                object.weight = 0;
                object.url = "";
                object.icon = "";
                object.value = 0;
                object.terminal = null;
                object.position = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.icon != null && message.hasOwnProperty("icon"))
                object.icon = message.icon;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.terminal != null && message.hasOwnProperty("terminal"))
                object.terminal = $root.tieba.Terminal.toObject(message.terminal, options);
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.tieba.Position.toObject(message.position, options);
            if (message.spriteInfo && message.spriteInfo.length) {
                object.spriteInfo = [];
                for (let j = 0; j < message.spriteInfo.length; ++j)
                    object.spriteInfo[j] = message.spriteInfo[j];
            }
            return object;
        };

        /**
         * Converts this Icon to JSON.
         * @function toJSON
         * @memberof tieba.Icon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Icon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Icon
         * @function getTypeUrl
         * @memberof tieba.Icon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Icon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Icon";
        };

        return Icon;
    })();

    tieba.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof tieba
         * @interface IPosition
         * @property {number|null} [frs] Position frs
         * @property {number|null} [pb] Position pb
         * @property {number|null} [home] Position home
         * @property {number|null} [card] Position card
         */

        /**
         * Constructs a new Position.
         * @memberof tieba
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {tieba.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position frs.
         * @member {number} frs
         * @memberof tieba.Position
         * @instance
         */
        Position.prototype.frs = 0;

        /**
         * Position pb.
         * @member {number} pb
         * @memberof tieba.Position
         * @instance
         */
        Position.prototype.pb = 0;

        /**
         * Position home.
         * @member {number} home
         * @memberof tieba.Position
         * @instance
         */
        Position.prototype.home = 0;

        /**
         * Position card.
         * @member {number} card
         * @memberof tieba.Position
         * @instance
         */
        Position.prototype.card = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof tieba.Position
         * @static
         * @param {tieba.IPosition=} [properties] Properties to set
         * @returns {tieba.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link tieba.Position.verify|verify} messages.
         * @function encode
         * @memberof tieba.Position
         * @static
         * @param {tieba.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frs != null && Object.hasOwnProperty.call(message, "frs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.frs);
            if (message.pb != null && Object.hasOwnProperty.call(message, "pb"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pb);
            if (message.home != null && Object.hasOwnProperty.call(message, "home"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.home);
            if (message.card != null && Object.hasOwnProperty.call(message, "card"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.card);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link tieba.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Position
         * @static
         * @param {tieba.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Position();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.frs = reader.int32();
                        break;
                    }
                case 2: {
                        message.pb = reader.int32();
                        break;
                    }
                case 3: {
                        message.home = reader.int32();
                        break;
                    }
                case 4: {
                        message.card = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof tieba.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frs != null && message.hasOwnProperty("frs"))
                if (!$util.isInteger(message.frs))
                    return "frs: integer expected";
            if (message.pb != null && message.hasOwnProperty("pb"))
                if (!$util.isInteger(message.pb))
                    return "pb: integer expected";
            if (message.home != null && message.hasOwnProperty("home"))
                if (!$util.isInteger(message.home))
                    return "home: integer expected";
            if (message.card != null && message.hasOwnProperty("card"))
                if (!$util.isInteger(message.card))
                    return "card: integer expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Position)
                return object;
            let message = new $root.tieba.Position();
            if (object.frs != null)
                message.frs = object.frs | 0;
            if (object.pb != null)
                message.pb = object.pb | 0;
            if (object.home != null)
                message.home = object.home | 0;
            if (object.card != null)
                message.card = object.card | 0;
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Position
         * @static
         * @param {tieba.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.frs = 0;
                object.pb = 0;
                object.home = 0;
                object.card = 0;
            }
            if (message.frs != null && message.hasOwnProperty("frs"))
                object.frs = message.frs;
            if (message.pb != null && message.hasOwnProperty("pb"))
                object.pb = message.pb;
            if (message.home != null && message.hasOwnProperty("home"))
                object.home = message.home;
            if (message.card != null && message.hasOwnProperty("card"))
                object.card = message.card;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof tieba.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof tieba.Position
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Position";
        };

        return Position;
    })();

    tieba.Terminal = (function() {

        /**
         * Properties of a Terminal.
         * @memberof tieba
         * @interface ITerminal
         * @property {number|null} [pc] Terminal pc
         * @property {number|null} [wap] Terminal wap
         * @property {number|null} [client] Terminal client
         */

        /**
         * Constructs a new Terminal.
         * @memberof tieba
         * @classdesc Represents a Terminal.
         * @implements ITerminal
         * @constructor
         * @param {tieba.ITerminal=} [properties] Properties to set
         */
        function Terminal(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Terminal pc.
         * @member {number} pc
         * @memberof tieba.Terminal
         * @instance
         */
        Terminal.prototype.pc = 0;

        /**
         * Terminal wap.
         * @member {number} wap
         * @memberof tieba.Terminal
         * @instance
         */
        Terminal.prototype.wap = 0;

        /**
         * Terminal client.
         * @member {number} client
         * @memberof tieba.Terminal
         * @instance
         */
        Terminal.prototype.client = 0;

        /**
         * Creates a new Terminal instance using the specified properties.
         * @function create
         * @memberof tieba.Terminal
         * @static
         * @param {tieba.ITerminal=} [properties] Properties to set
         * @returns {tieba.Terminal} Terminal instance
         */
        Terminal.create = function create(properties) {
            return new Terminal(properties);
        };

        /**
         * Encodes the specified Terminal message. Does not implicitly {@link tieba.Terminal.verify|verify} messages.
         * @function encode
         * @memberof tieba.Terminal
         * @static
         * @param {tieba.ITerminal} message Terminal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Terminal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pc != null && Object.hasOwnProperty.call(message, "pc"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pc);
            if (message.wap != null && Object.hasOwnProperty.call(message, "wap"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.wap);
            if (message.client != null && Object.hasOwnProperty.call(message, "client"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.client);
            return writer;
        };

        /**
         * Encodes the specified Terminal message, length delimited. Does not implicitly {@link tieba.Terminal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Terminal
         * @static
         * @param {tieba.ITerminal} message Terminal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Terminal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Terminal message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Terminal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Terminal} Terminal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Terminal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Terminal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pc = reader.int32();
                        break;
                    }
                case 2: {
                        message.wap = reader.int32();
                        break;
                    }
                case 3: {
                        message.client = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Terminal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Terminal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Terminal} Terminal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Terminal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Terminal message.
         * @function verify
         * @memberof tieba.Terminal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Terminal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pc != null && message.hasOwnProperty("pc"))
                if (!$util.isInteger(message.pc))
                    return "pc: integer expected";
            if (message.wap != null && message.hasOwnProperty("wap"))
                if (!$util.isInteger(message.wap))
                    return "wap: integer expected";
            if (message.client != null && message.hasOwnProperty("client"))
                if (!$util.isInteger(message.client))
                    return "client: integer expected";
            return null;
        };

        /**
         * Creates a Terminal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Terminal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Terminal} Terminal
         */
        Terminal.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Terminal)
                return object;
            let message = new $root.tieba.Terminal();
            if (object.pc != null)
                message.pc = object.pc | 0;
            if (object.wap != null)
                message.wap = object.wap | 0;
            if (object.client != null)
                message.client = object.client | 0;
            return message;
        };

        /**
         * Creates a plain object from a Terminal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Terminal
         * @static
         * @param {tieba.Terminal} message Terminal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Terminal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pc = 0;
                object.wap = 0;
                object.client = 0;
            }
            if (message.pc != null && message.hasOwnProperty("pc"))
                object.pc = message.pc;
            if (message.wap != null && message.hasOwnProperty("wap"))
                object.wap = message.wap;
            if (message.client != null && message.hasOwnProperty("client"))
                object.client = message.client;
            return object;
        };

        /**
         * Converts this Terminal to JSON.
         * @function toJSON
         * @memberof tieba.Terminal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Terminal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Terminal
         * @function getTypeUrl
         * @memberof tieba.Terminal
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Terminal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Terminal";
        };

        return Terminal;
    })();

    tieba.LikeForumInfo = (function() {

        /**
         * Properties of a LikeForumInfo.
         * @memberof tieba
         * @interface ILikeForumInfo
         * @property {string|null} [forumName] LikeForumInfo forumName
         * @property {number|Long|null} [forumId] LikeForumInfo forumId
         */

        /**
         * Constructs a new LikeForumInfo.
         * @memberof tieba
         * @classdesc Represents a LikeForumInfo.
         * @implements ILikeForumInfo
         * @constructor
         * @param {tieba.ILikeForumInfo=} [properties] Properties to set
         */
        function LikeForumInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LikeForumInfo forumName.
         * @member {string} forumName
         * @memberof tieba.LikeForumInfo
         * @instance
         */
        LikeForumInfo.prototype.forumName = "";

        /**
         * LikeForumInfo forumId.
         * @member {number|Long} forumId
         * @memberof tieba.LikeForumInfo
         * @instance
         */
        LikeForumInfo.prototype.forumId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new LikeForumInfo instance using the specified properties.
         * @function create
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {tieba.ILikeForumInfo=} [properties] Properties to set
         * @returns {tieba.LikeForumInfo} LikeForumInfo instance
         */
        LikeForumInfo.create = function create(properties) {
            return new LikeForumInfo(properties);
        };

        /**
         * Encodes the specified LikeForumInfo message. Does not implicitly {@link tieba.LikeForumInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {tieba.ILikeForumInfo} message LikeForumInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeForumInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.forumName);
            if (message.forumId != null && Object.hasOwnProperty.call(message, "forumId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.forumId);
            return writer;
        };

        /**
         * Encodes the specified LikeForumInfo message, length delimited. Does not implicitly {@link tieba.LikeForumInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {tieba.ILikeForumInfo} message LikeForumInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeForumInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LikeForumInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.LikeForumInfo} LikeForumInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeForumInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.LikeForumInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.forumName = reader.string();
                        break;
                    }
                case 2: {
                        message.forumId = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LikeForumInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.LikeForumInfo} LikeForumInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeForumInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LikeForumInfo message.
         * @function verify
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LikeForumInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                if (!$util.isString(message.forumName))
                    return "forumName: string expected";
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (!$util.isInteger(message.forumId) && !(message.forumId && $util.isInteger(message.forumId.low) && $util.isInteger(message.forumId.high)))
                    return "forumId: integer|Long expected";
            return null;
        };

        /**
         * Creates a LikeForumInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.LikeForumInfo} LikeForumInfo
         */
        LikeForumInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.LikeForumInfo)
                return object;
            let message = new $root.tieba.LikeForumInfo();
            if (object.forumName != null)
                message.forumName = String(object.forumName);
            if (object.forumId != null)
                if ($util.Long)
                    (message.forumId = $util.Long.fromValue(object.forumId)).unsigned = true;
                else if (typeof object.forumId === "string")
                    message.forumId = parseInt(object.forumId, 10);
                else if (typeof object.forumId === "number")
                    message.forumId = object.forumId;
                else if (typeof object.forumId === "object")
                    message.forumId = new $util.LongBits(object.forumId.low >>> 0, object.forumId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a LikeForumInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {tieba.LikeForumInfo} message LikeForumInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LikeForumInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.forumName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.forumId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.forumId = options.longs === String ? "0" : 0;
            }
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                object.forumName = message.forumName;
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (typeof message.forumId === "number")
                    object.forumId = options.longs === String ? String(message.forumId) : message.forumId;
                else
                    object.forumId = options.longs === String ? $util.Long.prototype.toString.call(message.forumId) : options.longs === Number ? new $util.LongBits(message.forumId.low >>> 0, message.forumId.high >>> 0).toNumber(true) : message.forumId;
            return object;
        };

        /**
         * Converts this LikeForumInfo to JSON.
         * @function toJSON
         * @memberof tieba.LikeForumInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LikeForumInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LikeForumInfo
         * @function getTypeUrl
         * @memberof tieba.LikeForumInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LikeForumInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.LikeForumInfo";
        };

        return LikeForumInfo;
    })();

    tieba.NewGodInfo = (function() {

        /**
         * Properties of a NewGodInfo.
         * @memberof tieba
         * @interface INewGodInfo
         * @property {number|null} [status] NewGodInfo status
         * @property {number|null} [fieldId] NewGodInfo fieldId
         * @property {string|null} [fieldName] NewGodInfo fieldName
         * @property {number|null} [type] NewGodInfo type
         * @property {string|null} [typeName] NewGodInfo typeName
         */

        /**
         * Constructs a new NewGodInfo.
         * @memberof tieba
         * @classdesc Represents a NewGodInfo.
         * @implements INewGodInfo
         * @constructor
         * @param {tieba.INewGodInfo=} [properties] Properties to set
         */
        function NewGodInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewGodInfo status.
         * @member {number} status
         * @memberof tieba.NewGodInfo
         * @instance
         */
        NewGodInfo.prototype.status = 0;

        /**
         * NewGodInfo fieldId.
         * @member {number} fieldId
         * @memberof tieba.NewGodInfo
         * @instance
         */
        NewGodInfo.prototype.fieldId = 0;

        /**
         * NewGodInfo fieldName.
         * @member {string} fieldName
         * @memberof tieba.NewGodInfo
         * @instance
         */
        NewGodInfo.prototype.fieldName = "";

        /**
         * NewGodInfo type.
         * @member {number} type
         * @memberof tieba.NewGodInfo
         * @instance
         */
        NewGodInfo.prototype.type = 0;

        /**
         * NewGodInfo typeName.
         * @member {string} typeName
         * @memberof tieba.NewGodInfo
         * @instance
         */
        NewGodInfo.prototype.typeName = "";

        /**
         * Creates a new NewGodInfo instance using the specified properties.
         * @function create
         * @memberof tieba.NewGodInfo
         * @static
         * @param {tieba.INewGodInfo=} [properties] Properties to set
         * @returns {tieba.NewGodInfo} NewGodInfo instance
         */
        NewGodInfo.create = function create(properties) {
            return new NewGodInfo(properties);
        };

        /**
         * Encodes the specified NewGodInfo message. Does not implicitly {@link tieba.NewGodInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.NewGodInfo
         * @static
         * @param {tieba.INewGodInfo} message NewGodInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewGodInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.fieldId != null && Object.hasOwnProperty.call(message, "fieldId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fieldId);
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fieldName);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.type);
            if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.typeName);
            return writer;
        };

        /**
         * Encodes the specified NewGodInfo message, length delimited. Does not implicitly {@link tieba.NewGodInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.NewGodInfo
         * @static
         * @param {tieba.INewGodInfo} message NewGodInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewGodInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewGodInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.NewGodInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.NewGodInfo} NewGodInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewGodInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.NewGodInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        message.fieldId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.fieldName = reader.string();
                        break;
                    }
                case 4: {
                        message.type = reader.uint32();
                        break;
                    }
                case 5: {
                        message.typeName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewGodInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.NewGodInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.NewGodInfo} NewGodInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewGodInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewGodInfo message.
         * @function verify
         * @memberof tieba.NewGodInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewGodInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.fieldId != null && message.hasOwnProperty("fieldId"))
                if (!$util.isInteger(message.fieldId))
                    return "fieldId: integer expected";
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                if (!$util.isString(message.fieldName))
                    return "fieldName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                if (!$util.isString(message.typeName))
                    return "typeName: string expected";
            return null;
        };

        /**
         * Creates a NewGodInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.NewGodInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.NewGodInfo} NewGodInfo
         */
        NewGodInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.NewGodInfo)
                return object;
            let message = new $root.tieba.NewGodInfo();
            if (object.status != null)
                message.status = object.status | 0;
            if (object.fieldId != null)
                message.fieldId = object.fieldId >>> 0;
            if (object.fieldName != null)
                message.fieldName = String(object.fieldName);
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.typeName != null)
                message.typeName = String(object.typeName);
            return message;
        };

        /**
         * Creates a plain object from a NewGodInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.NewGodInfo
         * @static
         * @param {tieba.NewGodInfo} message NewGodInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewGodInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = 0;
                object.fieldId = 0;
                object.fieldName = "";
                object.type = 0;
                object.typeName = "";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.fieldId != null && message.hasOwnProperty("fieldId"))
                object.fieldId = message.fieldId;
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                object.fieldName = message.fieldName;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.typeName != null && message.hasOwnProperty("typeName"))
                object.typeName = message.typeName;
            return object;
        };

        /**
         * Converts this NewGodInfo to JSON.
         * @function toJSON
         * @memberof tieba.NewGodInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewGodInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NewGodInfo
         * @function getTypeUrl
         * @memberof tieba.NewGodInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NewGodInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.NewGodInfo";
        };

        return NewGodInfo;
    })();

    tieba.UserPics = (function() {

        /**
         * Properties of a UserPics.
         * @memberof tieba
         * @interface IUserPics
         * @property {string|null} [big] UserPics big
         * @property {string|null} [small] UserPics small
         */

        /**
         * Constructs a new UserPics.
         * @memberof tieba
         * @classdesc Represents a UserPics.
         * @implements IUserPics
         * @constructor
         * @param {tieba.IUserPics=} [properties] Properties to set
         */
        function UserPics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserPics big.
         * @member {string} big
         * @memberof tieba.UserPics
         * @instance
         */
        UserPics.prototype.big = "";

        /**
         * UserPics small.
         * @member {string} small
         * @memberof tieba.UserPics
         * @instance
         */
        UserPics.prototype.small = "";

        /**
         * Creates a new UserPics instance using the specified properties.
         * @function create
         * @memberof tieba.UserPics
         * @static
         * @param {tieba.IUserPics=} [properties] Properties to set
         * @returns {tieba.UserPics} UserPics instance
         */
        UserPics.create = function create(properties) {
            return new UserPics(properties);
        };

        /**
         * Encodes the specified UserPics message. Does not implicitly {@link tieba.UserPics.verify|verify} messages.
         * @function encode
         * @memberof tieba.UserPics
         * @static
         * @param {tieba.IUserPics} message UserPics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.big != null && Object.hasOwnProperty.call(message, "big"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.big);
            if (message.small != null && Object.hasOwnProperty.call(message, "small"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.small);
            return writer;
        };

        /**
         * Encodes the specified UserPics message, length delimited. Does not implicitly {@link tieba.UserPics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.UserPics
         * @static
         * @param {tieba.IUserPics} message UserPics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserPics message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.UserPics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.UserPics} UserPics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.UserPics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.big = reader.string();
                        break;
                    }
                case 2: {
                        message.small = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserPics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.UserPics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.UserPics} UserPics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserPics message.
         * @function verify
         * @memberof tieba.UserPics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserPics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.big != null && message.hasOwnProperty("big"))
                if (!$util.isString(message.big))
                    return "big: string expected";
            if (message.small != null && message.hasOwnProperty("small"))
                if (!$util.isString(message.small))
                    return "small: string expected";
            return null;
        };

        /**
         * Creates a UserPics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.UserPics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.UserPics} UserPics
         */
        UserPics.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.UserPics)
                return object;
            let message = new $root.tieba.UserPics();
            if (object.big != null)
                message.big = String(object.big);
            if (object.small != null)
                message.small = String(object.small);
            return message;
        };

        /**
         * Creates a plain object from a UserPics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.UserPics
         * @static
         * @param {tieba.UserPics} message UserPics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserPics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.big = "";
                object.small = "";
            }
            if (message.big != null && message.hasOwnProperty("big"))
                object.big = message.big;
            if (message.small != null && message.hasOwnProperty("small"))
                object.small = message.small;
            return object;
        };

        /**
         * Converts this UserPics to JSON.
         * @function toJSON
         * @memberof tieba.UserPics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserPics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserPics
         * @function getTypeUrl
         * @memberof tieba.UserPics
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserPics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.UserPics";
        };

        return UserPics;
    })();

    tieba.PrivSets = (function() {

        /**
         * Properties of a PrivSets.
         * @memberof tieba
         * @interface IPrivSets
         * @property {number|null} [like] PrivSets like
         * @property {number|null} [group] PrivSets group
         * @property {number|null} [post] PrivSets post
         * @property {number|null} [live] PrivSets live
         */

        /**
         * Constructs a new PrivSets.
         * @memberof tieba
         * @classdesc Represents a PrivSets.
         * @implements IPrivSets
         * @constructor
         * @param {tieba.IPrivSets=} [properties] Properties to set
         */
        function PrivSets(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivSets like.
         * @member {number} like
         * @memberof tieba.PrivSets
         * @instance
         */
        PrivSets.prototype.like = 0;

        /**
         * PrivSets group.
         * @member {number} group
         * @memberof tieba.PrivSets
         * @instance
         */
        PrivSets.prototype.group = 0;

        /**
         * PrivSets post.
         * @member {number} post
         * @memberof tieba.PrivSets
         * @instance
         */
        PrivSets.prototype.post = 0;

        /**
         * PrivSets live.
         * @member {number} live
         * @memberof tieba.PrivSets
         * @instance
         */
        PrivSets.prototype.live = 0;

        /**
         * Creates a new PrivSets instance using the specified properties.
         * @function create
         * @memberof tieba.PrivSets
         * @static
         * @param {tieba.IPrivSets=} [properties] Properties to set
         * @returns {tieba.PrivSets} PrivSets instance
         */
        PrivSets.create = function create(properties) {
            return new PrivSets(properties);
        };

        /**
         * Encodes the specified PrivSets message. Does not implicitly {@link tieba.PrivSets.verify|verify} messages.
         * @function encode
         * @memberof tieba.PrivSets
         * @static
         * @param {tieba.IPrivSets} message PrivSets message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivSets.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.like != null && Object.hasOwnProperty.call(message, "like"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.like);
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.group);
            if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.post);
            if (message.live != null && Object.hasOwnProperty.call(message, "live"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.live);
            return writer;
        };

        /**
         * Encodes the specified PrivSets message, length delimited. Does not implicitly {@link tieba.PrivSets.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.PrivSets
         * @static
         * @param {tieba.IPrivSets} message PrivSets message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivSets.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivSets message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.PrivSets
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.PrivSets} PrivSets
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivSets.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.PrivSets();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.like = reader.int32();
                        break;
                    }
                case 3: {
                        message.group = reader.int32();
                        break;
                    }
                case 4: {
                        message.post = reader.int32();
                        break;
                    }
                case 6: {
                        message.live = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivSets message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.PrivSets
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.PrivSets} PrivSets
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivSets.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivSets message.
         * @function verify
         * @memberof tieba.PrivSets
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivSets.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.like != null && message.hasOwnProperty("like"))
                if (!$util.isInteger(message.like))
                    return "like: integer expected";
            if (message.group != null && message.hasOwnProperty("group"))
                if (!$util.isInteger(message.group))
                    return "group: integer expected";
            if (message.post != null && message.hasOwnProperty("post"))
                if (!$util.isInteger(message.post))
                    return "post: integer expected";
            if (message.live != null && message.hasOwnProperty("live"))
                if (!$util.isInteger(message.live))
                    return "live: integer expected";
            return null;
        };

        /**
         * Creates a PrivSets message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.PrivSets
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.PrivSets} PrivSets
         */
        PrivSets.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.PrivSets)
                return object;
            let message = new $root.tieba.PrivSets();
            if (object.like != null)
                message.like = object.like | 0;
            if (object.group != null)
                message.group = object.group | 0;
            if (object.post != null)
                message.post = object.post | 0;
            if (object.live != null)
                message.live = object.live | 0;
            return message;
        };

        /**
         * Creates a plain object from a PrivSets message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.PrivSets
         * @static
         * @param {tieba.PrivSets} message PrivSets
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivSets.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.like = 0;
                object.group = 0;
                object.post = 0;
                object.live = 0;
            }
            if (message.like != null && message.hasOwnProperty("like"))
                object.like = message.like;
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = message.group;
            if (message.post != null && message.hasOwnProperty("post"))
                object.post = message.post;
            if (message.live != null && message.hasOwnProperty("live"))
                object.live = message.live;
            return object;
        };

        /**
         * Converts this PrivSets to JSON.
         * @function toJSON
         * @memberof tieba.PrivSets
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivSets.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PrivSets
         * @function getTypeUrl
         * @memberof tieba.PrivSets
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PrivSets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.PrivSets";
        };

        return PrivSets;
    })();

    tieba.SimpleUser = (function() {

        /**
         * Properties of a SimpleUser.
         * @memberof tieba
         * @interface ISimpleUser
         * @property {number|Long|null} [userId] SimpleUser userId
         * @property {number|null} [userStatus] SimpleUser userStatus
         * @property {string|null} [secureemail] SimpleUser secureemail
         * @property {string|null} [securemobil] SimpleUser securemobil
         * @property {string|null} [userName] SimpleUser userName
         * @property {string|null} [userNickname] SimpleUser userNickname
         * @property {number|null} [incompleteUser] SimpleUser incompleteUser
         * @property {string|null} [portrait] SimpleUser portrait
         * @property {number|null} [agreeType] SimpleUser agreeType
         * @property {string|null} [aheadUrl] SimpleUser aheadUrl
         * @property {string|null} [blockMsg] SimpleUser blockMsg
         * @property {number|null} [showOnlyme] SimpleUser showOnlyme
         */

        /**
         * Constructs a new SimpleUser.
         * @memberof tieba
         * @classdesc Represents a SimpleUser.
         * @implements ISimpleUser
         * @constructor
         * @param {tieba.ISimpleUser=} [properties] Properties to set
         */
        function SimpleUser(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleUser userId.
         * @member {number|Long} userId
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SimpleUser userStatus.
         * @member {number} userStatus
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.userStatus = 0;

        /**
         * SimpleUser secureemail.
         * @member {string} secureemail
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.secureemail = "";

        /**
         * SimpleUser securemobil.
         * @member {string} securemobil
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.securemobil = "";

        /**
         * SimpleUser userName.
         * @member {string} userName
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.userName = "";

        /**
         * SimpleUser userNickname.
         * @member {string} userNickname
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.userNickname = "";

        /**
         * SimpleUser incompleteUser.
         * @member {number} incompleteUser
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.incompleteUser = 0;

        /**
         * SimpleUser portrait.
         * @member {string} portrait
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.portrait = "";

        /**
         * SimpleUser agreeType.
         * @member {number} agreeType
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.agreeType = 0;

        /**
         * SimpleUser aheadUrl.
         * @member {string} aheadUrl
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.aheadUrl = "";

        /**
         * SimpleUser blockMsg.
         * @member {string} blockMsg
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.blockMsg = "";

        /**
         * SimpleUser showOnlyme.
         * @member {number} showOnlyme
         * @memberof tieba.SimpleUser
         * @instance
         */
        SimpleUser.prototype.showOnlyme = 0;

        /**
         * Creates a new SimpleUser instance using the specified properties.
         * @function create
         * @memberof tieba.SimpleUser
         * @static
         * @param {tieba.ISimpleUser=} [properties] Properties to set
         * @returns {tieba.SimpleUser} SimpleUser instance
         */
        SimpleUser.create = function create(properties) {
            return new SimpleUser(properties);
        };

        /**
         * Encodes the specified SimpleUser message. Does not implicitly {@link tieba.SimpleUser.verify|verify} messages.
         * @function encode
         * @memberof tieba.SimpleUser
         * @static
         * @param {tieba.ISimpleUser} message SimpleUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.userId);
            if (message.userStatus != null && Object.hasOwnProperty.call(message, "userStatus"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userStatus);
            if (message.secureemail != null && Object.hasOwnProperty.call(message, "secureemail"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.secureemail);
            if (message.securemobil != null && Object.hasOwnProperty.call(message, "securemobil"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.securemobil);
            if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.userName);
            if (message.userNickname != null && Object.hasOwnProperty.call(message, "userNickname"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.userNickname);
            if (message.incompleteUser != null && Object.hasOwnProperty.call(message, "incompleteUser"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.incompleteUser);
            if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.portrait);
            if (message.agreeType != null && Object.hasOwnProperty.call(message, "agreeType"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.agreeType);
            if (message.aheadUrl != null && Object.hasOwnProperty.call(message, "aheadUrl"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.aheadUrl);
            if (message.blockMsg != null && Object.hasOwnProperty.call(message, "blockMsg"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.blockMsg);
            if (message.showOnlyme != null && Object.hasOwnProperty.call(message, "showOnlyme"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.showOnlyme);
            return writer;
        };

        /**
         * Encodes the specified SimpleUser message, length delimited. Does not implicitly {@link tieba.SimpleUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.SimpleUser
         * @static
         * @param {tieba.ISimpleUser} message SimpleUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleUser message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.SimpleUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.SimpleUser} SimpleUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.SimpleUser();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.int64();
                        break;
                    }
                case 2: {
                        message.userStatus = reader.int32();
                        break;
                    }
                case 3: {
                        message.secureemail = reader.string();
                        break;
                    }
                case 4: {
                        message.securemobil = reader.string();
                        break;
                    }
                case 5: {
                        message.userName = reader.string();
                        break;
                    }
                case 6: {
                        message.userNickname = reader.string();
                        break;
                    }
                case 7: {
                        message.incompleteUser = reader.uint32();
                        break;
                    }
                case 8: {
                        message.portrait = reader.string();
                        break;
                    }
                case 9: {
                        message.agreeType = reader.int32();
                        break;
                    }
                case 10: {
                        message.aheadUrl = reader.string();
                        break;
                    }
                case 11: {
                        message.blockMsg = reader.string();
                        break;
                    }
                case 12: {
                        message.showOnlyme = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.SimpleUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.SimpleUser} SimpleUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleUser message.
         * @function verify
         * @memberof tieba.SimpleUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            if (message.userStatus != null && message.hasOwnProperty("userStatus"))
                if (!$util.isInteger(message.userStatus))
                    return "userStatus: integer expected";
            if (message.secureemail != null && message.hasOwnProperty("secureemail"))
                if (!$util.isString(message.secureemail))
                    return "secureemail: string expected";
            if (message.securemobil != null && message.hasOwnProperty("securemobil"))
                if (!$util.isString(message.securemobil))
                    return "securemobil: string expected";
            if (message.userName != null && message.hasOwnProperty("userName"))
                if (!$util.isString(message.userName))
                    return "userName: string expected";
            if (message.userNickname != null && message.hasOwnProperty("userNickname"))
                if (!$util.isString(message.userNickname))
                    return "userNickname: string expected";
            if (message.incompleteUser != null && message.hasOwnProperty("incompleteUser"))
                if (!$util.isInteger(message.incompleteUser))
                    return "incompleteUser: integer expected";
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                if (!$util.isString(message.portrait))
                    return "portrait: string expected";
            if (message.agreeType != null && message.hasOwnProperty("agreeType"))
                if (!$util.isInteger(message.agreeType))
                    return "agreeType: integer expected";
            if (message.aheadUrl != null && message.hasOwnProperty("aheadUrl"))
                if (!$util.isString(message.aheadUrl))
                    return "aheadUrl: string expected";
            if (message.blockMsg != null && message.hasOwnProperty("blockMsg"))
                if (!$util.isString(message.blockMsg))
                    return "blockMsg: string expected";
            if (message.showOnlyme != null && message.hasOwnProperty("showOnlyme"))
                if (!$util.isInteger(message.showOnlyme))
                    return "showOnlyme: integer expected";
            return null;
        };

        /**
         * Creates a SimpleUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.SimpleUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.SimpleUser} SimpleUser
         */
        SimpleUser.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.SimpleUser)
                return object;
            let message = new $root.tieba.SimpleUser();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
            if (object.userStatus != null)
                message.userStatus = object.userStatus | 0;
            if (object.secureemail != null)
                message.secureemail = String(object.secureemail);
            if (object.securemobil != null)
                message.securemobil = String(object.securemobil);
            if (object.userName != null)
                message.userName = String(object.userName);
            if (object.userNickname != null)
                message.userNickname = String(object.userNickname);
            if (object.incompleteUser != null)
                message.incompleteUser = object.incompleteUser >>> 0;
            if (object.portrait != null)
                message.portrait = String(object.portrait);
            if (object.agreeType != null)
                message.agreeType = object.agreeType | 0;
            if (object.aheadUrl != null)
                message.aheadUrl = String(object.aheadUrl);
            if (object.blockMsg != null)
                message.blockMsg = String(object.blockMsg);
            if (object.showOnlyme != null)
                message.showOnlyme = object.showOnlyme | 0;
            return message;
        };

        /**
         * Creates a plain object from a SimpleUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.SimpleUser
         * @static
         * @param {tieba.SimpleUser} message SimpleUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimpleUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
                object.userStatus = 0;
                object.secureemail = "";
                object.securemobil = "";
                object.userName = "";
                object.userNickname = "";
                object.incompleteUser = 0;
                object.portrait = "";
                object.agreeType = 0;
                object.aheadUrl = "";
                object.blockMsg = "";
                object.showOnlyme = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
            if (message.userStatus != null && message.hasOwnProperty("userStatus"))
                object.userStatus = message.userStatus;
            if (message.secureemail != null && message.hasOwnProperty("secureemail"))
                object.secureemail = message.secureemail;
            if (message.securemobil != null && message.hasOwnProperty("securemobil"))
                object.securemobil = message.securemobil;
            if (message.userName != null && message.hasOwnProperty("userName"))
                object.userName = message.userName;
            if (message.userNickname != null && message.hasOwnProperty("userNickname"))
                object.userNickname = message.userNickname;
            if (message.incompleteUser != null && message.hasOwnProperty("incompleteUser"))
                object.incompleteUser = message.incompleteUser;
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                object.portrait = message.portrait;
            if (message.agreeType != null && message.hasOwnProperty("agreeType"))
                object.agreeType = message.agreeType;
            if (message.aheadUrl != null && message.hasOwnProperty("aheadUrl"))
                object.aheadUrl = message.aheadUrl;
            if (message.blockMsg != null && message.hasOwnProperty("blockMsg"))
                object.blockMsg = message.blockMsg;
            if (message.showOnlyme != null && message.hasOwnProperty("showOnlyme"))
                object.showOnlyme = message.showOnlyme;
            return object;
        };

        /**
         * Converts this SimpleUser to JSON.
         * @function toJSON
         * @memberof tieba.SimpleUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimpleUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimpleUser
         * @function getTypeUrl
         * @memberof tieba.SimpleUser
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimpleUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.SimpleUser";
        };

        return SimpleUser;
    })();

    tieba.LabelInfo = (function() {

        /**
         * Properties of a LabelInfo.
         * @memberof tieba
         * @interface ILabelInfo
         * @property {number|null} [labelHot] LabelInfo labelHot
         * @property {string|null} [labelContent] LabelInfo labelContent
         * @property {string|null} [labelId] LabelInfo labelId
         */

        /**
         * Constructs a new LabelInfo.
         * @memberof tieba
         * @classdesc Represents a LabelInfo.
         * @implements ILabelInfo
         * @constructor
         * @param {tieba.ILabelInfo=} [properties] Properties to set
         */
        function LabelInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LabelInfo labelHot.
         * @member {number} labelHot
         * @memberof tieba.LabelInfo
         * @instance
         */
        LabelInfo.prototype.labelHot = 0;

        /**
         * LabelInfo labelContent.
         * @member {string} labelContent
         * @memberof tieba.LabelInfo
         * @instance
         */
        LabelInfo.prototype.labelContent = "";

        /**
         * LabelInfo labelId.
         * @member {string} labelId
         * @memberof tieba.LabelInfo
         * @instance
         */
        LabelInfo.prototype.labelId = "";

        /**
         * Creates a new LabelInfo instance using the specified properties.
         * @function create
         * @memberof tieba.LabelInfo
         * @static
         * @param {tieba.ILabelInfo=} [properties] Properties to set
         * @returns {tieba.LabelInfo} LabelInfo instance
         */
        LabelInfo.create = function create(properties) {
            return new LabelInfo(properties);
        };

        /**
         * Encodes the specified LabelInfo message. Does not implicitly {@link tieba.LabelInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.LabelInfo
         * @static
         * @param {tieba.ILabelInfo} message LabelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LabelInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.labelHot != null && Object.hasOwnProperty.call(message, "labelHot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.labelHot);
            if (message.labelContent != null && Object.hasOwnProperty.call(message, "labelContent"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.labelContent);
            if (message.labelId != null && Object.hasOwnProperty.call(message, "labelId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.labelId);
            return writer;
        };

        /**
         * Encodes the specified LabelInfo message, length delimited. Does not implicitly {@link tieba.LabelInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.LabelInfo
         * @static
         * @param {tieba.ILabelInfo} message LabelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LabelInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LabelInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.LabelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.LabelInfo} LabelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LabelInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.LabelInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.labelHot = reader.int32();
                        break;
                    }
                case 2: {
                        message.labelContent = reader.string();
                        break;
                    }
                case 3: {
                        message.labelId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LabelInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.LabelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.LabelInfo} LabelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LabelInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LabelInfo message.
         * @function verify
         * @memberof tieba.LabelInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LabelInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.labelHot != null && message.hasOwnProperty("labelHot"))
                if (!$util.isInteger(message.labelHot))
                    return "labelHot: integer expected";
            if (message.labelContent != null && message.hasOwnProperty("labelContent"))
                if (!$util.isString(message.labelContent))
                    return "labelContent: string expected";
            if (message.labelId != null && message.hasOwnProperty("labelId"))
                if (!$util.isString(message.labelId))
                    return "labelId: string expected";
            return null;
        };

        /**
         * Creates a LabelInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.LabelInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.LabelInfo} LabelInfo
         */
        LabelInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.LabelInfo)
                return object;
            let message = new $root.tieba.LabelInfo();
            if (object.labelHot != null)
                message.labelHot = object.labelHot | 0;
            if (object.labelContent != null)
                message.labelContent = String(object.labelContent);
            if (object.labelId != null)
                message.labelId = String(object.labelId);
            return message;
        };

        /**
         * Creates a plain object from a LabelInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.LabelInfo
         * @static
         * @param {tieba.LabelInfo} message LabelInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LabelInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.labelHot = 0;
                object.labelContent = "";
                object.labelId = "";
            }
            if (message.labelHot != null && message.hasOwnProperty("labelHot"))
                object.labelHot = message.labelHot;
            if (message.labelContent != null && message.hasOwnProperty("labelContent"))
                object.labelContent = message.labelContent;
            if (message.labelId != null && message.hasOwnProperty("labelId"))
                object.labelId = message.labelId;
            return object;
        };

        /**
         * Converts this LabelInfo to JSON.
         * @function toJSON
         * @memberof tieba.LabelInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LabelInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LabelInfo
         * @function getTypeUrl
         * @memberof tieba.LabelInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LabelInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.LabelInfo";
        };

        return LabelInfo;
    })();

    tieba.LiveCoverStatus = (function() {

        /**
         * Properties of a LiveCoverStatus.
         * @memberof tieba
         * @interface ILiveCoverStatus
         * @property {number|null} [statusNum] LiveCoverStatus statusNum
         * @property {string|null} [status] LiveCoverStatus status
         */

        /**
         * Constructs a new LiveCoverStatus.
         * @memberof tieba
         * @classdesc Represents a LiveCoverStatus.
         * @implements ILiveCoverStatus
         * @constructor
         * @param {tieba.ILiveCoverStatus=} [properties] Properties to set
         */
        function LiveCoverStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveCoverStatus statusNum.
         * @member {number} statusNum
         * @memberof tieba.LiveCoverStatus
         * @instance
         */
        LiveCoverStatus.prototype.statusNum = 0;

        /**
         * LiveCoverStatus status.
         * @member {string} status
         * @memberof tieba.LiveCoverStatus
         * @instance
         */
        LiveCoverStatus.prototype.status = "";

        /**
         * Creates a new LiveCoverStatus instance using the specified properties.
         * @function create
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {tieba.ILiveCoverStatus=} [properties] Properties to set
         * @returns {tieba.LiveCoverStatus} LiveCoverStatus instance
         */
        LiveCoverStatus.create = function create(properties) {
            return new LiveCoverStatus(properties);
        };

        /**
         * Encodes the specified LiveCoverStatus message. Does not implicitly {@link tieba.LiveCoverStatus.verify|verify} messages.
         * @function encode
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {tieba.ILiveCoverStatus} message LiveCoverStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LiveCoverStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.statusNum != null && Object.hasOwnProperty.call(message, "statusNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.statusNum);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.status);
            return writer;
        };

        /**
         * Encodes the specified LiveCoverStatus message, length delimited. Does not implicitly {@link tieba.LiveCoverStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {tieba.ILiveCoverStatus} message LiveCoverStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LiveCoverStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LiveCoverStatus message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.LiveCoverStatus} LiveCoverStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveCoverStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.LiveCoverStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.statusNum = reader.int32();
                        break;
                    }
                case 2: {
                        message.status = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveCoverStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.LiveCoverStatus} LiveCoverStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveCoverStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LiveCoverStatus message.
         * @function verify
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LiveCoverStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.statusNum != null && message.hasOwnProperty("statusNum"))
                if (!$util.isInteger(message.statusNum))
                    return "statusNum: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            return null;
        };

        /**
         * Creates a LiveCoverStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.LiveCoverStatus} LiveCoverStatus
         */
        LiveCoverStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.LiveCoverStatus)
                return object;
            let message = new $root.tieba.LiveCoverStatus();
            if (object.statusNum != null)
                message.statusNum = object.statusNum | 0;
            if (object.status != null)
                message.status = String(object.status);
            return message;
        };

        /**
         * Creates a plain object from a LiveCoverStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {tieba.LiveCoverStatus} message LiveCoverStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LiveCoverStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.statusNum = 0;
                object.status = "";
            }
            if (message.statusNum != null && message.hasOwnProperty("statusNum"))
                object.statusNum = message.statusNum;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this LiveCoverStatus to JSON.
         * @function toJSON
         * @memberof tieba.LiveCoverStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LiveCoverStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LiveCoverStatus
         * @function getTypeUrl
         * @memberof tieba.LiveCoverStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LiveCoverStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.LiveCoverStatus";
        };

        return LiveCoverStatus;
    })();

    tieba.NoticeInfo = (function() {

        /**
         * Properties of a NoticeInfo.
         * @memberof tieba
         * @interface INoticeInfo
         * @property {string|null} [notice] NoticeInfo notice
         * @property {number|null} [pullCommentFrequence] NoticeInfo pullCommentFrequence
         */

        /**
         * Constructs a new NoticeInfo.
         * @memberof tieba
         * @classdesc Represents a NoticeInfo.
         * @implements INoticeInfo
         * @constructor
         * @param {tieba.INoticeInfo=} [properties] Properties to set
         */
        function NoticeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoticeInfo notice.
         * @member {string} notice
         * @memberof tieba.NoticeInfo
         * @instance
         */
        NoticeInfo.prototype.notice = "";

        /**
         * NoticeInfo pullCommentFrequence.
         * @member {number} pullCommentFrequence
         * @memberof tieba.NoticeInfo
         * @instance
         */
        NoticeInfo.prototype.pullCommentFrequence = 0;

        /**
         * Creates a new NoticeInfo instance using the specified properties.
         * @function create
         * @memberof tieba.NoticeInfo
         * @static
         * @param {tieba.INoticeInfo=} [properties] Properties to set
         * @returns {tieba.NoticeInfo} NoticeInfo instance
         */
        NoticeInfo.create = function create(properties) {
            return new NoticeInfo(properties);
        };

        /**
         * Encodes the specified NoticeInfo message. Does not implicitly {@link tieba.NoticeInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.NoticeInfo
         * @static
         * @param {tieba.INoticeInfo} message NoticeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.notice != null && Object.hasOwnProperty.call(message, "notice"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.notice);
            if (message.pullCommentFrequence != null && Object.hasOwnProperty.call(message, "pullCommentFrequence"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pullCommentFrequence);
            return writer;
        };

        /**
         * Encodes the specified NoticeInfo message, length delimited. Does not implicitly {@link tieba.NoticeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.NoticeInfo
         * @static
         * @param {tieba.INoticeInfo} message NoticeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoticeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.NoticeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.NoticeInfo} NoticeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.NoticeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.notice = reader.string();
                        break;
                    }
                case 2: {
                        message.pullCommentFrequence = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoticeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.NoticeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.NoticeInfo} NoticeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoticeInfo message.
         * @function verify
         * @memberof tieba.NoticeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoticeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.notice != null && message.hasOwnProperty("notice"))
                if (!$util.isString(message.notice))
                    return "notice: string expected";
            if (message.pullCommentFrequence != null && message.hasOwnProperty("pullCommentFrequence"))
                if (!$util.isInteger(message.pullCommentFrequence))
                    return "pullCommentFrequence: integer expected";
            return null;
        };

        /**
         * Creates a NoticeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.NoticeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.NoticeInfo} NoticeInfo
         */
        NoticeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.NoticeInfo)
                return object;
            let message = new $root.tieba.NoticeInfo();
            if (object.notice != null)
                message.notice = String(object.notice);
            if (object.pullCommentFrequence != null)
                message.pullCommentFrequence = object.pullCommentFrequence | 0;
            return message;
        };

        /**
         * Creates a plain object from a NoticeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.NoticeInfo
         * @static
         * @param {tieba.NoticeInfo} message NoticeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoticeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.notice = "";
                object.pullCommentFrequence = 0;
            }
            if (message.notice != null && message.hasOwnProperty("notice"))
                object.notice = message.notice;
            if (message.pullCommentFrequence != null && message.hasOwnProperty("pullCommentFrequence"))
                object.pullCommentFrequence = message.pullCommentFrequence;
            return object;
        };

        /**
         * Converts this NoticeInfo to JSON.
         * @function toJSON
         * @memberof tieba.NoticeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoticeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NoticeInfo
         * @function getTypeUrl
         * @memberof tieba.NoticeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NoticeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.NoticeInfo";
        };

        return NoticeInfo;
    })();

    tieba.Zan = (function() {

        /**
         * Properties of a Zan.
         * @memberof tieba
         * @interface IZan
         * @property {number|null} [num] Zan num
         * @property {Array.<tieba.IUser>|null} [likerList] Zan likerList
         * @property {number|null} [isLiked] Zan isLiked
         * @property {number|null} [lastTime] Zan lastTime
         * @property {Array.<number|Long>|null} [likerId] Zan likerId
         * @property {number|null} [consentType] Zan consentType
         */

        /**
         * Constructs a new Zan.
         * @memberof tieba
         * @classdesc Represents a Zan.
         * @implements IZan
         * @constructor
         * @param {tieba.IZan=} [properties] Properties to set
         */
        function Zan(properties) {
            this.likerList = [];
            this.likerId = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Zan num.
         * @member {number} num
         * @memberof tieba.Zan
         * @instance
         */
        Zan.prototype.num = 0;

        /**
         * Zan likerList.
         * @member {Array.<tieba.IUser>} likerList
         * @memberof tieba.Zan
         * @instance
         */
        Zan.prototype.likerList = $util.emptyArray;

        /**
         * Zan isLiked.
         * @member {number} isLiked
         * @memberof tieba.Zan
         * @instance
         */
        Zan.prototype.isLiked = 0;

        /**
         * Zan lastTime.
         * @member {number} lastTime
         * @memberof tieba.Zan
         * @instance
         */
        Zan.prototype.lastTime = 0;

        /**
         * Zan likerId.
         * @member {Array.<number|Long>} likerId
         * @memberof tieba.Zan
         * @instance
         */
        Zan.prototype.likerId = $util.emptyArray;

        /**
         * Zan consentType.
         * @member {number} consentType
         * @memberof tieba.Zan
         * @instance
         */
        Zan.prototype.consentType = 0;

        /**
         * Creates a new Zan instance using the specified properties.
         * @function create
         * @memberof tieba.Zan
         * @static
         * @param {tieba.IZan=} [properties] Properties to set
         * @returns {tieba.Zan} Zan instance
         */
        Zan.create = function create(properties) {
            return new Zan(properties);
        };

        /**
         * Encodes the specified Zan message. Does not implicitly {@link tieba.Zan.verify|verify} messages.
         * @function encode
         * @memberof tieba.Zan
         * @static
         * @param {tieba.IZan} message Zan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Zan.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
            if (message.likerList != null && message.likerList.length)
                for (let i = 0; i < message.likerList.length; ++i)
                    $root.tieba.User.encode(message.likerList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.isLiked != null && Object.hasOwnProperty.call(message, "isLiked"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isLiked);
            if (message.lastTime != null && Object.hasOwnProperty.call(message, "lastTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lastTime);
            if (message.likerId != null && message.likerId.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.likerId.length; ++i)
                    writer.int64(message.likerId[i]);
                writer.ldelim();
            }
            if (message.consentType != null && Object.hasOwnProperty.call(message, "consentType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.consentType);
            return writer;
        };

        /**
         * Encodes the specified Zan message, length delimited. Does not implicitly {@link tieba.Zan.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Zan
         * @static
         * @param {tieba.IZan} message Zan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Zan.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Zan message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Zan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Zan} Zan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Zan.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Zan();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.num = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.likerList && message.likerList.length))
                            message.likerList = [];
                        message.likerList.push($root.tieba.User.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.isLiked = reader.int32();
                        break;
                    }
                case 4: {
                        message.lastTime = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.likerId && message.likerId.length))
                            message.likerId = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.likerId.push(reader.int64());
                        } else
                            message.likerId.push(reader.int64());
                        break;
                    }
                case 6: {
                        message.consentType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Zan message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Zan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Zan} Zan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Zan.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Zan message.
         * @function verify
         * @memberof tieba.Zan
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Zan.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.likerList != null && message.hasOwnProperty("likerList")) {
                if (!Array.isArray(message.likerList))
                    return "likerList: array expected";
                for (let i = 0; i < message.likerList.length; ++i) {
                    let error = $root.tieba.User.verify(message.likerList[i]);
                    if (error)
                        return "likerList." + error;
                }
            }
            if (message.isLiked != null && message.hasOwnProperty("isLiked"))
                if (!$util.isInteger(message.isLiked))
                    return "isLiked: integer expected";
            if (message.lastTime != null && message.hasOwnProperty("lastTime"))
                if (!$util.isInteger(message.lastTime))
                    return "lastTime: integer expected";
            if (message.likerId != null && message.hasOwnProperty("likerId")) {
                if (!Array.isArray(message.likerId))
                    return "likerId: array expected";
                for (let i = 0; i < message.likerId.length; ++i)
                    if (!$util.isInteger(message.likerId[i]) && !(message.likerId[i] && $util.isInteger(message.likerId[i].low) && $util.isInteger(message.likerId[i].high)))
                        return "likerId: integer|Long[] expected";
            }
            if (message.consentType != null && message.hasOwnProperty("consentType"))
                if (!$util.isInteger(message.consentType))
                    return "consentType: integer expected";
            return null;
        };

        /**
         * Creates a Zan message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Zan
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Zan} Zan
         */
        Zan.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Zan)
                return object;
            let message = new $root.tieba.Zan();
            if (object.num != null)
                message.num = object.num | 0;
            if (object.likerList) {
                if (!Array.isArray(object.likerList))
                    throw TypeError(".tieba.Zan.likerList: array expected");
                message.likerList = [];
                for (let i = 0; i < object.likerList.length; ++i) {
                    if (typeof object.likerList[i] !== "object")
                        throw TypeError(".tieba.Zan.likerList: object expected");
                    message.likerList[i] = $root.tieba.User.fromObject(object.likerList[i]);
                }
            }
            if (object.isLiked != null)
                message.isLiked = object.isLiked | 0;
            if (object.lastTime != null)
                message.lastTime = object.lastTime | 0;
            if (object.likerId) {
                if (!Array.isArray(object.likerId))
                    throw TypeError(".tieba.Zan.likerId: array expected");
                message.likerId = [];
                for (let i = 0; i < object.likerId.length; ++i)
                    if ($util.Long)
                        (message.likerId[i] = $util.Long.fromValue(object.likerId[i])).unsigned = false;
                    else if (typeof object.likerId[i] === "string")
                        message.likerId[i] = parseInt(object.likerId[i], 10);
                    else if (typeof object.likerId[i] === "number")
                        message.likerId[i] = object.likerId[i];
                    else if (typeof object.likerId[i] === "object")
                        message.likerId[i] = new $util.LongBits(object.likerId[i].low >>> 0, object.likerId[i].high >>> 0).toNumber();
            }
            if (object.consentType != null)
                message.consentType = object.consentType | 0;
            return message;
        };

        /**
         * Creates a plain object from a Zan message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Zan
         * @static
         * @param {tieba.Zan} message Zan
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Zan.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.likerList = [];
                object.likerId = [];
            }
            if (options.defaults) {
                object.num = 0;
                object.isLiked = 0;
                object.lastTime = 0;
                object.consentType = 0;
            }
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.likerList && message.likerList.length) {
                object.likerList = [];
                for (let j = 0; j < message.likerList.length; ++j)
                    object.likerList[j] = $root.tieba.User.toObject(message.likerList[j], options);
            }
            if (message.isLiked != null && message.hasOwnProperty("isLiked"))
                object.isLiked = message.isLiked;
            if (message.lastTime != null && message.hasOwnProperty("lastTime"))
                object.lastTime = message.lastTime;
            if (message.likerId && message.likerId.length) {
                object.likerId = [];
                for (let j = 0; j < message.likerId.length; ++j)
                    if (typeof message.likerId[j] === "number")
                        object.likerId[j] = options.longs === String ? String(message.likerId[j]) : message.likerId[j];
                    else
                        object.likerId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.likerId[j]) : options.longs === Number ? new $util.LongBits(message.likerId[j].low >>> 0, message.likerId[j].high >>> 0).toNumber() : message.likerId[j];
            }
            if (message.consentType != null && message.hasOwnProperty("consentType"))
                object.consentType = message.consentType;
            return object;
        };

        /**
         * Converts this Zan to JSON.
         * @function toJSON
         * @memberof tieba.Zan
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Zan.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Zan
         * @function getTypeUrl
         * @memberof tieba.Zan
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Zan.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Zan";
        };

        return Zan;
    })();

    tieba.PostInfoContent = (function() {

        /**
         * Properties of a PostInfoContent.
         * @memberof tieba
         * @interface IPostInfoContent
         * @property {Array.<tieba.IAbstract>|null} [postContent] PostInfoContent postContent
         * @property {number|Long|null} [createTime] PostInfoContent createTime
         * @property {number|Long|null} [postType] PostInfoContent postType
         * @property {number|Long|null} [postId] PostInfoContent postId
         * @property {number|null} [isAuthorView] PostInfoContent isAuthorView
         * @property {string|null} [targetScheme] PostInfoContent targetScheme
         */

        /**
         * Constructs a new PostInfoContent.
         * @memberof tieba
         * @classdesc Represents a PostInfoContent.
         * @implements IPostInfoContent
         * @constructor
         * @param {tieba.IPostInfoContent=} [properties] Properties to set
         */
        function PostInfoContent(properties) {
            this.postContent = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostInfoContent postContent.
         * @member {Array.<tieba.IAbstract>} postContent
         * @memberof tieba.PostInfoContent
         * @instance
         */
        PostInfoContent.prototype.postContent = $util.emptyArray;

        /**
         * PostInfoContent createTime.
         * @member {number|Long} createTime
         * @memberof tieba.PostInfoContent
         * @instance
         */
        PostInfoContent.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoContent postType.
         * @member {number|Long} postType
         * @memberof tieba.PostInfoContent
         * @instance
         */
        PostInfoContent.prototype.postType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoContent postId.
         * @member {number|Long} postId
         * @memberof tieba.PostInfoContent
         * @instance
         */
        PostInfoContent.prototype.postId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PostInfoContent isAuthorView.
         * @member {number} isAuthorView
         * @memberof tieba.PostInfoContent
         * @instance
         */
        PostInfoContent.prototype.isAuthorView = 0;

        /**
         * PostInfoContent targetScheme.
         * @member {string} targetScheme
         * @memberof tieba.PostInfoContent
         * @instance
         */
        PostInfoContent.prototype.targetScheme = "";

        /**
         * Creates a new PostInfoContent instance using the specified properties.
         * @function create
         * @memberof tieba.PostInfoContent
         * @static
         * @param {tieba.IPostInfoContent=} [properties] Properties to set
         * @returns {tieba.PostInfoContent} PostInfoContent instance
         */
        PostInfoContent.create = function create(properties) {
            return new PostInfoContent(properties);
        };

        /**
         * Encodes the specified PostInfoContent message. Does not implicitly {@link tieba.PostInfoContent.verify|verify} messages.
         * @function encode
         * @memberof tieba.PostInfoContent
         * @static
         * @param {tieba.IPostInfoContent} message PostInfoContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostInfoContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.postContent != null && message.postContent.length)
                for (let i = 0; i < message.postContent.length; ++i)
                    $root.tieba.Abstract.encode(message.postContent[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.createTime);
            if (message.postType != null && Object.hasOwnProperty.call(message, "postType"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.postType);
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.postId);
            if (message.isAuthorView != null && Object.hasOwnProperty.call(message, "isAuthorView"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.isAuthorView);
            if (message.targetScheme != null && Object.hasOwnProperty.call(message, "targetScheme"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.targetScheme);
            return writer;
        };

        /**
         * Encodes the specified PostInfoContent message, length delimited. Does not implicitly {@link tieba.PostInfoContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.PostInfoContent
         * @static
         * @param {tieba.IPostInfoContent} message PostInfoContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostInfoContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostInfoContent message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.PostInfoContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.PostInfoContent} PostInfoContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostInfoContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.PostInfoContent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.postContent && message.postContent.length))
                            message.postContent = [];
                        message.postContent.push($root.tieba.Abstract.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.createTime = reader.uint64();
                        break;
                    }
                case 3: {
                        message.postType = reader.uint64();
                        break;
                    }
                case 4: {
                        message.postId = reader.uint64();
                        break;
                    }
                case 5: {
                        message.isAuthorView = reader.int32();
                        break;
                    }
                case 7: {
                        message.targetScheme = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostInfoContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.PostInfoContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.PostInfoContent} PostInfoContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostInfoContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostInfoContent message.
         * @function verify
         * @memberof tieba.PostInfoContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostInfoContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.postContent != null && message.hasOwnProperty("postContent")) {
                if (!Array.isArray(message.postContent))
                    return "postContent: array expected";
                for (let i = 0; i < message.postContent.length; ++i) {
                    let error = $root.tieba.Abstract.verify(message.postContent[i]);
                    if (error)
                        return "postContent." + error;
                }
            }
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.postType != null && message.hasOwnProperty("postType"))
                if (!$util.isInteger(message.postType) && !(message.postType && $util.isInteger(message.postType.low) && $util.isInteger(message.postType.high)))
                    return "postType: integer|Long expected";
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isInteger(message.postId) && !(message.postId && $util.isInteger(message.postId.low) && $util.isInteger(message.postId.high)))
                    return "postId: integer|Long expected";
            if (message.isAuthorView != null && message.hasOwnProperty("isAuthorView"))
                if (!$util.isInteger(message.isAuthorView))
                    return "isAuthorView: integer expected";
            if (message.targetScheme != null && message.hasOwnProperty("targetScheme"))
                if (!$util.isString(message.targetScheme))
                    return "targetScheme: string expected";
            return null;
        };

        /**
         * Creates a PostInfoContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.PostInfoContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.PostInfoContent} PostInfoContent
         */
        PostInfoContent.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.PostInfoContent)
                return object;
            let message = new $root.tieba.PostInfoContent();
            if (object.postContent) {
                if (!Array.isArray(object.postContent))
                    throw TypeError(".tieba.PostInfoContent.postContent: array expected");
                message.postContent = [];
                for (let i = 0; i < object.postContent.length; ++i) {
                    if (typeof object.postContent[i] !== "object")
                        throw TypeError(".tieba.PostInfoContent.postContent: object expected");
                    message.postContent[i] = $root.tieba.Abstract.fromObject(object.postContent[i]);
                }
            }
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = true;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber(true);
            if (object.postType != null)
                if ($util.Long)
                    (message.postType = $util.Long.fromValue(object.postType)).unsigned = true;
                else if (typeof object.postType === "string")
                    message.postType = parseInt(object.postType, 10);
                else if (typeof object.postType === "number")
                    message.postType = object.postType;
                else if (typeof object.postType === "object")
                    message.postType = new $util.LongBits(object.postType.low >>> 0, object.postType.high >>> 0).toNumber(true);
            if (object.postId != null)
                if ($util.Long)
                    (message.postId = $util.Long.fromValue(object.postId)).unsigned = true;
                else if (typeof object.postId === "string")
                    message.postId = parseInt(object.postId, 10);
                else if (typeof object.postId === "number")
                    message.postId = object.postId;
                else if (typeof object.postId === "object")
                    message.postId = new $util.LongBits(object.postId.low >>> 0, object.postId.high >>> 0).toNumber(true);
            if (object.isAuthorView != null)
                message.isAuthorView = object.isAuthorView | 0;
            if (object.targetScheme != null)
                message.targetScheme = String(object.targetScheme);
            return message;
        };

        /**
         * Creates a plain object from a PostInfoContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.PostInfoContent
         * @static
         * @param {tieba.PostInfoContent} message PostInfoContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostInfoContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.postContent = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.postType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.postType = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.postId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.postId = options.longs === String ? "0" : 0;
                object.isAuthorView = 0;
                object.targetScheme = "";
            }
            if (message.postContent && message.postContent.length) {
                object.postContent = [];
                for (let j = 0; j < message.postContent.length; ++j)
                    object.postContent[j] = $root.tieba.Abstract.toObject(message.postContent[j], options);
            }
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber(true) : message.createTime;
            if (message.postType != null && message.hasOwnProperty("postType"))
                if (typeof message.postType === "number")
                    object.postType = options.longs === String ? String(message.postType) : message.postType;
                else
                    object.postType = options.longs === String ? $util.Long.prototype.toString.call(message.postType) : options.longs === Number ? new $util.LongBits(message.postType.low >>> 0, message.postType.high >>> 0).toNumber(true) : message.postType;
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (typeof message.postId === "number")
                    object.postId = options.longs === String ? String(message.postId) : message.postId;
                else
                    object.postId = options.longs === String ? $util.Long.prototype.toString.call(message.postId) : options.longs === Number ? new $util.LongBits(message.postId.low >>> 0, message.postId.high >>> 0).toNumber(true) : message.postId;
            if (message.isAuthorView != null && message.hasOwnProperty("isAuthorView"))
                object.isAuthorView = message.isAuthorView;
            if (message.targetScheme != null && message.hasOwnProperty("targetScheme"))
                object.targetScheme = message.targetScheme;
            return object;
        };

        /**
         * Converts this PostInfoContent to JSON.
         * @function toJSON
         * @memberof tieba.PostInfoContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostInfoContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PostInfoContent
         * @function getTypeUrl
         * @memberof tieba.PostInfoContent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PostInfoContent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.PostInfoContent";
        };

        return PostInfoContent;
    })();

    tieba.Abstract = (function() {

        /**
         * Properties of an Abstract.
         * @memberof tieba
         * @interface IAbstract
         * @property {number|null} [type] Abstract type
         * @property {string|null} [text] Abstract text
         * @property {string|null} [link] Abstract link
         * @property {string|null} [src] Abstract src
         * @property {string|null} [un] Abstract un
         * @property {string|null} [duringTime] Abstract duringTime
         * @property {string|null} [voiceMD5] Abstract voiceMD5
         */

        /**
         * Constructs a new Abstract.
         * @memberof tieba
         * @classdesc Represents an Abstract.
         * @implements IAbstract
         * @constructor
         * @param {tieba.IAbstract=} [properties] Properties to set
         */
        function Abstract(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Abstract type.
         * @member {number} type
         * @memberof tieba.Abstract
         * @instance
         */
        Abstract.prototype.type = 0;

        /**
         * Abstract text.
         * @member {string} text
         * @memberof tieba.Abstract
         * @instance
         */
        Abstract.prototype.text = "";

        /**
         * Abstract link.
         * @member {string} link
         * @memberof tieba.Abstract
         * @instance
         */
        Abstract.prototype.link = "";

        /**
         * Abstract src.
         * @member {string} src
         * @memberof tieba.Abstract
         * @instance
         */
        Abstract.prototype.src = "";

        /**
         * Abstract un.
         * @member {string} un
         * @memberof tieba.Abstract
         * @instance
         */
        Abstract.prototype.un = "";

        /**
         * Abstract duringTime.
         * @member {string} duringTime
         * @memberof tieba.Abstract
         * @instance
         */
        Abstract.prototype.duringTime = "";

        /**
         * Abstract voiceMD5.
         * @member {string} voiceMD5
         * @memberof tieba.Abstract
         * @instance
         */
        Abstract.prototype.voiceMD5 = "";

        /**
         * Creates a new Abstract instance using the specified properties.
         * @function create
         * @memberof tieba.Abstract
         * @static
         * @param {tieba.IAbstract=} [properties] Properties to set
         * @returns {tieba.Abstract} Abstract instance
         */
        Abstract.create = function create(properties) {
            return new Abstract(properties);
        };

        /**
         * Encodes the specified Abstract message. Does not implicitly {@link tieba.Abstract.verify|verify} messages.
         * @function encode
         * @memberof tieba.Abstract
         * @static
         * @param {tieba.IAbstract} message Abstract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Abstract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.link != null && Object.hasOwnProperty.call(message, "link"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.link);
            if (message.src != null && Object.hasOwnProperty.call(message, "src"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.src);
            if (message.un != null && Object.hasOwnProperty.call(message, "un"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.un);
            if (message.duringTime != null && Object.hasOwnProperty.call(message, "duringTime"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.duringTime);
            if (message.voiceMD5 != null && Object.hasOwnProperty.call(message, "voiceMD5"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.voiceMD5);
            return writer;
        };

        /**
         * Encodes the specified Abstract message, length delimited. Does not implicitly {@link tieba.Abstract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Abstract
         * @static
         * @param {tieba.IAbstract} message Abstract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Abstract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Abstract message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Abstract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Abstract} Abstract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Abstract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Abstract();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.text = reader.string();
                        break;
                    }
                case 3: {
                        message.link = reader.string();
                        break;
                    }
                case 4: {
                        message.src = reader.string();
                        break;
                    }
                case 5: {
                        message.un = reader.string();
                        break;
                    }
                case 6: {
                        message.duringTime = reader.string();
                        break;
                    }
                case 7: {
                        message.voiceMD5 = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Abstract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Abstract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Abstract} Abstract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Abstract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Abstract message.
         * @function verify
         * @memberof tieba.Abstract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Abstract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.link != null && message.hasOwnProperty("link"))
                if (!$util.isString(message.link))
                    return "link: string expected";
            if (message.src != null && message.hasOwnProperty("src"))
                if (!$util.isString(message.src))
                    return "src: string expected";
            if (message.un != null && message.hasOwnProperty("un"))
                if (!$util.isString(message.un))
                    return "un: string expected";
            if (message.duringTime != null && message.hasOwnProperty("duringTime"))
                if (!$util.isString(message.duringTime))
                    return "duringTime: string expected";
            if (message.voiceMD5 != null && message.hasOwnProperty("voiceMD5"))
                if (!$util.isString(message.voiceMD5))
                    return "voiceMD5: string expected";
            return null;
        };

        /**
         * Creates an Abstract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Abstract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Abstract} Abstract
         */
        Abstract.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Abstract)
                return object;
            let message = new $root.tieba.Abstract();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.link != null)
                message.link = String(object.link);
            if (object.src != null)
                message.src = String(object.src);
            if (object.un != null)
                message.un = String(object.un);
            if (object.duringTime != null)
                message.duringTime = String(object.duringTime);
            if (object.voiceMD5 != null)
                message.voiceMD5 = String(object.voiceMD5);
            return message;
        };

        /**
         * Creates a plain object from an Abstract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Abstract
         * @static
         * @param {tieba.Abstract} message Abstract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Abstract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = 0;
                object.text = "";
                object.link = "";
                object.src = "";
                object.un = "";
                object.duringTime = "";
                object.voiceMD5 = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.link != null && message.hasOwnProperty("link"))
                object.link = message.link;
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = message.src;
            if (message.un != null && message.hasOwnProperty("un"))
                object.un = message.un;
            if (message.duringTime != null && message.hasOwnProperty("duringTime"))
                object.duringTime = message.duringTime;
            if (message.voiceMD5 != null && message.hasOwnProperty("voiceMD5"))
                object.voiceMD5 = message.voiceMD5;
            return object;
        };

        /**
         * Converts this Abstract to JSON.
         * @function toJSON
         * @memberof tieba.Abstract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Abstract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Abstract
         * @function getTypeUrl
         * @memberof tieba.Abstract
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Abstract.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Abstract";
        };

        return Abstract;
    })();

    tieba.PbContent = (function() {

        /**
         * Properties of a PbContent.
         * @memberof tieba
         * @interface IPbContent
         * @property {number|null} [type] PbContent type
         * @property {string|null} [text] PbContent text
         * @property {string|null} [link] PbContent link
         * @property {string|null} [src] PbContent src
         * @property {string|null} [bsize] PbContent bsize
         * @property {string|null} [bigSrc] PbContent bigSrc
         * @property {string|null} [bigSize] PbContent bigSize
         * @property {string|null} [cdnSrc] PbContent cdnSrc
         * @property {string|null} [bigCdnSrc] PbContent bigCdnSrc
         * @property {string|null} [imgType] PbContent imgType
         * @property {string|null} [c] PbContent c
         * @property {string|null} [voiceMD5] PbContent voiceMD5
         * @property {number|null} [duringTime] PbContent duringTime
         * @property {number|Long|null} [uid] PbContent uid
         * @property {string|null} [dynamic] PbContent dynamic
         * @property {string|null} [_static] PbContent _static
         * @property {number|null} [width] PbContent width
         * @property {number|null} [height] PbContent height
         * @property {string|null} [originSrc] PbContent originSrc
         * @property {number|null} [originSize] PbContent originSize
         * @property {string|null} [mediaSubtitle] PbContent mediaSubtitle
         * @property {number|null} [urlType] PbContent urlType
         * @property {tieba.IMemeInfo|null} [memeInfo] PbContent memeInfo
         * @property {number|null} [isLongPic] PbContent isLongPic
         * @property {number|null} [showOriginalBtn] PbContent showOriginalBtn
         * @property {string|null} [cdnSrcActive] PbContent cdnSrcActive
         */

        /**
         * Constructs a new PbContent.
         * @memberof tieba
         * @classdesc Represents a PbContent.
         * @implements IPbContent
         * @constructor
         * @param {tieba.IPbContent=} [properties] Properties to set
         */
        function PbContent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbContent type.
         * @member {number} type
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.type = 0;

        /**
         * PbContent text.
         * @member {string} text
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.text = "";

        /**
         * PbContent link.
         * @member {string} link
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.link = "";

        /**
         * PbContent src.
         * @member {string} src
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.src = "";

        /**
         * PbContent bsize.
         * @member {string} bsize
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.bsize = "";

        /**
         * PbContent bigSrc.
         * @member {string} bigSrc
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.bigSrc = "";

        /**
         * PbContent bigSize.
         * @member {string} bigSize
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.bigSize = "";

        /**
         * PbContent cdnSrc.
         * @member {string} cdnSrc
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.cdnSrc = "";

        /**
         * PbContent bigCdnSrc.
         * @member {string} bigCdnSrc
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.bigCdnSrc = "";

        /**
         * PbContent imgType.
         * @member {string} imgType
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.imgType = "";

        /**
         * PbContent c.
         * @member {string} c
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.c = "";

        /**
         * PbContent voiceMD5.
         * @member {string} voiceMD5
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.voiceMD5 = "";

        /**
         * PbContent duringTime.
         * @member {number} duringTime
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.duringTime = 0;

        /**
         * PbContent uid.
         * @member {number|Long} uid
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PbContent dynamic.
         * @member {string} dynamic
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.dynamic = "";

        /**
         * PbContent _static.
         * @member {string} _static
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype._static = "";

        /**
         * PbContent width.
         * @member {number} width
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.width = 0;

        /**
         * PbContent height.
         * @member {number} height
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.height = 0;

        /**
         * PbContent originSrc.
         * @member {string} originSrc
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.originSrc = "";

        /**
         * PbContent originSize.
         * @member {number} originSize
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.originSize = 0;

        /**
         * PbContent mediaSubtitle.
         * @member {string} mediaSubtitle
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.mediaSubtitle = "";

        /**
         * PbContent urlType.
         * @member {number} urlType
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.urlType = 0;

        /**
         * PbContent memeInfo.
         * @member {tieba.IMemeInfo|null|undefined} memeInfo
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.memeInfo = null;

        /**
         * PbContent isLongPic.
         * @member {number} isLongPic
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.isLongPic = 0;

        /**
         * PbContent showOriginalBtn.
         * @member {number} showOriginalBtn
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.showOriginalBtn = 0;

        /**
         * PbContent cdnSrcActive.
         * @member {string} cdnSrcActive
         * @memberof tieba.PbContent
         * @instance
         */
        PbContent.prototype.cdnSrcActive = "";

        /**
         * Creates a new PbContent instance using the specified properties.
         * @function create
         * @memberof tieba.PbContent
         * @static
         * @param {tieba.IPbContent=} [properties] Properties to set
         * @returns {tieba.PbContent} PbContent instance
         */
        PbContent.create = function create(properties) {
            return new PbContent(properties);
        };

        /**
         * Encodes the specified PbContent message. Does not implicitly {@link tieba.PbContent.verify|verify} messages.
         * @function encode
         * @memberof tieba.PbContent
         * @static
         * @param {tieba.IPbContent} message PbContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.link != null && Object.hasOwnProperty.call(message, "link"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.link);
            if (message.src != null && Object.hasOwnProperty.call(message, "src"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.src);
            if (message.bsize != null && Object.hasOwnProperty.call(message, "bsize"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.bsize);
            if (message.bigSrc != null && Object.hasOwnProperty.call(message, "bigSrc"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.bigSrc);
            if (message.bigSize != null && Object.hasOwnProperty.call(message, "bigSize"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.bigSize);
            if (message.cdnSrc != null && Object.hasOwnProperty.call(message, "cdnSrc"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.cdnSrc);
            if (message.bigCdnSrc != null && Object.hasOwnProperty.call(message, "bigCdnSrc"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.bigCdnSrc);
            if (message.imgType != null && Object.hasOwnProperty.call(message, "imgType"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.imgType);
            if (message.c != null && Object.hasOwnProperty.call(message, "c"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.c);
            if (message.voiceMD5 != null && Object.hasOwnProperty.call(message, "voiceMD5"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.voiceMD5);
            if (message.duringTime != null && Object.hasOwnProperty.call(message, "duringTime"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.duringTime);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.uid);
            if (message.dynamic != null && Object.hasOwnProperty.call(message, "dynamic"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.dynamic);
            if (message._static != null && Object.hasOwnProperty.call(message, "_static"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message._static);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.height);
            if (message.originSrc != null && Object.hasOwnProperty.call(message, "originSrc"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.originSrc);
            if (message.originSize != null && Object.hasOwnProperty.call(message, "originSize"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.originSize);
            if (message.mediaSubtitle != null && Object.hasOwnProperty.call(message, "mediaSubtitle"))
                writer.uint32(/* id 31, wireType 2 =*/250).string(message.mediaSubtitle);
            if (message.urlType != null && Object.hasOwnProperty.call(message, "urlType"))
                writer.uint32(/* id 32, wireType 0 =*/256).int32(message.urlType);
            if (message.memeInfo != null && Object.hasOwnProperty.call(message, "memeInfo"))
                $root.tieba.MemeInfo.encode(message.memeInfo, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.isLongPic != null && Object.hasOwnProperty.call(message, "isLongPic"))
                writer.uint32(/* id 34, wireType 0 =*/272).uint32(message.isLongPic);
            if (message.showOriginalBtn != null && Object.hasOwnProperty.call(message, "showOriginalBtn"))
                writer.uint32(/* id 35, wireType 0 =*/280).uint32(message.showOriginalBtn);
            if (message.cdnSrcActive != null && Object.hasOwnProperty.call(message, "cdnSrcActive"))
                writer.uint32(/* id 36, wireType 2 =*/290).string(message.cdnSrcActive);
            return writer;
        };

        /**
         * Encodes the specified PbContent message, length delimited. Does not implicitly {@link tieba.PbContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.PbContent
         * @static
         * @param {tieba.IPbContent} message PbContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbContent message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.PbContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.PbContent} PbContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.PbContent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.text = reader.string();
                        break;
                    }
                case 3: {
                        message.link = reader.string();
                        break;
                    }
                case 4: {
                        message.src = reader.string();
                        break;
                    }
                case 5: {
                        message.bsize = reader.string();
                        break;
                    }
                case 6: {
                        message.bigSrc = reader.string();
                        break;
                    }
                case 7: {
                        message.bigSize = reader.string();
                        break;
                    }
                case 8: {
                        message.cdnSrc = reader.string();
                        break;
                    }
                case 9: {
                        message.bigCdnSrc = reader.string();
                        break;
                    }
                case 10: {
                        message.imgType = reader.string();
                        break;
                    }
                case 11: {
                        message.c = reader.string();
                        break;
                    }
                case 12: {
                        message.voiceMD5 = reader.string();
                        break;
                    }
                case 13: {
                        message.duringTime = reader.uint32();
                        break;
                    }
                case 15: {
                        message.uid = reader.int64();
                        break;
                    }
                case 16: {
                        message.dynamic = reader.string();
                        break;
                    }
                case 17: {
                        message._static = reader.string();
                        break;
                    }
                case 18: {
                        message.width = reader.uint32();
                        break;
                    }
                case 19: {
                        message.height = reader.uint32();
                        break;
                    }
                case 25: {
                        message.originSrc = reader.string();
                        break;
                    }
                case 27: {
                        message.originSize = reader.uint32();
                        break;
                    }
                case 31: {
                        message.mediaSubtitle = reader.string();
                        break;
                    }
                case 32: {
                        message.urlType = reader.int32();
                        break;
                    }
                case 33: {
                        message.memeInfo = $root.tieba.MemeInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 34: {
                        message.isLongPic = reader.uint32();
                        break;
                    }
                case 35: {
                        message.showOriginalBtn = reader.uint32();
                        break;
                    }
                case 36: {
                        message.cdnSrcActive = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.PbContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.PbContent} PbContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbContent message.
         * @function verify
         * @memberof tieba.PbContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.link != null && message.hasOwnProperty("link"))
                if (!$util.isString(message.link))
                    return "link: string expected";
            if (message.src != null && message.hasOwnProperty("src"))
                if (!$util.isString(message.src))
                    return "src: string expected";
            if (message.bsize != null && message.hasOwnProperty("bsize"))
                if (!$util.isString(message.bsize))
                    return "bsize: string expected";
            if (message.bigSrc != null && message.hasOwnProperty("bigSrc"))
                if (!$util.isString(message.bigSrc))
                    return "bigSrc: string expected";
            if (message.bigSize != null && message.hasOwnProperty("bigSize"))
                if (!$util.isString(message.bigSize))
                    return "bigSize: string expected";
            if (message.cdnSrc != null && message.hasOwnProperty("cdnSrc"))
                if (!$util.isString(message.cdnSrc))
                    return "cdnSrc: string expected";
            if (message.bigCdnSrc != null && message.hasOwnProperty("bigCdnSrc"))
                if (!$util.isString(message.bigCdnSrc))
                    return "bigCdnSrc: string expected";
            if (message.imgType != null && message.hasOwnProperty("imgType"))
                if (!$util.isString(message.imgType))
                    return "imgType: string expected";
            if (message.c != null && message.hasOwnProperty("c"))
                if (!$util.isString(message.c))
                    return "c: string expected";
            if (message.voiceMD5 != null && message.hasOwnProperty("voiceMD5"))
                if (!$util.isString(message.voiceMD5))
                    return "voiceMD5: string expected";
            if (message.duringTime != null && message.hasOwnProperty("duringTime"))
                if (!$util.isInteger(message.duringTime))
                    return "duringTime: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.dynamic != null && message.hasOwnProperty("dynamic"))
                if (!$util.isString(message.dynamic))
                    return "dynamic: string expected";
            if (message._static != null && message.hasOwnProperty("_static"))
                if (!$util.isString(message._static))
                    return "_static: string expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.originSrc != null && message.hasOwnProperty("originSrc"))
                if (!$util.isString(message.originSrc))
                    return "originSrc: string expected";
            if (message.originSize != null && message.hasOwnProperty("originSize"))
                if (!$util.isInteger(message.originSize))
                    return "originSize: integer expected";
            if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
                if (!$util.isString(message.mediaSubtitle))
                    return "mediaSubtitle: string expected";
            if (message.urlType != null && message.hasOwnProperty("urlType"))
                if (!$util.isInteger(message.urlType))
                    return "urlType: integer expected";
            if (message.memeInfo != null && message.hasOwnProperty("memeInfo")) {
                let error = $root.tieba.MemeInfo.verify(message.memeInfo);
                if (error)
                    return "memeInfo." + error;
            }
            if (message.isLongPic != null && message.hasOwnProperty("isLongPic"))
                if (!$util.isInteger(message.isLongPic))
                    return "isLongPic: integer expected";
            if (message.showOriginalBtn != null && message.hasOwnProperty("showOriginalBtn"))
                if (!$util.isInteger(message.showOriginalBtn))
                    return "showOriginalBtn: integer expected";
            if (message.cdnSrcActive != null && message.hasOwnProperty("cdnSrcActive"))
                if (!$util.isString(message.cdnSrcActive))
                    return "cdnSrcActive: string expected";
            return null;
        };

        /**
         * Creates a PbContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.PbContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.PbContent} PbContent
         */
        PbContent.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.PbContent)
                return object;
            let message = new $root.tieba.PbContent();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.link != null)
                message.link = String(object.link);
            if (object.src != null)
                message.src = String(object.src);
            if (object.bsize != null)
                message.bsize = String(object.bsize);
            if (object.bigSrc != null)
                message.bigSrc = String(object.bigSrc);
            if (object.bigSize != null)
                message.bigSize = String(object.bigSize);
            if (object.cdnSrc != null)
                message.cdnSrc = String(object.cdnSrc);
            if (object.bigCdnSrc != null)
                message.bigCdnSrc = String(object.bigCdnSrc);
            if (object.imgType != null)
                message.imgType = String(object.imgType);
            if (object.c != null)
                message.c = String(object.c);
            if (object.voiceMD5 != null)
                message.voiceMD5 = String(object.voiceMD5);
            if (object.duringTime != null)
                message.duringTime = object.duringTime >>> 0;
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.dynamic != null)
                message.dynamic = String(object.dynamic);
            if (object._static != null)
                message._static = String(object._static);
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.originSrc != null)
                message.originSrc = String(object.originSrc);
            if (object.originSize != null)
                message.originSize = object.originSize >>> 0;
            if (object.mediaSubtitle != null)
                message.mediaSubtitle = String(object.mediaSubtitle);
            if (object.urlType != null)
                message.urlType = object.urlType | 0;
            if (object.memeInfo != null) {
                if (typeof object.memeInfo !== "object")
                    throw TypeError(".tieba.PbContent.memeInfo: object expected");
                message.memeInfo = $root.tieba.MemeInfo.fromObject(object.memeInfo);
            }
            if (object.isLongPic != null)
                message.isLongPic = object.isLongPic >>> 0;
            if (object.showOriginalBtn != null)
                message.showOriginalBtn = object.showOriginalBtn >>> 0;
            if (object.cdnSrcActive != null)
                message.cdnSrcActive = String(object.cdnSrcActive);
            return message;
        };

        /**
         * Creates a plain object from a PbContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.PbContent
         * @static
         * @param {tieba.PbContent} message PbContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = 0;
                object.text = "";
                object.link = "";
                object.src = "";
                object.bsize = "";
                object.bigSrc = "";
                object.bigSize = "";
                object.cdnSrc = "";
                object.bigCdnSrc = "";
                object.imgType = "";
                object.c = "";
                object.voiceMD5 = "";
                object.duringTime = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.dynamic = "";
                object._static = "";
                object.width = 0;
                object.height = 0;
                object.originSrc = "";
                object.originSize = 0;
                object.mediaSubtitle = "";
                object.urlType = 0;
                object.memeInfo = null;
                object.isLongPic = 0;
                object.showOriginalBtn = 0;
                object.cdnSrcActive = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.link != null && message.hasOwnProperty("link"))
                object.link = message.link;
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = message.src;
            if (message.bsize != null && message.hasOwnProperty("bsize"))
                object.bsize = message.bsize;
            if (message.bigSrc != null && message.hasOwnProperty("bigSrc"))
                object.bigSrc = message.bigSrc;
            if (message.bigSize != null && message.hasOwnProperty("bigSize"))
                object.bigSize = message.bigSize;
            if (message.cdnSrc != null && message.hasOwnProperty("cdnSrc"))
                object.cdnSrc = message.cdnSrc;
            if (message.bigCdnSrc != null && message.hasOwnProperty("bigCdnSrc"))
                object.bigCdnSrc = message.bigCdnSrc;
            if (message.imgType != null && message.hasOwnProperty("imgType"))
                object.imgType = message.imgType;
            if (message.c != null && message.hasOwnProperty("c"))
                object.c = message.c;
            if (message.voiceMD5 != null && message.hasOwnProperty("voiceMD5"))
                object.voiceMD5 = message.voiceMD5;
            if (message.duringTime != null && message.hasOwnProperty("duringTime"))
                object.duringTime = message.duringTime;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.dynamic != null && message.hasOwnProperty("dynamic"))
                object.dynamic = message.dynamic;
            if (message._static != null && message.hasOwnProperty("_static"))
                object._static = message._static;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.originSrc != null && message.hasOwnProperty("originSrc"))
                object.originSrc = message.originSrc;
            if (message.originSize != null && message.hasOwnProperty("originSize"))
                object.originSize = message.originSize;
            if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
                object.mediaSubtitle = message.mediaSubtitle;
            if (message.urlType != null && message.hasOwnProperty("urlType"))
                object.urlType = message.urlType;
            if (message.memeInfo != null && message.hasOwnProperty("memeInfo"))
                object.memeInfo = $root.tieba.MemeInfo.toObject(message.memeInfo, options);
            if (message.isLongPic != null && message.hasOwnProperty("isLongPic"))
                object.isLongPic = message.isLongPic;
            if (message.showOriginalBtn != null && message.hasOwnProperty("showOriginalBtn"))
                object.showOriginalBtn = message.showOriginalBtn;
            if (message.cdnSrcActive != null && message.hasOwnProperty("cdnSrcActive"))
                object.cdnSrcActive = message.cdnSrcActive;
            return object;
        };

        /**
         * Converts this PbContent to JSON.
         * @function toJSON
         * @memberof tieba.PbContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PbContent
         * @function getTypeUrl
         * @memberof tieba.PbContent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PbContent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.PbContent";
        };

        return PbContent;
    })();

    tieba.MemeInfo = (function() {

        /**
         * Properties of a MemeInfo.
         * @memberof tieba
         * @interface IMemeInfo
         * @property {number|null} [pckId] MemeInfo pckId
         * @property {number|Long|null} [picId] MemeInfo picId
         * @property {string|null} [picUrl] MemeInfo picUrl
         * @property {string|null} [thumbnail] MemeInfo thumbnail
         * @property {number|null} [width] MemeInfo width
         * @property {number|null} [height] MemeInfo height
         * @property {string|null} [detailLink] MemeInfo detailLink
         */

        /**
         * Constructs a new MemeInfo.
         * @memberof tieba
         * @classdesc Represents a MemeInfo.
         * @implements IMemeInfo
         * @constructor
         * @param {tieba.IMemeInfo=} [properties] Properties to set
         */
        function MemeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemeInfo pckId.
         * @member {number} pckId
         * @memberof tieba.MemeInfo
         * @instance
         */
        MemeInfo.prototype.pckId = 0;

        /**
         * MemeInfo picId.
         * @member {number|Long} picId
         * @memberof tieba.MemeInfo
         * @instance
         */
        MemeInfo.prototype.picId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MemeInfo picUrl.
         * @member {string} picUrl
         * @memberof tieba.MemeInfo
         * @instance
         */
        MemeInfo.prototype.picUrl = "";

        /**
         * MemeInfo thumbnail.
         * @member {string} thumbnail
         * @memberof tieba.MemeInfo
         * @instance
         */
        MemeInfo.prototype.thumbnail = "";

        /**
         * MemeInfo width.
         * @member {number} width
         * @memberof tieba.MemeInfo
         * @instance
         */
        MemeInfo.prototype.width = 0;

        /**
         * MemeInfo height.
         * @member {number} height
         * @memberof tieba.MemeInfo
         * @instance
         */
        MemeInfo.prototype.height = 0;

        /**
         * MemeInfo detailLink.
         * @member {string} detailLink
         * @memberof tieba.MemeInfo
         * @instance
         */
        MemeInfo.prototype.detailLink = "";

        /**
         * Creates a new MemeInfo instance using the specified properties.
         * @function create
         * @memberof tieba.MemeInfo
         * @static
         * @param {tieba.IMemeInfo=} [properties] Properties to set
         * @returns {tieba.MemeInfo} MemeInfo instance
         */
        MemeInfo.create = function create(properties) {
            return new MemeInfo(properties);
        };

        /**
         * Encodes the specified MemeInfo message. Does not implicitly {@link tieba.MemeInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.MemeInfo
         * @static
         * @param {tieba.IMemeInfo} message MemeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pckId != null && Object.hasOwnProperty.call(message, "pckId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.pckId);
            if (message.picId != null && Object.hasOwnProperty.call(message, "picId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.picId);
            if (message.picUrl != null && Object.hasOwnProperty.call(message, "picUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.picUrl);
            if (message.thumbnail != null && Object.hasOwnProperty.call(message, "thumbnail"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.thumbnail);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.height);
            if (message.detailLink != null && Object.hasOwnProperty.call(message, "detailLink"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.detailLink);
            return writer;
        };

        /**
         * Encodes the specified MemeInfo message, length delimited. Does not implicitly {@link tieba.MemeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.MemeInfo
         * @static
         * @param {tieba.IMemeInfo} message MemeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.MemeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.MemeInfo} MemeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.MemeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pckId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.picId = reader.uint64();
                        break;
                    }
                case 3: {
                        message.picUrl = reader.string();
                        break;
                    }
                case 4: {
                        message.thumbnail = reader.string();
                        break;
                    }
                case 5: {
                        message.width = reader.uint32();
                        break;
                    }
                case 6: {
                        message.height = reader.uint32();
                        break;
                    }
                case 7: {
                        message.detailLink = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.MemeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.MemeInfo} MemeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MemeInfo message.
         * @function verify
         * @memberof tieba.MemeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MemeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pckId != null && message.hasOwnProperty("pckId"))
                if (!$util.isInteger(message.pckId))
                    return "pckId: integer expected";
            if (message.picId != null && message.hasOwnProperty("picId"))
                if (!$util.isInteger(message.picId) && !(message.picId && $util.isInteger(message.picId.low) && $util.isInteger(message.picId.high)))
                    return "picId: integer|Long expected";
            if (message.picUrl != null && message.hasOwnProperty("picUrl"))
                if (!$util.isString(message.picUrl))
                    return "picUrl: string expected";
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                if (!$util.isString(message.thumbnail))
                    return "thumbnail: string expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.detailLink != null && message.hasOwnProperty("detailLink"))
                if (!$util.isString(message.detailLink))
                    return "detailLink: string expected";
            return null;
        };

        /**
         * Creates a MemeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.MemeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.MemeInfo} MemeInfo
         */
        MemeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.MemeInfo)
                return object;
            let message = new $root.tieba.MemeInfo();
            if (object.pckId != null)
                message.pckId = object.pckId >>> 0;
            if (object.picId != null)
                if ($util.Long)
                    (message.picId = $util.Long.fromValue(object.picId)).unsigned = true;
                else if (typeof object.picId === "string")
                    message.picId = parseInt(object.picId, 10);
                else if (typeof object.picId === "number")
                    message.picId = object.picId;
                else if (typeof object.picId === "object")
                    message.picId = new $util.LongBits(object.picId.low >>> 0, object.picId.high >>> 0).toNumber(true);
            if (object.picUrl != null)
                message.picUrl = String(object.picUrl);
            if (object.thumbnail != null)
                message.thumbnail = String(object.thumbnail);
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.detailLink != null)
                message.detailLink = String(object.detailLink);
            return message;
        };

        /**
         * Creates a plain object from a MemeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.MemeInfo
         * @static
         * @param {tieba.MemeInfo} message MemeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pckId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.picId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.picId = options.longs === String ? "0" : 0;
                object.picUrl = "";
                object.thumbnail = "";
                object.width = 0;
                object.height = 0;
                object.detailLink = "";
            }
            if (message.pckId != null && message.hasOwnProperty("pckId"))
                object.pckId = message.pckId;
            if (message.picId != null && message.hasOwnProperty("picId"))
                if (typeof message.picId === "number")
                    object.picId = options.longs === String ? String(message.picId) : message.picId;
                else
                    object.picId = options.longs === String ? $util.Long.prototype.toString.call(message.picId) : options.longs === Number ? new $util.LongBits(message.picId.low >>> 0, message.picId.high >>> 0).toNumber(true) : message.picId;
            if (message.picUrl != null && message.hasOwnProperty("picUrl"))
                object.picUrl = message.picUrl;
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                object.thumbnail = message.thumbnail;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.detailLink != null && message.hasOwnProperty("detailLink"))
                object.detailLink = message.detailLink;
            return object;
        };

        /**
         * Converts this MemeInfo to JSON.
         * @function toJSON
         * @memberof tieba.MemeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MemeInfo
         * @function getTypeUrl
         * @memberof tieba.MemeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MemeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.MemeInfo";
        };

        return MemeInfo;
    })();

    tieba.Media = (function() {

        /**
         * Properties of a Media.
         * @memberof tieba
         * @interface IMedia
         * @property {number|null} [type] Media type
         * @property {string|null} [bigPic] Media bigPic
         * @property {string|null} [srcPic] Media srcPic
         * @property {number|null} [width] Media width
         * @property {number|null} [height] Media height
         * @property {string|null} [originPic] Media originPic
         * @property {number|null} [originSize] Media originSize
         * @property {number|Long|null} [postId] Media postId
         * @property {string|null} [dynamicPic] Media dynamicPic
         * @property {number|null} [isLongPic] Media isLongPic
         * @property {number|null} [showOriginalBtn] Media showOriginalBtn
         */

        /**
         * Constructs a new Media.
         * @memberof tieba
         * @classdesc Represents a Media.
         * @implements IMedia
         * @constructor
         * @param {tieba.IMedia=} [properties] Properties to set
         */
        function Media(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Media type.
         * @member {number} type
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.type = 0;

        /**
         * Media bigPic.
         * @member {string} bigPic
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.bigPic = "";

        /**
         * Media srcPic.
         * @member {string} srcPic
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.srcPic = "";

        /**
         * Media width.
         * @member {number} width
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.width = 0;

        /**
         * Media height.
         * @member {number} height
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.height = 0;

        /**
         * Media originPic.
         * @member {string} originPic
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.originPic = "";

        /**
         * Media originSize.
         * @member {number} originSize
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.originSize = 0;

        /**
         * Media postId.
         * @member {number|Long} postId
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.postId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Media dynamicPic.
         * @member {string} dynamicPic
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.dynamicPic = "";

        /**
         * Media isLongPic.
         * @member {number} isLongPic
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.isLongPic = 0;

        /**
         * Media showOriginalBtn.
         * @member {number} showOriginalBtn
         * @memberof tieba.Media
         * @instance
         */
        Media.prototype.showOriginalBtn = 0;

        /**
         * Creates a new Media instance using the specified properties.
         * @function create
         * @memberof tieba.Media
         * @static
         * @param {tieba.IMedia=} [properties] Properties to set
         * @returns {tieba.Media} Media instance
         */
        Media.create = function create(properties) {
            return new Media(properties);
        };

        /**
         * Encodes the specified Media message. Does not implicitly {@link tieba.Media.verify|verify} messages.
         * @function encode
         * @memberof tieba.Media
         * @static
         * @param {tieba.IMedia} message Media message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Media.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.bigPic != null && Object.hasOwnProperty.call(message, "bigPic"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.bigPic);
            if (message.srcPic != null && Object.hasOwnProperty.call(message, "srcPic"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.srcPic);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.height);
            if (message.originPic != null && Object.hasOwnProperty.call(message, "originPic"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.originPic);
            if (message.originSize != null && Object.hasOwnProperty.call(message, "originSize"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.originSize);
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 17, wireType 0 =*/136).int64(message.postId);
            if (message.dynamicPic != null && Object.hasOwnProperty.call(message, "dynamicPic"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.dynamicPic);
            if (message.isLongPic != null && Object.hasOwnProperty.call(message, "isLongPic"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.isLongPic);
            if (message.showOriginalBtn != null && Object.hasOwnProperty.call(message, "showOriginalBtn"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.showOriginalBtn);
            return writer;
        };

        /**
         * Encodes the specified Media message, length delimited. Does not implicitly {@link tieba.Media.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Media
         * @static
         * @param {tieba.IMedia} message Media message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Media.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Media message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Media
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Media} Media
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Media.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Media();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        message.bigPic = reader.string();
                        break;
                    }
                case 8: {
                        message.srcPic = reader.string();
                        break;
                    }
                case 10: {
                        message.width = reader.uint32();
                        break;
                    }
                case 11: {
                        message.height = reader.uint32();
                        break;
                    }
                case 15: {
                        message.originPic = reader.string();
                        break;
                    }
                case 16: {
                        message.originSize = reader.uint32();
                        break;
                    }
                case 17: {
                        message.postId = reader.int64();
                        break;
                    }
                case 18: {
                        message.dynamicPic = reader.string();
                        break;
                    }
                case 19: {
                        message.isLongPic = reader.uint32();
                        break;
                    }
                case 20: {
                        message.showOriginalBtn = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Media message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Media
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Media} Media
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Media.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Media message.
         * @function verify
         * @memberof tieba.Media
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Media.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.bigPic != null && message.hasOwnProperty("bigPic"))
                if (!$util.isString(message.bigPic))
                    return "bigPic: string expected";
            if (message.srcPic != null && message.hasOwnProperty("srcPic"))
                if (!$util.isString(message.srcPic))
                    return "srcPic: string expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.originPic != null && message.hasOwnProperty("originPic"))
                if (!$util.isString(message.originPic))
                    return "originPic: string expected";
            if (message.originSize != null && message.hasOwnProperty("originSize"))
                if (!$util.isInteger(message.originSize))
                    return "originSize: integer expected";
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isInteger(message.postId) && !(message.postId && $util.isInteger(message.postId.low) && $util.isInteger(message.postId.high)))
                    return "postId: integer|Long expected";
            if (message.dynamicPic != null && message.hasOwnProperty("dynamicPic"))
                if (!$util.isString(message.dynamicPic))
                    return "dynamicPic: string expected";
            if (message.isLongPic != null && message.hasOwnProperty("isLongPic"))
                if (!$util.isInteger(message.isLongPic))
                    return "isLongPic: integer expected";
            if (message.showOriginalBtn != null && message.hasOwnProperty("showOriginalBtn"))
                if (!$util.isInteger(message.showOriginalBtn))
                    return "showOriginalBtn: integer expected";
            return null;
        };

        /**
         * Creates a Media message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Media
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Media} Media
         */
        Media.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Media)
                return object;
            let message = new $root.tieba.Media();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.bigPic != null)
                message.bigPic = String(object.bigPic);
            if (object.srcPic != null)
                message.srcPic = String(object.srcPic);
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.originPic != null)
                message.originPic = String(object.originPic);
            if (object.originSize != null)
                message.originSize = object.originSize >>> 0;
            if (object.postId != null)
                if ($util.Long)
                    (message.postId = $util.Long.fromValue(object.postId)).unsigned = false;
                else if (typeof object.postId === "string")
                    message.postId = parseInt(object.postId, 10);
                else if (typeof object.postId === "number")
                    message.postId = object.postId;
                else if (typeof object.postId === "object")
                    message.postId = new $util.LongBits(object.postId.low >>> 0, object.postId.high >>> 0).toNumber();
            if (object.dynamicPic != null)
                message.dynamicPic = String(object.dynamicPic);
            if (object.isLongPic != null)
                message.isLongPic = object.isLongPic >>> 0;
            if (object.showOriginalBtn != null)
                message.showOriginalBtn = object.showOriginalBtn >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Media message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Media
         * @static
         * @param {tieba.Media} message Media
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Media.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = 0;
                object.bigPic = "";
                object.srcPic = "";
                object.width = 0;
                object.height = 0;
                object.originPic = "";
                object.originSize = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.postId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.postId = options.longs === String ? "0" : 0;
                object.dynamicPic = "";
                object.isLongPic = 0;
                object.showOriginalBtn = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.bigPic != null && message.hasOwnProperty("bigPic"))
                object.bigPic = message.bigPic;
            if (message.srcPic != null && message.hasOwnProperty("srcPic"))
                object.srcPic = message.srcPic;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.originPic != null && message.hasOwnProperty("originPic"))
                object.originPic = message.originPic;
            if (message.originSize != null && message.hasOwnProperty("originSize"))
                object.originSize = message.originSize;
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (typeof message.postId === "number")
                    object.postId = options.longs === String ? String(message.postId) : message.postId;
                else
                    object.postId = options.longs === String ? $util.Long.prototype.toString.call(message.postId) : options.longs === Number ? new $util.LongBits(message.postId.low >>> 0, message.postId.high >>> 0).toNumber() : message.postId;
            if (message.dynamicPic != null && message.hasOwnProperty("dynamicPic"))
                object.dynamicPic = message.dynamicPic;
            if (message.isLongPic != null && message.hasOwnProperty("isLongPic"))
                object.isLongPic = message.isLongPic;
            if (message.showOriginalBtn != null && message.hasOwnProperty("showOriginalBtn"))
                object.showOriginalBtn = message.showOriginalBtn;
            return object;
        };

        /**
         * Converts this Media to JSON.
         * @function toJSON
         * @memberof tieba.Media
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Media.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Media
         * @function getTypeUrl
         * @memberof tieba.Media
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Media.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Media";
        };

        return Media;
    })();

    tieba.PollInfo = (function() {

        /**
         * Properties of a PollInfo.
         * @memberof tieba
         * @interface IPollInfo
         * @property {number|null} [type] PollInfo type
         * @property {number|null} [isMulti] PollInfo isMulti
         * @property {number|Long|null} [totalNum] PollInfo totalNum
         * @property {number|null} [optionsCount] PollInfo optionsCount
         * @property {number|null} [isPolled] PollInfo isPolled
         * @property {string|null} [polledValue] PollInfo polledValue
         * @property {string|null} [tips] PollInfo tips
         * @property {number|null} [endTime] PollInfo endTime
         * @property {Array.<tieba.IPollOption>|null} [options] PollInfo options
         * @property {number|null} [status] PollInfo status
         * @property {number|Long|null} [totalPoll] PollInfo totalPoll
         * @property {string|null} [title] PollInfo title
         * @property {number|null} [lastTime] PollInfo lastTime
         */

        /**
         * Constructs a new PollInfo.
         * @memberof tieba
         * @classdesc Represents a PollInfo.
         * @implements IPollInfo
         * @constructor
         * @param {tieba.IPollInfo=} [properties] Properties to set
         */
        function PollInfo(properties) {
            this.options = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PollInfo type.
         * @member {number} type
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.type = 0;

        /**
         * PollInfo isMulti.
         * @member {number} isMulti
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.isMulti = 0;

        /**
         * PollInfo totalNum.
         * @member {number|Long} totalNum
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.totalNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PollInfo optionsCount.
         * @member {number} optionsCount
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.optionsCount = 0;

        /**
         * PollInfo isPolled.
         * @member {number} isPolled
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.isPolled = 0;

        /**
         * PollInfo polledValue.
         * @member {string} polledValue
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.polledValue = "";

        /**
         * PollInfo tips.
         * @member {string} tips
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.tips = "";

        /**
         * PollInfo endTime.
         * @member {number} endTime
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.endTime = 0;

        /**
         * PollInfo options.
         * @member {Array.<tieba.IPollOption>} options
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.options = $util.emptyArray;

        /**
         * PollInfo status.
         * @member {number} status
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.status = 0;

        /**
         * PollInfo totalPoll.
         * @member {number|Long} totalPoll
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.totalPoll = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PollInfo title.
         * @member {string} title
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.title = "";

        /**
         * PollInfo lastTime.
         * @member {number} lastTime
         * @memberof tieba.PollInfo
         * @instance
         */
        PollInfo.prototype.lastTime = 0;

        /**
         * Creates a new PollInfo instance using the specified properties.
         * @function create
         * @memberof tieba.PollInfo
         * @static
         * @param {tieba.IPollInfo=} [properties] Properties to set
         * @returns {tieba.PollInfo} PollInfo instance
         */
        PollInfo.create = function create(properties) {
            return new PollInfo(properties);
        };

        /**
         * Encodes the specified PollInfo message. Does not implicitly {@link tieba.PollInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.PollInfo
         * @static
         * @param {tieba.IPollInfo} message PollInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.isMulti != null && Object.hasOwnProperty.call(message, "isMulti"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isMulti);
            if (message.totalNum != null && Object.hasOwnProperty.call(message, "totalNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalNum);
            if (message.optionsCount != null && Object.hasOwnProperty.call(message, "optionsCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.optionsCount);
            if (message.isPolled != null && Object.hasOwnProperty.call(message, "isPolled"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.isPolled);
            if (message.polledValue != null && Object.hasOwnProperty.call(message, "polledValue"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.polledValue);
            if (message.tips != null && Object.hasOwnProperty.call(message, "tips"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.tips);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.endTime);
            if (message.options != null && message.options.length)
                for (let i = 0; i < message.options.length; ++i)
                    $root.tieba.PollOption.encode(message.options[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.status);
            if (message.totalPoll != null && Object.hasOwnProperty.call(message, "totalPoll"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.totalPoll);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.title);
            if (message.lastTime != null && Object.hasOwnProperty.call(message, "lastTime"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.lastTime);
            return writer;
        };

        /**
         * Encodes the specified PollInfo message, length delimited. Does not implicitly {@link tieba.PollInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.PollInfo
         * @static
         * @param {tieba.IPollInfo} message PollInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PollInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.PollInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.PollInfo} PollInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.PollInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.isMulti = reader.int32();
                        break;
                    }
                case 3: {
                        message.totalNum = reader.int64();
                        break;
                    }
                case 4: {
                        message.optionsCount = reader.int32();
                        break;
                    }
                case 5: {
                        message.isPolled = reader.int32();
                        break;
                    }
                case 6: {
                        message.polledValue = reader.string();
                        break;
                    }
                case 7: {
                        message.tips = reader.string();
                        break;
                    }
                case 8: {
                        message.endTime = reader.int32();
                        break;
                    }
                case 9: {
                        if (!(message.options && message.options.length))
                            message.options = [];
                        message.options.push($root.tieba.PollOption.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.status = reader.int32();
                        break;
                    }
                case 11: {
                        message.totalPoll = reader.int64();
                        break;
                    }
                case 12: {
                        message.title = reader.string();
                        break;
                    }
                case 13: {
                        message.lastTime = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PollInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.PollInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.PollInfo} PollInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PollInfo message.
         * @function verify
         * @memberof tieba.PollInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PollInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.isMulti != null && message.hasOwnProperty("isMulti"))
                if (!$util.isInteger(message.isMulti))
                    return "isMulti: integer expected";
            if (message.totalNum != null && message.hasOwnProperty("totalNum"))
                if (!$util.isInteger(message.totalNum) && !(message.totalNum && $util.isInteger(message.totalNum.low) && $util.isInteger(message.totalNum.high)))
                    return "totalNum: integer|Long expected";
            if (message.optionsCount != null && message.hasOwnProperty("optionsCount"))
                if (!$util.isInteger(message.optionsCount))
                    return "optionsCount: integer expected";
            if (message.isPolled != null && message.hasOwnProperty("isPolled"))
                if (!$util.isInteger(message.isPolled))
                    return "isPolled: integer expected";
            if (message.polledValue != null && message.hasOwnProperty("polledValue"))
                if (!$util.isString(message.polledValue))
                    return "polledValue: string expected";
            if (message.tips != null && message.hasOwnProperty("tips"))
                if (!$util.isString(message.tips))
                    return "tips: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime))
                    return "endTime: integer expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (let i = 0; i < message.options.length; ++i) {
                    let error = $root.tieba.PollOption.verify(message.options[i]);
                    if (error)
                        return "options." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.totalPoll != null && message.hasOwnProperty("totalPoll"))
                if (!$util.isInteger(message.totalPoll) && !(message.totalPoll && $util.isInteger(message.totalPoll.low) && $util.isInteger(message.totalPoll.high)))
                    return "totalPoll: integer|Long expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.lastTime != null && message.hasOwnProperty("lastTime"))
                if (!$util.isInteger(message.lastTime))
                    return "lastTime: integer expected";
            return null;
        };

        /**
         * Creates a PollInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.PollInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.PollInfo} PollInfo
         */
        PollInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.PollInfo)
                return object;
            let message = new $root.tieba.PollInfo();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.isMulti != null)
                message.isMulti = object.isMulti | 0;
            if (object.totalNum != null)
                if ($util.Long)
                    (message.totalNum = $util.Long.fromValue(object.totalNum)).unsigned = false;
                else if (typeof object.totalNum === "string")
                    message.totalNum = parseInt(object.totalNum, 10);
                else if (typeof object.totalNum === "number")
                    message.totalNum = object.totalNum;
                else if (typeof object.totalNum === "object")
                    message.totalNum = new $util.LongBits(object.totalNum.low >>> 0, object.totalNum.high >>> 0).toNumber();
            if (object.optionsCount != null)
                message.optionsCount = object.optionsCount | 0;
            if (object.isPolled != null)
                message.isPolled = object.isPolled | 0;
            if (object.polledValue != null)
                message.polledValue = String(object.polledValue);
            if (object.tips != null)
                message.tips = String(object.tips);
            if (object.endTime != null)
                message.endTime = object.endTime | 0;
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".tieba.PollInfo.options: array expected");
                message.options = [];
                for (let i = 0; i < object.options.length; ++i) {
                    if (typeof object.options[i] !== "object")
                        throw TypeError(".tieba.PollInfo.options: object expected");
                    message.options[i] = $root.tieba.PollOption.fromObject(object.options[i]);
                }
            }
            if (object.status != null)
                message.status = object.status | 0;
            if (object.totalPoll != null)
                if ($util.Long)
                    (message.totalPoll = $util.Long.fromValue(object.totalPoll)).unsigned = false;
                else if (typeof object.totalPoll === "string")
                    message.totalPoll = parseInt(object.totalPoll, 10);
                else if (typeof object.totalPoll === "number")
                    message.totalPoll = object.totalPoll;
                else if (typeof object.totalPoll === "object")
                    message.totalPoll = new $util.LongBits(object.totalPoll.low >>> 0, object.totalPoll.high >>> 0).toNumber();
            if (object.title != null)
                message.title = String(object.title);
            if (object.lastTime != null)
                message.lastTime = object.lastTime >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PollInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.PollInfo
         * @static
         * @param {tieba.PollInfo} message PollInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PollInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.options = [];
            if (options.defaults) {
                object.type = 0;
                object.isMulti = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalNum = options.longs === String ? "0" : 0;
                object.optionsCount = 0;
                object.isPolled = 0;
                object.polledValue = "";
                object.tips = "";
                object.endTime = 0;
                object.status = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalPoll = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalPoll = options.longs === String ? "0" : 0;
                object.title = "";
                object.lastTime = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.isMulti != null && message.hasOwnProperty("isMulti"))
                object.isMulti = message.isMulti;
            if (message.totalNum != null && message.hasOwnProperty("totalNum"))
                if (typeof message.totalNum === "number")
                    object.totalNum = options.longs === String ? String(message.totalNum) : message.totalNum;
                else
                    object.totalNum = options.longs === String ? $util.Long.prototype.toString.call(message.totalNum) : options.longs === Number ? new $util.LongBits(message.totalNum.low >>> 0, message.totalNum.high >>> 0).toNumber() : message.totalNum;
            if (message.optionsCount != null && message.hasOwnProperty("optionsCount"))
                object.optionsCount = message.optionsCount;
            if (message.isPolled != null && message.hasOwnProperty("isPolled"))
                object.isPolled = message.isPolled;
            if (message.polledValue != null && message.hasOwnProperty("polledValue"))
                object.polledValue = message.polledValue;
            if (message.tips != null && message.hasOwnProperty("tips"))
                object.tips = message.tips;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.options && message.options.length) {
                object.options = [];
                for (let j = 0; j < message.options.length; ++j)
                    object.options[j] = $root.tieba.PollOption.toObject(message.options[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.totalPoll != null && message.hasOwnProperty("totalPoll"))
                if (typeof message.totalPoll === "number")
                    object.totalPoll = options.longs === String ? String(message.totalPoll) : message.totalPoll;
                else
                    object.totalPoll = options.longs === String ? $util.Long.prototype.toString.call(message.totalPoll) : options.longs === Number ? new $util.LongBits(message.totalPoll.low >>> 0, message.totalPoll.high >>> 0).toNumber() : message.totalPoll;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.lastTime != null && message.hasOwnProperty("lastTime"))
                object.lastTime = message.lastTime;
            return object;
        };

        /**
         * Converts this PollInfo to JSON.
         * @function toJSON
         * @memberof tieba.PollInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PollInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PollInfo
         * @function getTypeUrl
         * @memberof tieba.PollInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PollInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.PollInfo";
        };

        return PollInfo;
    })();

    tieba.PollOption = (function() {

        /**
         * Properties of a PollOption.
         * @memberof tieba
         * @interface IPollOption
         * @property {number|null} [id] PollOption id
         * @property {number|Long|null} [num] PollOption num
         * @property {string|null} [text] PollOption text
         * @property {string|null} [image] PollOption image
         */

        /**
         * Constructs a new PollOption.
         * @memberof tieba
         * @classdesc Represents a PollOption.
         * @implements IPollOption
         * @constructor
         * @param {tieba.IPollOption=} [properties] Properties to set
         */
        function PollOption(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PollOption id.
         * @member {number} id
         * @memberof tieba.PollOption
         * @instance
         */
        PollOption.prototype.id = 0;

        /**
         * PollOption num.
         * @member {number|Long} num
         * @memberof tieba.PollOption
         * @instance
         */
        PollOption.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PollOption text.
         * @member {string} text
         * @memberof tieba.PollOption
         * @instance
         */
        PollOption.prototype.text = "";

        /**
         * PollOption image.
         * @member {string} image
         * @memberof tieba.PollOption
         * @instance
         */
        PollOption.prototype.image = "";

        /**
         * Creates a new PollOption instance using the specified properties.
         * @function create
         * @memberof tieba.PollOption
         * @static
         * @param {tieba.IPollOption=} [properties] Properties to set
         * @returns {tieba.PollOption} PollOption instance
         */
        PollOption.create = function create(properties) {
            return new PollOption(properties);
        };

        /**
         * Encodes the specified PollOption message. Does not implicitly {@link tieba.PollOption.verify|verify} messages.
         * @function encode
         * @memberof tieba.PollOption
         * @static
         * @param {tieba.IPollOption} message PollOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollOption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.num);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.image);
            return writer;
        };

        /**
         * Encodes the specified PollOption message, length delimited. Does not implicitly {@link tieba.PollOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.PollOption
         * @static
         * @param {tieba.IPollOption} message PollOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollOption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PollOption message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.PollOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.PollOption} PollOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollOption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.PollOption();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int64();
                        break;
                    }
                case 3: {
                        message.text = reader.string();
                        break;
                    }
                case 4: {
                        message.image = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PollOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.PollOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.PollOption} PollOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollOption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PollOption message.
         * @function verify
         * @memberof tieba.PollOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PollOption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                    return "num: integer|Long expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.image != null && message.hasOwnProperty("image"))
                if (!$util.isString(message.image))
                    return "image: string expected";
            return null;
        };

        /**
         * Creates a PollOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.PollOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.PollOption} PollOption
         */
        PollOption.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.PollOption)
                return object;
            let message = new $root.tieba.PollOption();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                if ($util.Long)
                    (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                else if (typeof object.num === "string")
                    message.num = parseInt(object.num, 10);
                else if (typeof object.num === "number")
                    message.num = object.num;
                else if (typeof object.num === "object")
                    message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
            if (object.text != null)
                message.text = String(object.text);
            if (object.image != null)
                message.image = String(object.image);
            return message;
        };

        /**
         * Creates a plain object from a PollOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.PollOption
         * @static
         * @param {tieba.PollOption} message PollOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PollOption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.num = options.longs === String ? "0" : 0;
                object.text = "";
                object.image = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                if (typeof message.num === "number")
                    object.num = options.longs === String ? String(message.num) : message.num;
                else
                    object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = message.image;
            return object;
        };

        /**
         * Converts this PollOption to JSON.
         * @function toJSON
         * @memberof tieba.PollOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PollOption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PollOption
         * @function getTypeUrl
         * @memberof tieba.PollOption
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PollOption.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.PollOption";
        };

        return PollOption;
    })();

    tieba.VideoInfo = (function() {

        /**
         * Properties of a VideoInfo.
         * @memberof tieba
         * @interface IVideoInfo
         * @property {string|null} [videoMD5] VideoInfo videoMD5
         * @property {string|null} [videoUrl] VideoInfo videoUrl
         * @property {number|null} [videoDuration] VideoInfo videoDuration
         * @property {number|null} [videoWidth] VideoInfo videoWidth
         * @property {number|null} [videoHeight] VideoInfo videoHeight
         * @property {string|null} [thumbnailUrl] VideoInfo thumbnailUrl
         * @property {number|null} [thumbnailWidth] VideoInfo thumbnailWidth
         * @property {number|null} [thumbnailHeight] VideoInfo thumbnailHeight
         * @property {string|null} [mediaSubtitle] VideoInfo mediaSubtitle
         */

        /**
         * Constructs a new VideoInfo.
         * @memberof tieba
         * @classdesc Represents a VideoInfo.
         * @implements IVideoInfo
         * @constructor
         * @param {tieba.IVideoInfo=} [properties] Properties to set
         */
        function VideoInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoInfo videoMD5.
         * @member {string} videoMD5
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.videoMD5 = "";

        /**
         * VideoInfo videoUrl.
         * @member {string} videoUrl
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.videoUrl = "";

        /**
         * VideoInfo videoDuration.
         * @member {number} videoDuration
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.videoDuration = 0;

        /**
         * VideoInfo videoWidth.
         * @member {number} videoWidth
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.videoWidth = 0;

        /**
         * VideoInfo videoHeight.
         * @member {number} videoHeight
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.videoHeight = 0;

        /**
         * VideoInfo thumbnailUrl.
         * @member {string} thumbnailUrl
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.thumbnailUrl = "";

        /**
         * VideoInfo thumbnailWidth.
         * @member {number} thumbnailWidth
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.thumbnailWidth = 0;

        /**
         * VideoInfo thumbnailHeight.
         * @member {number} thumbnailHeight
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.thumbnailHeight = 0;

        /**
         * VideoInfo mediaSubtitle.
         * @member {string} mediaSubtitle
         * @memberof tieba.VideoInfo
         * @instance
         */
        VideoInfo.prototype.mediaSubtitle = "";

        /**
         * Creates a new VideoInfo instance using the specified properties.
         * @function create
         * @memberof tieba.VideoInfo
         * @static
         * @param {tieba.IVideoInfo=} [properties] Properties to set
         * @returns {tieba.VideoInfo} VideoInfo instance
         */
        VideoInfo.create = function create(properties) {
            return new VideoInfo(properties);
        };

        /**
         * Encodes the specified VideoInfo message. Does not implicitly {@link tieba.VideoInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.VideoInfo
         * @static
         * @param {tieba.IVideoInfo} message VideoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.videoMD5 != null && Object.hasOwnProperty.call(message, "videoMD5"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.videoMD5);
            if (message.videoUrl != null && Object.hasOwnProperty.call(message, "videoUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.videoUrl);
            if (message.videoDuration != null && Object.hasOwnProperty.call(message, "videoDuration"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.videoDuration);
            if (message.videoWidth != null && Object.hasOwnProperty.call(message, "videoWidth"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.videoWidth);
            if (message.videoHeight != null && Object.hasOwnProperty.call(message, "videoHeight"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.videoHeight);
            if (message.thumbnailUrl != null && Object.hasOwnProperty.call(message, "thumbnailUrl"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.thumbnailUrl);
            if (message.thumbnailWidth != null && Object.hasOwnProperty.call(message, "thumbnailWidth"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.thumbnailWidth);
            if (message.thumbnailHeight != null && Object.hasOwnProperty.call(message, "thumbnailHeight"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.thumbnailHeight);
            if (message.mediaSubtitle != null && Object.hasOwnProperty.call(message, "mediaSubtitle"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.mediaSubtitle);
            return writer;
        };

        /**
         * Encodes the specified VideoInfo message, length delimited. Does not implicitly {@link tieba.VideoInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.VideoInfo
         * @static
         * @param {tieba.IVideoInfo} message VideoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.VideoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.VideoInfo} VideoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.VideoInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.videoMD5 = reader.string();
                        break;
                    }
                case 2: {
                        message.videoUrl = reader.string();
                        break;
                    }
                case 3: {
                        message.videoDuration = reader.uint32();
                        break;
                    }
                case 4: {
                        message.videoWidth = reader.uint32();
                        break;
                    }
                case 5: {
                        message.videoHeight = reader.uint32();
                        break;
                    }
                case 6: {
                        message.thumbnailUrl = reader.string();
                        break;
                    }
                case 7: {
                        message.thumbnailWidth = reader.uint32();
                        break;
                    }
                case 8: {
                        message.thumbnailHeight = reader.uint32();
                        break;
                    }
                case 11: {
                        message.mediaSubtitle = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.VideoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.VideoInfo} VideoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoInfo message.
         * @function verify
         * @memberof tieba.VideoInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.videoMD5 != null && message.hasOwnProperty("videoMD5"))
                if (!$util.isString(message.videoMD5))
                    return "videoMD5: string expected";
            if (message.videoUrl != null && message.hasOwnProperty("videoUrl"))
                if (!$util.isString(message.videoUrl))
                    return "videoUrl: string expected";
            if (message.videoDuration != null && message.hasOwnProperty("videoDuration"))
                if (!$util.isInteger(message.videoDuration))
                    return "videoDuration: integer expected";
            if (message.videoWidth != null && message.hasOwnProperty("videoWidth"))
                if (!$util.isInteger(message.videoWidth))
                    return "videoWidth: integer expected";
            if (message.videoHeight != null && message.hasOwnProperty("videoHeight"))
                if (!$util.isInteger(message.videoHeight))
                    return "videoHeight: integer expected";
            if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                if (!$util.isString(message.thumbnailUrl))
                    return "thumbnailUrl: string expected";
            if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                if (!$util.isInteger(message.thumbnailWidth))
                    return "thumbnailWidth: integer expected";
            if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                if (!$util.isInteger(message.thumbnailHeight))
                    return "thumbnailHeight: integer expected";
            if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
                if (!$util.isString(message.mediaSubtitle))
                    return "mediaSubtitle: string expected";
            return null;
        };

        /**
         * Creates a VideoInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.VideoInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.VideoInfo} VideoInfo
         */
        VideoInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.VideoInfo)
                return object;
            let message = new $root.tieba.VideoInfo();
            if (object.videoMD5 != null)
                message.videoMD5 = String(object.videoMD5);
            if (object.videoUrl != null)
                message.videoUrl = String(object.videoUrl);
            if (object.videoDuration != null)
                message.videoDuration = object.videoDuration >>> 0;
            if (object.videoWidth != null)
                message.videoWidth = object.videoWidth >>> 0;
            if (object.videoHeight != null)
                message.videoHeight = object.videoHeight >>> 0;
            if (object.thumbnailUrl != null)
                message.thumbnailUrl = String(object.thumbnailUrl);
            if (object.thumbnailWidth != null)
                message.thumbnailWidth = object.thumbnailWidth >>> 0;
            if (object.thumbnailHeight != null)
                message.thumbnailHeight = object.thumbnailHeight >>> 0;
            if (object.mediaSubtitle != null)
                message.mediaSubtitle = String(object.mediaSubtitle);
            return message;
        };

        /**
         * Creates a plain object from a VideoInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.VideoInfo
         * @static
         * @param {tieba.VideoInfo} message VideoInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VideoInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.videoMD5 = "";
                object.videoUrl = "";
                object.videoDuration = 0;
                object.videoWidth = 0;
                object.videoHeight = 0;
                object.thumbnailUrl = "";
                object.thumbnailWidth = 0;
                object.thumbnailHeight = 0;
                object.mediaSubtitle = "";
            }
            if (message.videoMD5 != null && message.hasOwnProperty("videoMD5"))
                object.videoMD5 = message.videoMD5;
            if (message.videoUrl != null && message.hasOwnProperty("videoUrl"))
                object.videoUrl = message.videoUrl;
            if (message.videoDuration != null && message.hasOwnProperty("videoDuration"))
                object.videoDuration = message.videoDuration;
            if (message.videoWidth != null && message.hasOwnProperty("videoWidth"))
                object.videoWidth = message.videoWidth;
            if (message.videoHeight != null && message.hasOwnProperty("videoHeight"))
                object.videoHeight = message.videoHeight;
            if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                object.thumbnailUrl = message.thumbnailUrl;
            if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                object.thumbnailWidth = message.thumbnailWidth;
            if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                object.thumbnailHeight = message.thumbnailHeight;
            if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
                object.mediaSubtitle = message.mediaSubtitle;
            return object;
        };

        /**
         * Converts this VideoInfo to JSON.
         * @function toJSON
         * @memberof tieba.VideoInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VideoInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VideoInfo
         * @function getTypeUrl
         * @memberof tieba.VideoInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VideoInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.VideoInfo";
        };

        return VideoInfo;
    })();

    tieba.Agree = (function() {

        /**
         * Properties of an Agree.
         * @memberof tieba
         * @interface IAgree
         * @property {number|Long|null} [agreeNum] Agree agreeNum
         * @property {number|null} [hasAgree] Agree hasAgree
         * @property {number|null} [agreeType] Agree agreeType
         * @property {number|Long|null} [disagreeNum] Agree disagreeNum
         * @property {number|Long|null} [diffAgreeNum] Agree diffAgreeNum
         */

        /**
         * Constructs a new Agree.
         * @memberof tieba
         * @classdesc Represents an Agree.
         * @implements IAgree
         * @constructor
         * @param {tieba.IAgree=} [properties] Properties to set
         */
        function Agree(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Agree agreeNum.
         * @member {number|Long} agreeNum
         * @memberof tieba.Agree
         * @instance
         */
        Agree.prototype.agreeNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Agree hasAgree.
         * @member {number} hasAgree
         * @memberof tieba.Agree
         * @instance
         */
        Agree.prototype.hasAgree = 0;

        /**
         * Agree agreeType.
         * @member {number} agreeType
         * @memberof tieba.Agree
         * @instance
         */
        Agree.prototype.agreeType = 0;

        /**
         * Agree disagreeNum.
         * @member {number|Long} disagreeNum
         * @memberof tieba.Agree
         * @instance
         */
        Agree.prototype.disagreeNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Agree diffAgreeNum.
         * @member {number|Long} diffAgreeNum
         * @memberof tieba.Agree
         * @instance
         */
        Agree.prototype.diffAgreeNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Agree instance using the specified properties.
         * @function create
         * @memberof tieba.Agree
         * @static
         * @param {tieba.IAgree=} [properties] Properties to set
         * @returns {tieba.Agree} Agree instance
         */
        Agree.create = function create(properties) {
            return new Agree(properties);
        };

        /**
         * Encodes the specified Agree message. Does not implicitly {@link tieba.Agree.verify|verify} messages.
         * @function encode
         * @memberof tieba.Agree
         * @static
         * @param {tieba.IAgree} message Agree message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Agree.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.agreeNum != null && Object.hasOwnProperty.call(message, "agreeNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.agreeNum);
            if (message.hasAgree != null && Object.hasOwnProperty.call(message, "hasAgree"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hasAgree);
            if (message.agreeType != null && Object.hasOwnProperty.call(message, "agreeType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.agreeType);
            if (message.disagreeNum != null && Object.hasOwnProperty.call(message, "disagreeNum"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.disagreeNum);
            if (message.diffAgreeNum != null && Object.hasOwnProperty.call(message, "diffAgreeNum"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.diffAgreeNum);
            return writer;
        };

        /**
         * Encodes the specified Agree message, length delimited. Does not implicitly {@link tieba.Agree.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Agree
         * @static
         * @param {tieba.IAgree} message Agree message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Agree.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Agree message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Agree
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Agree} Agree
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Agree.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Agree();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.agreeNum = reader.int64();
                        break;
                    }
                case 2: {
                        message.hasAgree = reader.int32();
                        break;
                    }
                case 3: {
                        message.agreeType = reader.int32();
                        break;
                    }
                case 4: {
                        message.disagreeNum = reader.int64();
                        break;
                    }
                case 5: {
                        message.diffAgreeNum = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Agree message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Agree
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Agree} Agree
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Agree.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Agree message.
         * @function verify
         * @memberof tieba.Agree
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Agree.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
                if (!$util.isInteger(message.agreeNum) && !(message.agreeNum && $util.isInteger(message.agreeNum.low) && $util.isInteger(message.agreeNum.high)))
                    return "agreeNum: integer|Long expected";
            if (message.hasAgree != null && message.hasOwnProperty("hasAgree"))
                if (!$util.isInteger(message.hasAgree))
                    return "hasAgree: integer expected";
            if (message.agreeType != null && message.hasOwnProperty("agreeType"))
                if (!$util.isInteger(message.agreeType))
                    return "agreeType: integer expected";
            if (message.disagreeNum != null && message.hasOwnProperty("disagreeNum"))
                if (!$util.isInteger(message.disagreeNum) && !(message.disagreeNum && $util.isInteger(message.disagreeNum.low) && $util.isInteger(message.disagreeNum.high)))
                    return "disagreeNum: integer|Long expected";
            if (message.diffAgreeNum != null && message.hasOwnProperty("diffAgreeNum"))
                if (!$util.isInteger(message.diffAgreeNum) && !(message.diffAgreeNum && $util.isInteger(message.diffAgreeNum.low) && $util.isInteger(message.diffAgreeNum.high)))
                    return "diffAgreeNum: integer|Long expected";
            return null;
        };

        /**
         * Creates an Agree message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Agree
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Agree} Agree
         */
        Agree.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Agree)
                return object;
            let message = new $root.tieba.Agree();
            if (object.agreeNum != null)
                if ($util.Long)
                    (message.agreeNum = $util.Long.fromValue(object.agreeNum)).unsigned = false;
                else if (typeof object.agreeNum === "string")
                    message.agreeNum = parseInt(object.agreeNum, 10);
                else if (typeof object.agreeNum === "number")
                    message.agreeNum = object.agreeNum;
                else if (typeof object.agreeNum === "object")
                    message.agreeNum = new $util.LongBits(object.agreeNum.low >>> 0, object.agreeNum.high >>> 0).toNumber();
            if (object.hasAgree != null)
                message.hasAgree = object.hasAgree | 0;
            if (object.agreeType != null)
                message.agreeType = object.agreeType | 0;
            if (object.disagreeNum != null)
                if ($util.Long)
                    (message.disagreeNum = $util.Long.fromValue(object.disagreeNum)).unsigned = false;
                else if (typeof object.disagreeNum === "string")
                    message.disagreeNum = parseInt(object.disagreeNum, 10);
                else if (typeof object.disagreeNum === "number")
                    message.disagreeNum = object.disagreeNum;
                else if (typeof object.disagreeNum === "object")
                    message.disagreeNum = new $util.LongBits(object.disagreeNum.low >>> 0, object.disagreeNum.high >>> 0).toNumber();
            if (object.diffAgreeNum != null)
                if ($util.Long)
                    (message.diffAgreeNum = $util.Long.fromValue(object.diffAgreeNum)).unsigned = false;
                else if (typeof object.diffAgreeNum === "string")
                    message.diffAgreeNum = parseInt(object.diffAgreeNum, 10);
                else if (typeof object.diffAgreeNum === "number")
                    message.diffAgreeNum = object.diffAgreeNum;
                else if (typeof object.diffAgreeNum === "object")
                    message.diffAgreeNum = new $util.LongBits(object.diffAgreeNum.low >>> 0, object.diffAgreeNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Agree message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Agree
         * @static
         * @param {tieba.Agree} message Agree
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Agree.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.agreeNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.agreeNum = options.longs === String ? "0" : 0;
                object.hasAgree = 0;
                object.agreeType = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.disagreeNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.disagreeNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.diffAgreeNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.diffAgreeNum = options.longs === String ? "0" : 0;
            }
            if (message.agreeNum != null && message.hasOwnProperty("agreeNum"))
                if (typeof message.agreeNum === "number")
                    object.agreeNum = options.longs === String ? String(message.agreeNum) : message.agreeNum;
                else
                    object.agreeNum = options.longs === String ? $util.Long.prototype.toString.call(message.agreeNum) : options.longs === Number ? new $util.LongBits(message.agreeNum.low >>> 0, message.agreeNum.high >>> 0).toNumber() : message.agreeNum;
            if (message.hasAgree != null && message.hasOwnProperty("hasAgree"))
                object.hasAgree = message.hasAgree;
            if (message.agreeType != null && message.hasOwnProperty("agreeType"))
                object.agreeType = message.agreeType;
            if (message.disagreeNum != null && message.hasOwnProperty("disagreeNum"))
                if (typeof message.disagreeNum === "number")
                    object.disagreeNum = options.longs === String ? String(message.disagreeNum) : message.disagreeNum;
                else
                    object.disagreeNum = options.longs === String ? $util.Long.prototype.toString.call(message.disagreeNum) : options.longs === Number ? new $util.LongBits(message.disagreeNum.low >>> 0, message.disagreeNum.high >>> 0).toNumber() : message.disagreeNum;
            if (message.diffAgreeNum != null && message.hasOwnProperty("diffAgreeNum"))
                if (typeof message.diffAgreeNum === "number")
                    object.diffAgreeNum = options.longs === String ? String(message.diffAgreeNum) : message.diffAgreeNum;
                else
                    object.diffAgreeNum = options.longs === String ? $util.Long.prototype.toString.call(message.diffAgreeNum) : options.longs === Number ? new $util.LongBits(message.diffAgreeNum.low >>> 0, message.diffAgreeNum.high >>> 0).toNumber() : message.diffAgreeNum;
            return object;
        };

        /**
         * Converts this Agree to JSON.
         * @function toJSON
         * @memberof tieba.Agree
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Agree.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Agree
         * @function getTypeUrl
         * @memberof tieba.Agree
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Agree.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Agree";
        };

        return Agree;
    })();

    tieba.OriginThreadInfo = (function() {

        /**
         * Properties of an OriginThreadInfo.
         * @memberof tieba
         * @interface IOriginThreadInfo
         * @property {string|null} [title] OriginThreadInfo title
         * @property {Array.<tieba.IMedia>|null} [media] OriginThreadInfo media
         * @property {Array.<tieba.IAbstract>|null} [_abstract] OriginThreadInfo _abstract
         * @property {string|null} [fname] OriginThreadInfo fname
         * @property {string|null} [tid] OriginThreadInfo tid
         * @property {tieba.IAlaLiveInfo|null} [alaInfo] OriginThreadInfo alaInfo
         * @property {number|Long|null} [fid] OriginThreadInfo fid
         * @property {number|null} [threadType] OriginThreadInfo threadType
         * @property {number|null} [isDeleted] OriginThreadInfo isDeleted
         * @property {number|null} [isUgc] OriginThreadInfo isUgc
         * @property {tieba.IBaijiahao|null} [oriUgcInfo] OriginThreadInfo oriUgcInfo
         * @property {Array.<tieba.IVoice>|null} [voiceInfo] OriginThreadInfo voiceInfo
         * @property {tieba.IVideoInfo|null} [videoInfo] OriginThreadInfo videoInfo
         * @property {Array.<tieba.IPbContent>|null} [content] OriginThreadInfo content
         * @property {number|null} [isNewStyle] OriginThreadInfo isNewStyle
         * @property {number|null} [replyNum] OriginThreadInfo replyNum
         * @property {tieba.IUser|null} [author] OriginThreadInfo author
         * @property {tieba.IAgree|null} [agree] OriginThreadInfo agree
         * @property {number|null} [sharedNum] OriginThreadInfo sharedNum
         * @property {tieba.IPollInfo|null} [pollInfo] OriginThreadInfo pollInfo
         * @property {tieba.IItem|null} [item] OriginThreadInfo item
         * @property {Array.<tieba.IHeadItem>|null} [itemStar] OriginThreadInfo itemStar
         * @property {Array.<tieba.IPbLinkInfo>|null} [pbLinkInfo] OriginThreadInfo pbLinkInfo
         * @property {number|Long|null} [pid] OriginThreadInfo pid
         * @property {number|null} [goodTypes] OriginThreadInfo goodTypes
         * @property {number|null} [topTypes] OriginThreadInfo topTypes
         * @property {number|null} [isFrsMask] OriginThreadInfo isFrsMask
         */

        /**
         * Constructs a new OriginThreadInfo.
         * @memberof tieba
         * @classdesc Represents an OriginThreadInfo.
         * @implements IOriginThreadInfo
         * @constructor
         * @param {tieba.IOriginThreadInfo=} [properties] Properties to set
         */
        function OriginThreadInfo(properties) {
            this.media = [];
            this._abstract = [];
            this.voiceInfo = [];
            this.content = [];
            this.itemStar = [];
            this.pbLinkInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OriginThreadInfo title.
         * @member {string} title
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.title = "";

        /**
         * OriginThreadInfo media.
         * @member {Array.<tieba.IMedia>} media
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.media = $util.emptyArray;

        /**
         * OriginThreadInfo _abstract.
         * @member {Array.<tieba.IAbstract>} _abstract
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype._abstract = $util.emptyArray;

        /**
         * OriginThreadInfo fname.
         * @member {string} fname
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.fname = "";

        /**
         * OriginThreadInfo tid.
         * @member {string} tid
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.tid = "";

        /**
         * OriginThreadInfo alaInfo.
         * @member {tieba.IAlaLiveInfo|null|undefined} alaInfo
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.alaInfo = null;

        /**
         * OriginThreadInfo fid.
         * @member {number|Long} fid
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.fid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OriginThreadInfo threadType.
         * @member {number} threadType
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.threadType = 0;

        /**
         * OriginThreadInfo isDeleted.
         * @member {number} isDeleted
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.isDeleted = 0;

        /**
         * OriginThreadInfo isUgc.
         * @member {number} isUgc
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.isUgc = 0;

        /**
         * OriginThreadInfo oriUgcInfo.
         * @member {tieba.IBaijiahao|null|undefined} oriUgcInfo
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.oriUgcInfo = null;

        /**
         * OriginThreadInfo voiceInfo.
         * @member {Array.<tieba.IVoice>} voiceInfo
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.voiceInfo = $util.emptyArray;

        /**
         * OriginThreadInfo videoInfo.
         * @member {tieba.IVideoInfo|null|undefined} videoInfo
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.videoInfo = null;

        /**
         * OriginThreadInfo content.
         * @member {Array.<tieba.IPbContent>} content
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.content = $util.emptyArray;

        /**
         * OriginThreadInfo isNewStyle.
         * @member {number} isNewStyle
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.isNewStyle = 0;

        /**
         * OriginThreadInfo replyNum.
         * @member {number} replyNum
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.replyNum = 0;

        /**
         * OriginThreadInfo author.
         * @member {tieba.IUser|null|undefined} author
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.author = null;

        /**
         * OriginThreadInfo agree.
         * @member {tieba.IAgree|null|undefined} agree
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.agree = null;

        /**
         * OriginThreadInfo sharedNum.
         * @member {number} sharedNum
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.sharedNum = 0;

        /**
         * OriginThreadInfo pollInfo.
         * @member {tieba.IPollInfo|null|undefined} pollInfo
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.pollInfo = null;

        /**
         * OriginThreadInfo item.
         * @member {tieba.IItem|null|undefined} item
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.item = null;

        /**
         * OriginThreadInfo itemStar.
         * @member {Array.<tieba.IHeadItem>} itemStar
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.itemStar = $util.emptyArray;

        /**
         * OriginThreadInfo pbLinkInfo.
         * @member {Array.<tieba.IPbLinkInfo>} pbLinkInfo
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.pbLinkInfo = $util.emptyArray;

        /**
         * OriginThreadInfo pid.
         * @member {number|Long} pid
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.pid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OriginThreadInfo goodTypes.
         * @member {number} goodTypes
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.goodTypes = 0;

        /**
         * OriginThreadInfo topTypes.
         * @member {number} topTypes
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.topTypes = 0;

        /**
         * OriginThreadInfo isFrsMask.
         * @member {number} isFrsMask
         * @memberof tieba.OriginThreadInfo
         * @instance
         */
        OriginThreadInfo.prototype.isFrsMask = 0;

        /**
         * Creates a new OriginThreadInfo instance using the specified properties.
         * @function create
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {tieba.IOriginThreadInfo=} [properties] Properties to set
         * @returns {tieba.OriginThreadInfo} OriginThreadInfo instance
         */
        OriginThreadInfo.create = function create(properties) {
            return new OriginThreadInfo(properties);
        };

        /**
         * Encodes the specified OriginThreadInfo message. Does not implicitly {@link tieba.OriginThreadInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {tieba.IOriginThreadInfo} message OriginThreadInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OriginThreadInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.media != null && message.media.length)
                for (let i = 0; i < message.media.length; ++i)
                    $root.tieba.Media.encode(message.media[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message._abstract != null && message._abstract.length)
                for (let i = 0; i < message._abstract.length; ++i)
                    $root.tieba.Abstract.encode(message._abstract[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.fname != null && Object.hasOwnProperty.call(message, "fname"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fname);
            if (message.tid != null && Object.hasOwnProperty.call(message, "tid"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.tid);
            if (message.alaInfo != null && Object.hasOwnProperty.call(message, "alaInfo"))
                $root.tieba.AlaLiveInfo.encode(message.alaInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.fid != null && Object.hasOwnProperty.call(message, "fid"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fid);
            if (message.threadType != null && Object.hasOwnProperty.call(message, "threadType"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.threadType);
            if (message.isDeleted != null && Object.hasOwnProperty.call(message, "isDeleted"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.isDeleted);
            if (message.isUgc != null && Object.hasOwnProperty.call(message, "isUgc"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.isUgc);
            if (message.oriUgcInfo != null && Object.hasOwnProperty.call(message, "oriUgcInfo"))
                $root.tieba.Baijiahao.encode(message.oriUgcInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.voiceInfo != null && message.voiceInfo.length)
                for (let i = 0; i < message.voiceInfo.length; ++i)
                    $root.tieba.Voice.encode(message.voiceInfo[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.videoInfo != null && Object.hasOwnProperty.call(message, "videoInfo"))
                $root.tieba.VideoInfo.encode(message.videoInfo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.content != null && message.content.length)
                for (let i = 0; i < message.content.length; ++i)
                    $root.tieba.PbContent.encode(message.content[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.isNewStyle != null && Object.hasOwnProperty.call(message, "isNewStyle"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.isNewStyle);
            if (message.replyNum != null && Object.hasOwnProperty.call(message, "replyNum"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.replyNum);
            if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                $root.tieba.User.encode(message.author, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.agree != null && Object.hasOwnProperty.call(message, "agree"))
                $root.tieba.Agree.encode(message.agree, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.sharedNum != null && Object.hasOwnProperty.call(message, "sharedNum"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.sharedNum);
            if (message.pollInfo != null && Object.hasOwnProperty.call(message, "pollInfo"))
                $root.tieba.PollInfo.encode(message.pollInfo, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.tieba.Item.encode(message.item, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.itemStar != null && message.itemStar.length)
                for (let i = 0; i < message.itemStar.length; ++i)
                    $root.tieba.HeadItem.encode(message.itemStar[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.pbLinkInfo != null && message.pbLinkInfo.length)
                for (let i = 0; i < message.pbLinkInfo.length; ++i)
                    $root.tieba.PbLinkInfo.encode(message.pbLinkInfo[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.pid != null && Object.hasOwnProperty.call(message, "pid"))
                writer.uint32(/* id 25, wireType 0 =*/200).int64(message.pid);
            if (message.goodTypes != null && Object.hasOwnProperty.call(message, "goodTypes"))
                writer.uint32(/* id 26, wireType 0 =*/208).int32(message.goodTypes);
            if (message.topTypes != null && Object.hasOwnProperty.call(message, "topTypes"))
                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.topTypes);
            if (message.isFrsMask != null && Object.hasOwnProperty.call(message, "isFrsMask"))
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.isFrsMask);
            return writer;
        };

        /**
         * Encodes the specified OriginThreadInfo message, length delimited. Does not implicitly {@link tieba.OriginThreadInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {tieba.IOriginThreadInfo} message OriginThreadInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OriginThreadInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OriginThreadInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.OriginThreadInfo} OriginThreadInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OriginThreadInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.OriginThreadInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.title = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.media && message.media.length))
                            message.media = [];
                        message.media.push($root.tieba.Media.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message._abstract && message._abstract.length))
                            message._abstract = [];
                        message._abstract.push($root.tieba.Abstract.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.fname = reader.string();
                        break;
                    }
                case 5: {
                        message.tid = reader.string();
                        break;
                    }
                case 6: {
                        message.alaInfo = $root.tieba.AlaLiveInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.fid = reader.int64();
                        break;
                    }
                case 8: {
                        message.threadType = reader.int32();
                        break;
                    }
                case 9: {
                        message.isDeleted = reader.int32();
                        break;
                    }
                case 10: {
                        message.isUgc = reader.int32();
                        break;
                    }
                case 11: {
                        message.oriUgcInfo = $root.tieba.Baijiahao.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        if (!(message.voiceInfo && message.voiceInfo.length))
                            message.voiceInfo = [];
                        message.voiceInfo.push($root.tieba.Voice.decode(reader, reader.uint32()));
                        break;
                    }
                case 13: {
                        message.videoInfo = $root.tieba.VideoInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        if (!(message.content && message.content.length))
                            message.content = [];
                        message.content.push($root.tieba.PbContent.decode(reader, reader.uint32()));
                        break;
                    }
                case 15: {
                        message.isNewStyle = reader.int32();
                        break;
                    }
                case 16: {
                        message.replyNum = reader.int32();
                        break;
                    }
                case 18: {
                        message.author = $root.tieba.User.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.agree = $root.tieba.Agree.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.sharedNum = reader.int32();
                        break;
                    }
                case 21: {
                        message.pollInfo = $root.tieba.PollInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.item = $root.tieba.Item.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        if (!(message.itemStar && message.itemStar.length))
                            message.itemStar = [];
                        message.itemStar.push($root.tieba.HeadItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 24: {
                        if (!(message.pbLinkInfo && message.pbLinkInfo.length))
                            message.pbLinkInfo = [];
                        message.pbLinkInfo.push($root.tieba.PbLinkInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 25: {
                        message.pid = reader.int64();
                        break;
                    }
                case 26: {
                        message.goodTypes = reader.int32();
                        break;
                    }
                case 27: {
                        message.topTypes = reader.int32();
                        break;
                    }
                case 28: {
                        message.isFrsMask = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OriginThreadInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.OriginThreadInfo} OriginThreadInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OriginThreadInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OriginThreadInfo message.
         * @function verify
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OriginThreadInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.media != null && message.hasOwnProperty("media")) {
                if (!Array.isArray(message.media))
                    return "media: array expected";
                for (let i = 0; i < message.media.length; ++i) {
                    let error = $root.tieba.Media.verify(message.media[i]);
                    if (error)
                        return "media." + error;
                }
            }
            if (message._abstract != null && message.hasOwnProperty("_abstract")) {
                if (!Array.isArray(message._abstract))
                    return "_abstract: array expected";
                for (let i = 0; i < message._abstract.length; ++i) {
                    let error = $root.tieba.Abstract.verify(message._abstract[i]);
                    if (error)
                        return "_abstract." + error;
                }
            }
            if (message.fname != null && message.hasOwnProperty("fname"))
                if (!$util.isString(message.fname))
                    return "fname: string expected";
            if (message.tid != null && message.hasOwnProperty("tid"))
                if (!$util.isString(message.tid))
                    return "tid: string expected";
            if (message.alaInfo != null && message.hasOwnProperty("alaInfo")) {
                let error = $root.tieba.AlaLiveInfo.verify(message.alaInfo);
                if (error)
                    return "alaInfo." + error;
            }
            if (message.fid != null && message.hasOwnProperty("fid"))
                if (!$util.isInteger(message.fid) && !(message.fid && $util.isInteger(message.fid.low) && $util.isInteger(message.fid.high)))
                    return "fid: integer|Long expected";
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                if (!$util.isInteger(message.threadType))
                    return "threadType: integer expected";
            if (message.isDeleted != null && message.hasOwnProperty("isDeleted"))
                if (!$util.isInteger(message.isDeleted))
                    return "isDeleted: integer expected";
            if (message.isUgc != null && message.hasOwnProperty("isUgc"))
                if (!$util.isInteger(message.isUgc))
                    return "isUgc: integer expected";
            if (message.oriUgcInfo != null && message.hasOwnProperty("oriUgcInfo")) {
                let error = $root.tieba.Baijiahao.verify(message.oriUgcInfo);
                if (error)
                    return "oriUgcInfo." + error;
            }
            if (message.voiceInfo != null && message.hasOwnProperty("voiceInfo")) {
                if (!Array.isArray(message.voiceInfo))
                    return "voiceInfo: array expected";
                for (let i = 0; i < message.voiceInfo.length; ++i) {
                    let error = $root.tieba.Voice.verify(message.voiceInfo[i]);
                    if (error)
                        return "voiceInfo." + error;
                }
            }
            if (message.videoInfo != null && message.hasOwnProperty("videoInfo")) {
                let error = $root.tieba.VideoInfo.verify(message.videoInfo);
                if (error)
                    return "videoInfo." + error;
            }
            if (message.content != null && message.hasOwnProperty("content")) {
                if (!Array.isArray(message.content))
                    return "content: array expected";
                for (let i = 0; i < message.content.length; ++i) {
                    let error = $root.tieba.PbContent.verify(message.content[i]);
                    if (error)
                        return "content." + error;
                }
            }
            if (message.isNewStyle != null && message.hasOwnProperty("isNewStyle"))
                if (!$util.isInteger(message.isNewStyle))
                    return "isNewStyle: integer expected";
            if (message.replyNum != null && message.hasOwnProperty("replyNum"))
                if (!$util.isInteger(message.replyNum))
                    return "replyNum: integer expected";
            if (message.author != null && message.hasOwnProperty("author")) {
                let error = $root.tieba.User.verify(message.author);
                if (error)
                    return "author." + error;
            }
            if (message.agree != null && message.hasOwnProperty("agree")) {
                let error = $root.tieba.Agree.verify(message.agree);
                if (error)
                    return "agree." + error;
            }
            if (message.sharedNum != null && message.hasOwnProperty("sharedNum"))
                if (!$util.isInteger(message.sharedNum))
                    return "sharedNum: integer expected";
            if (message.pollInfo != null && message.hasOwnProperty("pollInfo")) {
                let error = $root.tieba.PollInfo.verify(message.pollInfo);
                if (error)
                    return "pollInfo." + error;
            }
            if (message.item != null && message.hasOwnProperty("item")) {
                let error = $root.tieba.Item.verify(message.item);
                if (error)
                    return "item." + error;
            }
            if (message.itemStar != null && message.hasOwnProperty("itemStar")) {
                if (!Array.isArray(message.itemStar))
                    return "itemStar: array expected";
                for (let i = 0; i < message.itemStar.length; ++i) {
                    let error = $root.tieba.HeadItem.verify(message.itemStar[i]);
                    if (error)
                        return "itemStar." + error;
                }
            }
            if (message.pbLinkInfo != null && message.hasOwnProperty("pbLinkInfo")) {
                if (!Array.isArray(message.pbLinkInfo))
                    return "pbLinkInfo: array expected";
                for (let i = 0; i < message.pbLinkInfo.length; ++i) {
                    let error = $root.tieba.PbLinkInfo.verify(message.pbLinkInfo[i]);
                    if (error)
                        return "pbLinkInfo." + error;
                }
            }
            if (message.pid != null && message.hasOwnProperty("pid"))
                if (!$util.isInteger(message.pid) && !(message.pid && $util.isInteger(message.pid.low) && $util.isInteger(message.pid.high)))
                    return "pid: integer|Long expected";
            if (message.goodTypes != null && message.hasOwnProperty("goodTypes"))
                if (!$util.isInteger(message.goodTypes))
                    return "goodTypes: integer expected";
            if (message.topTypes != null && message.hasOwnProperty("topTypes"))
                if (!$util.isInteger(message.topTypes))
                    return "topTypes: integer expected";
            if (message.isFrsMask != null && message.hasOwnProperty("isFrsMask"))
                if (!$util.isInteger(message.isFrsMask))
                    return "isFrsMask: integer expected";
            return null;
        };

        /**
         * Creates an OriginThreadInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.OriginThreadInfo} OriginThreadInfo
         */
        OriginThreadInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.OriginThreadInfo)
                return object;
            let message = new $root.tieba.OriginThreadInfo();
            if (object.title != null)
                message.title = String(object.title);
            if (object.media) {
                if (!Array.isArray(object.media))
                    throw TypeError(".tieba.OriginThreadInfo.media: array expected");
                message.media = [];
                for (let i = 0; i < object.media.length; ++i) {
                    if (typeof object.media[i] !== "object")
                        throw TypeError(".tieba.OriginThreadInfo.media: object expected");
                    message.media[i] = $root.tieba.Media.fromObject(object.media[i]);
                }
            }
            if (object._abstract) {
                if (!Array.isArray(object._abstract))
                    throw TypeError(".tieba.OriginThreadInfo._abstract: array expected");
                message._abstract = [];
                for (let i = 0; i < object._abstract.length; ++i) {
                    if (typeof object._abstract[i] !== "object")
                        throw TypeError(".tieba.OriginThreadInfo._abstract: object expected");
                    message._abstract[i] = $root.tieba.Abstract.fromObject(object._abstract[i]);
                }
            }
            if (object.fname != null)
                message.fname = String(object.fname);
            if (object.tid != null)
                message.tid = String(object.tid);
            if (object.alaInfo != null) {
                if (typeof object.alaInfo !== "object")
                    throw TypeError(".tieba.OriginThreadInfo.alaInfo: object expected");
                message.alaInfo = $root.tieba.AlaLiveInfo.fromObject(object.alaInfo);
            }
            if (object.fid != null)
                if ($util.Long)
                    (message.fid = $util.Long.fromValue(object.fid)).unsigned = false;
                else if (typeof object.fid === "string")
                    message.fid = parseInt(object.fid, 10);
                else if (typeof object.fid === "number")
                    message.fid = object.fid;
                else if (typeof object.fid === "object")
                    message.fid = new $util.LongBits(object.fid.low >>> 0, object.fid.high >>> 0).toNumber();
            if (object.threadType != null)
                message.threadType = object.threadType | 0;
            if (object.isDeleted != null)
                message.isDeleted = object.isDeleted | 0;
            if (object.isUgc != null)
                message.isUgc = object.isUgc | 0;
            if (object.oriUgcInfo != null) {
                if (typeof object.oriUgcInfo !== "object")
                    throw TypeError(".tieba.OriginThreadInfo.oriUgcInfo: object expected");
                message.oriUgcInfo = $root.tieba.Baijiahao.fromObject(object.oriUgcInfo);
            }
            if (object.voiceInfo) {
                if (!Array.isArray(object.voiceInfo))
                    throw TypeError(".tieba.OriginThreadInfo.voiceInfo: array expected");
                message.voiceInfo = [];
                for (let i = 0; i < object.voiceInfo.length; ++i) {
                    if (typeof object.voiceInfo[i] !== "object")
                        throw TypeError(".tieba.OriginThreadInfo.voiceInfo: object expected");
                    message.voiceInfo[i] = $root.tieba.Voice.fromObject(object.voiceInfo[i]);
                }
            }
            if (object.videoInfo != null) {
                if (typeof object.videoInfo !== "object")
                    throw TypeError(".tieba.OriginThreadInfo.videoInfo: object expected");
                message.videoInfo = $root.tieba.VideoInfo.fromObject(object.videoInfo);
            }
            if (object.content) {
                if (!Array.isArray(object.content))
                    throw TypeError(".tieba.OriginThreadInfo.content: array expected");
                message.content = [];
                for (let i = 0; i < object.content.length; ++i) {
                    if (typeof object.content[i] !== "object")
                        throw TypeError(".tieba.OriginThreadInfo.content: object expected");
                    message.content[i] = $root.tieba.PbContent.fromObject(object.content[i]);
                }
            }
            if (object.isNewStyle != null)
                message.isNewStyle = object.isNewStyle | 0;
            if (object.replyNum != null)
                message.replyNum = object.replyNum | 0;
            if (object.author != null) {
                if (typeof object.author !== "object")
                    throw TypeError(".tieba.OriginThreadInfo.author: object expected");
                message.author = $root.tieba.User.fromObject(object.author);
            }
            if (object.agree != null) {
                if (typeof object.agree !== "object")
                    throw TypeError(".tieba.OriginThreadInfo.agree: object expected");
                message.agree = $root.tieba.Agree.fromObject(object.agree);
            }
            if (object.sharedNum != null)
                message.sharedNum = object.sharedNum | 0;
            if (object.pollInfo != null) {
                if (typeof object.pollInfo !== "object")
                    throw TypeError(".tieba.OriginThreadInfo.pollInfo: object expected");
                message.pollInfo = $root.tieba.PollInfo.fromObject(object.pollInfo);
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".tieba.OriginThreadInfo.item: object expected");
                message.item = $root.tieba.Item.fromObject(object.item);
            }
            if (object.itemStar) {
                if (!Array.isArray(object.itemStar))
                    throw TypeError(".tieba.OriginThreadInfo.itemStar: array expected");
                message.itemStar = [];
                for (let i = 0; i < object.itemStar.length; ++i) {
                    if (typeof object.itemStar[i] !== "object")
                        throw TypeError(".tieba.OriginThreadInfo.itemStar: object expected");
                    message.itemStar[i] = $root.tieba.HeadItem.fromObject(object.itemStar[i]);
                }
            }
            if (object.pbLinkInfo) {
                if (!Array.isArray(object.pbLinkInfo))
                    throw TypeError(".tieba.OriginThreadInfo.pbLinkInfo: array expected");
                message.pbLinkInfo = [];
                for (let i = 0; i < object.pbLinkInfo.length; ++i) {
                    if (typeof object.pbLinkInfo[i] !== "object")
                        throw TypeError(".tieba.OriginThreadInfo.pbLinkInfo: object expected");
                    message.pbLinkInfo[i] = $root.tieba.PbLinkInfo.fromObject(object.pbLinkInfo[i]);
                }
            }
            if (object.pid != null)
                if ($util.Long)
                    (message.pid = $util.Long.fromValue(object.pid)).unsigned = false;
                else if (typeof object.pid === "string")
                    message.pid = parseInt(object.pid, 10);
                else if (typeof object.pid === "number")
                    message.pid = object.pid;
                else if (typeof object.pid === "object")
                    message.pid = new $util.LongBits(object.pid.low >>> 0, object.pid.high >>> 0).toNumber();
            if (object.goodTypes != null)
                message.goodTypes = object.goodTypes | 0;
            if (object.topTypes != null)
                message.topTypes = object.topTypes | 0;
            if (object.isFrsMask != null)
                message.isFrsMask = object.isFrsMask | 0;
            return message;
        };

        /**
         * Creates a plain object from an OriginThreadInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {tieba.OriginThreadInfo} message OriginThreadInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OriginThreadInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.media = [];
                object._abstract = [];
                object.voiceInfo = [];
                object.content = [];
                object.itemStar = [];
                object.pbLinkInfo = [];
            }
            if (options.defaults) {
                object.title = "";
                object.fname = "";
                object.tid = "";
                object.alaInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fid = options.longs === String ? "0" : 0;
                object.threadType = 0;
                object.isDeleted = 0;
                object.isUgc = 0;
                object.oriUgcInfo = null;
                object.videoInfo = null;
                object.isNewStyle = 0;
                object.replyNum = 0;
                object.author = null;
                object.agree = null;
                object.sharedNum = 0;
                object.pollInfo = null;
                object.item = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.pid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pid = options.longs === String ? "0" : 0;
                object.goodTypes = 0;
                object.topTypes = 0;
                object.isFrsMask = 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.media && message.media.length) {
                object.media = [];
                for (let j = 0; j < message.media.length; ++j)
                    object.media[j] = $root.tieba.Media.toObject(message.media[j], options);
            }
            if (message._abstract && message._abstract.length) {
                object._abstract = [];
                for (let j = 0; j < message._abstract.length; ++j)
                    object._abstract[j] = $root.tieba.Abstract.toObject(message._abstract[j], options);
            }
            if (message.fname != null && message.hasOwnProperty("fname"))
                object.fname = message.fname;
            if (message.tid != null && message.hasOwnProperty("tid"))
                object.tid = message.tid;
            if (message.alaInfo != null && message.hasOwnProperty("alaInfo"))
                object.alaInfo = $root.tieba.AlaLiveInfo.toObject(message.alaInfo, options);
            if (message.fid != null && message.hasOwnProperty("fid"))
                if (typeof message.fid === "number")
                    object.fid = options.longs === String ? String(message.fid) : message.fid;
                else
                    object.fid = options.longs === String ? $util.Long.prototype.toString.call(message.fid) : options.longs === Number ? new $util.LongBits(message.fid.low >>> 0, message.fid.high >>> 0).toNumber() : message.fid;
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                object.threadType = message.threadType;
            if (message.isDeleted != null && message.hasOwnProperty("isDeleted"))
                object.isDeleted = message.isDeleted;
            if (message.isUgc != null && message.hasOwnProperty("isUgc"))
                object.isUgc = message.isUgc;
            if (message.oriUgcInfo != null && message.hasOwnProperty("oriUgcInfo"))
                object.oriUgcInfo = $root.tieba.Baijiahao.toObject(message.oriUgcInfo, options);
            if (message.voiceInfo && message.voiceInfo.length) {
                object.voiceInfo = [];
                for (let j = 0; j < message.voiceInfo.length; ++j)
                    object.voiceInfo[j] = $root.tieba.Voice.toObject(message.voiceInfo[j], options);
            }
            if (message.videoInfo != null && message.hasOwnProperty("videoInfo"))
                object.videoInfo = $root.tieba.VideoInfo.toObject(message.videoInfo, options);
            if (message.content && message.content.length) {
                object.content = [];
                for (let j = 0; j < message.content.length; ++j)
                    object.content[j] = $root.tieba.PbContent.toObject(message.content[j], options);
            }
            if (message.isNewStyle != null && message.hasOwnProperty("isNewStyle"))
                object.isNewStyle = message.isNewStyle;
            if (message.replyNum != null && message.hasOwnProperty("replyNum"))
                object.replyNum = message.replyNum;
            if (message.author != null && message.hasOwnProperty("author"))
                object.author = $root.tieba.User.toObject(message.author, options);
            if (message.agree != null && message.hasOwnProperty("agree"))
                object.agree = $root.tieba.Agree.toObject(message.agree, options);
            if (message.sharedNum != null && message.hasOwnProperty("sharedNum"))
                object.sharedNum = message.sharedNum;
            if (message.pollInfo != null && message.hasOwnProperty("pollInfo"))
                object.pollInfo = $root.tieba.PollInfo.toObject(message.pollInfo, options);
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.tieba.Item.toObject(message.item, options);
            if (message.itemStar && message.itemStar.length) {
                object.itemStar = [];
                for (let j = 0; j < message.itemStar.length; ++j)
                    object.itemStar[j] = $root.tieba.HeadItem.toObject(message.itemStar[j], options);
            }
            if (message.pbLinkInfo && message.pbLinkInfo.length) {
                object.pbLinkInfo = [];
                for (let j = 0; j < message.pbLinkInfo.length; ++j)
                    object.pbLinkInfo[j] = $root.tieba.PbLinkInfo.toObject(message.pbLinkInfo[j], options);
            }
            if (message.pid != null && message.hasOwnProperty("pid"))
                if (typeof message.pid === "number")
                    object.pid = options.longs === String ? String(message.pid) : message.pid;
                else
                    object.pid = options.longs === String ? $util.Long.prototype.toString.call(message.pid) : options.longs === Number ? new $util.LongBits(message.pid.low >>> 0, message.pid.high >>> 0).toNumber() : message.pid;
            if (message.goodTypes != null && message.hasOwnProperty("goodTypes"))
                object.goodTypes = message.goodTypes;
            if (message.topTypes != null && message.hasOwnProperty("topTypes"))
                object.topTypes = message.topTypes;
            if (message.isFrsMask != null && message.hasOwnProperty("isFrsMask"))
                object.isFrsMask = message.isFrsMask;
            return object;
        };

        /**
         * Converts this OriginThreadInfo to JSON.
         * @function toJSON
         * @memberof tieba.OriginThreadInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OriginThreadInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OriginThreadInfo
         * @function getTypeUrl
         * @memberof tieba.OriginThreadInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OriginThreadInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.OriginThreadInfo";
        };

        return OriginThreadInfo;
    })();

    tieba.AlaLiveInfo = (function() {

        /**
         * Properties of an AlaLiveInfo.
         * @memberof tieba
         * @interface IAlaLiveInfo
         * @property {number|Long|null} [liveId] AlaLiveInfo liveId
         * @property {string|null} [cover] AlaLiveInfo cover
         * @property {string|null} [sessionId] AlaLiveInfo sessionId
         * @property {string|null} [rtmpUrl] AlaLiveInfo rtmpUrl
         * @property {string|null} [hlsUrl] AlaLiveInfo hlsUrl
         * @property {number|Long|null} [groupId] AlaLiveInfo groupId
         * @property {string|null} [mediaUrl] AlaLiveInfo mediaUrl
         * @property {string|null} [mediaPic] AlaLiveInfo mediaPic
         * @property {string|null} [mediaId] AlaLiveInfo mediaId
         * @property {string|null} [mediaSubtitle] AlaLiveInfo mediaSubtitle
         * @property {string|null} [description] AlaLiveInfo description
         * @property {tieba.IAlaUserInfo|null} [userInfo] AlaLiveInfo userInfo
         * @property {number|null} [duration] AlaLiveInfo duration
         * @property {number|null} [audienceCount] AlaLiveInfo audienceCount
         * @property {number|null} [liveType] AlaLiveInfo liveType
         * @property {number|null} [screenDirection] AlaLiveInfo screenDirection
         * @property {string|null} [labelName] AlaLiveInfo labelName
         * @property {number|null} [liveStatus] AlaLiveInfo liveStatus
         * @property {tieba.IAlaShareInfo|null} [shareInfo] AlaLiveInfo shareInfo
         * @property {number|Long|null} [distance] AlaLiveInfo distance
         * @property {string|null} [thirdAppId] AlaLiveInfo thirdAppId
         * @property {number|Long|null} [threadId] AlaLiveInfo threadId
         * @property {Array.<tieba.IAlaStageDislikeInfo>|null} [stageDislikeInfo] AlaLiveInfo stageDislikeInfo
         * @property {tieba.IAlaCoverLabel|null} [label] AlaLiveInfo label
         * @property {tieba.IAlaChallengeInfo|null} [challengeInfo] AlaLiveInfo challengeInfo
         * @property {number|null} [frsTopliveType] AlaLiveInfo frsTopliveType
         * @property {string|null} [frsToplivePic] AlaLiveInfo frsToplivePic
         * @property {number|null} [frsTopliveForce] AlaLiveInfo frsTopliveForce
         * @property {number|null} [liveFrom] AlaLiveInfo liveFrom
         * @property {string|null} [thirdRoomId] AlaLiveInfo thirdRoomId
         * @property {string|null} [routerType] AlaLiveInfo routerType
         * @property {string|null} [thirdLiveType] AlaLiveInfo thirdLiveType
         * @property {string|null} [firstHeadline] AlaLiveInfo firstHeadline
         * @property {string|null} [secondHeadline] AlaLiveInfo secondHeadline
         * @property {number|null} [pbDisplayType] AlaLiveInfo pbDisplayType
         * @property {string|null} [recomReason] AlaLiveInfo recomReason
         * @property {number|null} [openRecomReason] AlaLiveInfo openRecomReason
         * @property {number|null} [openRecomLocation] AlaLiveInfo openRecomLocation
         * @property {number|null} [openRecomFans] AlaLiveInfo openRecomFans
         * @property {number|null} [openRecomDuration] AlaLiveInfo openRecomDuration
         * @property {Array.<tieba.IDislikeInfo>|null} [dislikeInfo] AlaLiveInfo dislikeInfo
         * @property {number|Long|null} [roomId] AlaLiveInfo roomId
         * @property {number|null} [roomStatus] AlaLiveInfo roomStatus
         * @property {string|null} [roomName] AlaLiveInfo roomName
         * @property {string|null} [forumUserLiveMsg] AlaLiveInfo forumUserLiveMsg
         * @property {string|null} [coverWide] AlaLiveInfo coverWide
         * @property {tieba.IYyExt|null} [yyExt] AlaLiveInfo yyExt
         */

        /**
         * Constructs a new AlaLiveInfo.
         * @memberof tieba
         * @classdesc Represents an AlaLiveInfo.
         * @implements IAlaLiveInfo
         * @constructor
         * @param {tieba.IAlaLiveInfo=} [properties] Properties to set
         */
        function AlaLiveInfo(properties) {
            this.stageDislikeInfo = [];
            this.dislikeInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AlaLiveInfo liveId.
         * @member {number|Long} liveId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.liveId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaLiveInfo cover.
         * @member {string} cover
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.cover = "";

        /**
         * AlaLiveInfo sessionId.
         * @member {string} sessionId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.sessionId = "";

        /**
         * AlaLiveInfo rtmpUrl.
         * @member {string} rtmpUrl
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.rtmpUrl = "";

        /**
         * AlaLiveInfo hlsUrl.
         * @member {string} hlsUrl
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.hlsUrl = "";

        /**
         * AlaLiveInfo groupId.
         * @member {number|Long} groupId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaLiveInfo mediaUrl.
         * @member {string} mediaUrl
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.mediaUrl = "";

        /**
         * AlaLiveInfo mediaPic.
         * @member {string} mediaPic
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.mediaPic = "";

        /**
         * AlaLiveInfo mediaId.
         * @member {string} mediaId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.mediaId = "";

        /**
         * AlaLiveInfo mediaSubtitle.
         * @member {string} mediaSubtitle
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.mediaSubtitle = "";

        /**
         * AlaLiveInfo description.
         * @member {string} description
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.description = "";

        /**
         * AlaLiveInfo userInfo.
         * @member {tieba.IAlaUserInfo|null|undefined} userInfo
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.userInfo = null;

        /**
         * AlaLiveInfo duration.
         * @member {number} duration
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.duration = 0;

        /**
         * AlaLiveInfo audienceCount.
         * @member {number} audienceCount
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.audienceCount = 0;

        /**
         * AlaLiveInfo liveType.
         * @member {number} liveType
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.liveType = 0;

        /**
         * AlaLiveInfo screenDirection.
         * @member {number} screenDirection
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.screenDirection = 0;

        /**
         * AlaLiveInfo labelName.
         * @member {string} labelName
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.labelName = "";

        /**
         * AlaLiveInfo liveStatus.
         * @member {number} liveStatus
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.liveStatus = 0;

        /**
         * AlaLiveInfo shareInfo.
         * @member {tieba.IAlaShareInfo|null|undefined} shareInfo
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.shareInfo = null;

        /**
         * AlaLiveInfo distance.
         * @member {number|Long} distance
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.distance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaLiveInfo thirdAppId.
         * @member {string} thirdAppId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.thirdAppId = "";

        /**
         * AlaLiveInfo threadId.
         * @member {number|Long} threadId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.threadId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaLiveInfo stageDislikeInfo.
         * @member {Array.<tieba.IAlaStageDislikeInfo>} stageDislikeInfo
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.stageDislikeInfo = $util.emptyArray;

        /**
         * AlaLiveInfo label.
         * @member {tieba.IAlaCoverLabel|null|undefined} label
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.label = null;

        /**
         * AlaLiveInfo challengeInfo.
         * @member {tieba.IAlaChallengeInfo|null|undefined} challengeInfo
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.challengeInfo = null;

        /**
         * AlaLiveInfo frsTopliveType.
         * @member {number} frsTopliveType
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.frsTopliveType = 0;

        /**
         * AlaLiveInfo frsToplivePic.
         * @member {string} frsToplivePic
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.frsToplivePic = "";

        /**
         * AlaLiveInfo frsTopliveForce.
         * @member {number} frsTopliveForce
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.frsTopliveForce = 0;

        /**
         * AlaLiveInfo liveFrom.
         * @member {number} liveFrom
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.liveFrom = 0;

        /**
         * AlaLiveInfo thirdRoomId.
         * @member {string} thirdRoomId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.thirdRoomId = "";

        /**
         * AlaLiveInfo routerType.
         * @member {string} routerType
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.routerType = "";

        /**
         * AlaLiveInfo thirdLiveType.
         * @member {string} thirdLiveType
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.thirdLiveType = "";

        /**
         * AlaLiveInfo firstHeadline.
         * @member {string} firstHeadline
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.firstHeadline = "";

        /**
         * AlaLiveInfo secondHeadline.
         * @member {string} secondHeadline
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.secondHeadline = "";

        /**
         * AlaLiveInfo pbDisplayType.
         * @member {number} pbDisplayType
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.pbDisplayType = 0;

        /**
         * AlaLiveInfo recomReason.
         * @member {string} recomReason
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.recomReason = "";

        /**
         * AlaLiveInfo openRecomReason.
         * @member {number} openRecomReason
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.openRecomReason = 0;

        /**
         * AlaLiveInfo openRecomLocation.
         * @member {number} openRecomLocation
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.openRecomLocation = 0;

        /**
         * AlaLiveInfo openRecomFans.
         * @member {number} openRecomFans
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.openRecomFans = 0;

        /**
         * AlaLiveInfo openRecomDuration.
         * @member {number} openRecomDuration
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.openRecomDuration = 0;

        /**
         * AlaLiveInfo dislikeInfo.
         * @member {Array.<tieba.IDislikeInfo>} dislikeInfo
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.dislikeInfo = $util.emptyArray;

        /**
         * AlaLiveInfo roomId.
         * @member {number|Long} roomId
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.roomId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaLiveInfo roomStatus.
         * @member {number} roomStatus
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.roomStatus = 0;

        /**
         * AlaLiveInfo roomName.
         * @member {string} roomName
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.roomName = "";

        /**
         * AlaLiveInfo forumUserLiveMsg.
         * @member {string} forumUserLiveMsg
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.forumUserLiveMsg = "";

        /**
         * AlaLiveInfo coverWide.
         * @member {string} coverWide
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.coverWide = "";

        /**
         * AlaLiveInfo yyExt.
         * @member {tieba.IYyExt|null|undefined} yyExt
         * @memberof tieba.AlaLiveInfo
         * @instance
         */
        AlaLiveInfo.prototype.yyExt = null;

        /**
         * Creates a new AlaLiveInfo instance using the specified properties.
         * @function create
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {tieba.IAlaLiveInfo=} [properties] Properties to set
         * @returns {tieba.AlaLiveInfo} AlaLiveInfo instance
         */
        AlaLiveInfo.create = function create(properties) {
            return new AlaLiveInfo(properties);
        };

        /**
         * Encodes the specified AlaLiveInfo message. Does not implicitly {@link tieba.AlaLiveInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {tieba.IAlaLiveInfo} message AlaLiveInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaLiveInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.liveId != null && Object.hasOwnProperty.call(message, "liveId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.liveId);
            if (message.cover != null && Object.hasOwnProperty.call(message, "cover"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cover);
            if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sessionId);
            if (message.rtmpUrl != null && Object.hasOwnProperty.call(message, "rtmpUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.rtmpUrl);
            if (message.hlsUrl != null && Object.hasOwnProperty.call(message, "hlsUrl"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.hlsUrl);
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.groupId);
            if (message.mediaUrl != null && Object.hasOwnProperty.call(message, "mediaUrl"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.mediaUrl);
            if (message.mediaPic != null && Object.hasOwnProperty.call(message, "mediaPic"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.mediaPic);
            if (message.mediaId != null && Object.hasOwnProperty.call(message, "mediaId"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.mediaId);
            if (message.mediaSubtitle != null && Object.hasOwnProperty.call(message, "mediaSubtitle"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.mediaSubtitle);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.description);
            if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
                $root.tieba.AlaUserInfo.encode(message.userInfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.duration);
            if (message.audienceCount != null && Object.hasOwnProperty.call(message, "audienceCount"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.audienceCount);
            if (message.liveType != null && Object.hasOwnProperty.call(message, "liveType"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.liveType);
            if (message.screenDirection != null && Object.hasOwnProperty.call(message, "screenDirection"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.screenDirection);
            if (message.labelName != null && Object.hasOwnProperty.call(message, "labelName"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.labelName);
            if (message.liveStatus != null && Object.hasOwnProperty.call(message, "liveStatus"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.liveStatus);
            if (message.shareInfo != null && Object.hasOwnProperty.call(message, "shareInfo"))
                $root.tieba.AlaShareInfo.encode(message.shareInfo, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint64(message.distance);
            if (message.thirdAppId != null && Object.hasOwnProperty.call(message, "thirdAppId"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.thirdAppId);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.threadId);
            if (message.stageDislikeInfo != null && message.stageDislikeInfo.length)
                for (let i = 0; i < message.stageDislikeInfo.length; ++i)
                    $root.tieba.AlaStageDislikeInfo.encode(message.stageDislikeInfo[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                $root.tieba.AlaCoverLabel.encode(message.label, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.challengeInfo != null && Object.hasOwnProperty.call(message, "challengeInfo"))
                $root.tieba.AlaChallengeInfo.encode(message.challengeInfo, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.frsTopliveType != null && Object.hasOwnProperty.call(message, "frsTopliveType"))
                writer.uint32(/* id 26, wireType 0 =*/208).int32(message.frsTopliveType);
            if (message.frsToplivePic != null && Object.hasOwnProperty.call(message, "frsToplivePic"))
                writer.uint32(/* id 27, wireType 2 =*/218).string(message.frsToplivePic);
            if (message.frsTopliveForce != null && Object.hasOwnProperty.call(message, "frsTopliveForce"))
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.frsTopliveForce);
            if (message.liveFrom != null && Object.hasOwnProperty.call(message, "liveFrom"))
                writer.uint32(/* id 29, wireType 0 =*/232).int32(message.liveFrom);
            if (message.thirdRoomId != null && Object.hasOwnProperty.call(message, "thirdRoomId"))
                writer.uint32(/* id 31, wireType 2 =*/250).string(message.thirdRoomId);
            if (message.routerType != null && Object.hasOwnProperty.call(message, "routerType"))
                writer.uint32(/* id 32, wireType 2 =*/258).string(message.routerType);
            if (message.thirdLiveType != null && Object.hasOwnProperty.call(message, "thirdLiveType"))
                writer.uint32(/* id 33, wireType 2 =*/266).string(message.thirdLiveType);
            if (message.firstHeadline != null && Object.hasOwnProperty.call(message, "firstHeadline"))
                writer.uint32(/* id 34, wireType 2 =*/274).string(message.firstHeadline);
            if (message.secondHeadline != null && Object.hasOwnProperty.call(message, "secondHeadline"))
                writer.uint32(/* id 35, wireType 2 =*/282).string(message.secondHeadline);
            if (message.pbDisplayType != null && Object.hasOwnProperty.call(message, "pbDisplayType"))
                writer.uint32(/* id 36, wireType 0 =*/288).uint32(message.pbDisplayType);
            if (message.recomReason != null && Object.hasOwnProperty.call(message, "recomReason"))
                writer.uint32(/* id 37, wireType 2 =*/298).string(message.recomReason);
            if (message.openRecomReason != null && Object.hasOwnProperty.call(message, "openRecomReason"))
                writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.openRecomReason);
            if (message.openRecomLocation != null && Object.hasOwnProperty.call(message, "openRecomLocation"))
                writer.uint32(/* id 39, wireType 0 =*/312).uint32(message.openRecomLocation);
            if (message.openRecomFans != null && Object.hasOwnProperty.call(message, "openRecomFans"))
                writer.uint32(/* id 40, wireType 0 =*/320).uint32(message.openRecomFans);
            if (message.openRecomDuration != null && Object.hasOwnProperty.call(message, "openRecomDuration"))
                writer.uint32(/* id 41, wireType 0 =*/328).uint32(message.openRecomDuration);
            if (message.dislikeInfo != null && message.dislikeInfo.length)
                for (let i = 0; i < message.dislikeInfo.length; ++i)
                    $root.tieba.DislikeInfo.encode(message.dislikeInfo[i], writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 44, wireType 0 =*/352).uint64(message.roomId);
            if (message.roomStatus != null && Object.hasOwnProperty.call(message, "roomStatus"))
                writer.uint32(/* id 45, wireType 0 =*/360).int32(message.roomStatus);
            if (message.roomName != null && Object.hasOwnProperty.call(message, "roomName"))
                writer.uint32(/* id 46, wireType 2 =*/370).string(message.roomName);
            if (message.forumUserLiveMsg != null && Object.hasOwnProperty.call(message, "forumUserLiveMsg"))
                writer.uint32(/* id 47, wireType 2 =*/378).string(message.forumUserLiveMsg);
            if (message.coverWide != null && Object.hasOwnProperty.call(message, "coverWide"))
                writer.uint32(/* id 48, wireType 2 =*/386).string(message.coverWide);
            if (message.yyExt != null && Object.hasOwnProperty.call(message, "yyExt"))
                $root.tieba.YyExt.encode(message.yyExt, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AlaLiveInfo message, length delimited. Does not implicitly {@link tieba.AlaLiveInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {tieba.IAlaLiveInfo} message AlaLiveInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaLiveInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AlaLiveInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.AlaLiveInfo} AlaLiveInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaLiveInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.AlaLiveInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.liveId = reader.uint64();
                        break;
                    }
                case 2: {
                        message.cover = reader.string();
                        break;
                    }
                case 3: {
                        message.sessionId = reader.string();
                        break;
                    }
                case 4: {
                        message.rtmpUrl = reader.string();
                        break;
                    }
                case 5: {
                        message.hlsUrl = reader.string();
                        break;
                    }
                case 6: {
                        message.groupId = reader.uint64();
                        break;
                    }
                case 7: {
                        message.mediaUrl = reader.string();
                        break;
                    }
                case 8: {
                        message.mediaPic = reader.string();
                        break;
                    }
                case 9: {
                        message.mediaId = reader.string();
                        break;
                    }
                case 10: {
                        message.mediaSubtitle = reader.string();
                        break;
                    }
                case 11: {
                        message.description = reader.string();
                        break;
                    }
                case 12: {
                        message.userInfo = $root.tieba.AlaUserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.duration = reader.uint32();
                        break;
                    }
                case 14: {
                        message.audienceCount = reader.uint32();
                        break;
                    }
                case 15: {
                        message.liveType = reader.uint32();
                        break;
                    }
                case 16: {
                        message.screenDirection = reader.uint32();
                        break;
                    }
                case 17: {
                        message.labelName = reader.string();
                        break;
                    }
                case 18: {
                        message.liveStatus = reader.int32();
                        break;
                    }
                case 19: {
                        message.shareInfo = $root.tieba.AlaShareInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.distance = reader.uint64();
                        break;
                    }
                case 21: {
                        message.thirdAppId = reader.string();
                        break;
                    }
                case 22: {
                        message.threadId = reader.uint64();
                        break;
                    }
                case 23: {
                        if (!(message.stageDislikeInfo && message.stageDislikeInfo.length))
                            message.stageDislikeInfo = [];
                        message.stageDislikeInfo.push($root.tieba.AlaStageDislikeInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 24: {
                        message.label = $root.tieba.AlaCoverLabel.decode(reader, reader.uint32());
                        break;
                    }
                case 25: {
                        message.challengeInfo = $root.tieba.AlaChallengeInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 26: {
                        message.frsTopliveType = reader.int32();
                        break;
                    }
                case 27: {
                        message.frsToplivePic = reader.string();
                        break;
                    }
                case 28: {
                        message.frsTopliveForce = reader.int32();
                        break;
                    }
                case 29: {
                        message.liveFrom = reader.int32();
                        break;
                    }
                case 31: {
                        message.thirdRoomId = reader.string();
                        break;
                    }
                case 32: {
                        message.routerType = reader.string();
                        break;
                    }
                case 33: {
                        message.thirdLiveType = reader.string();
                        break;
                    }
                case 34: {
                        message.firstHeadline = reader.string();
                        break;
                    }
                case 35: {
                        message.secondHeadline = reader.string();
                        break;
                    }
                case 36: {
                        message.pbDisplayType = reader.uint32();
                        break;
                    }
                case 37: {
                        message.recomReason = reader.string();
                        break;
                    }
                case 38: {
                        message.openRecomReason = reader.uint32();
                        break;
                    }
                case 39: {
                        message.openRecomLocation = reader.uint32();
                        break;
                    }
                case 40: {
                        message.openRecomFans = reader.uint32();
                        break;
                    }
                case 41: {
                        message.openRecomDuration = reader.uint32();
                        break;
                    }
                case 43: {
                        if (!(message.dislikeInfo && message.dislikeInfo.length))
                            message.dislikeInfo = [];
                        message.dislikeInfo.push($root.tieba.DislikeInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 44: {
                        message.roomId = reader.uint64();
                        break;
                    }
                case 45: {
                        message.roomStatus = reader.int32();
                        break;
                    }
                case 46: {
                        message.roomName = reader.string();
                        break;
                    }
                case 47: {
                        message.forumUserLiveMsg = reader.string();
                        break;
                    }
                case 48: {
                        message.coverWide = reader.string();
                        break;
                    }
                case 49: {
                        message.yyExt = $root.tieba.YyExt.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AlaLiveInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.AlaLiveInfo} AlaLiveInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaLiveInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AlaLiveInfo message.
         * @function verify
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlaLiveInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                if (!$util.isInteger(message.liveId) && !(message.liveId && $util.isInteger(message.liveId.low) && $util.isInteger(message.liveId.high)))
                    return "liveId: integer|Long expected";
            if (message.cover != null && message.hasOwnProperty("cover"))
                if (!$util.isString(message.cover))
                    return "cover: string expected";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                if (!$util.isString(message.sessionId))
                    return "sessionId: string expected";
            if (message.rtmpUrl != null && message.hasOwnProperty("rtmpUrl"))
                if (!$util.isString(message.rtmpUrl))
                    return "rtmpUrl: string expected";
            if (message.hlsUrl != null && message.hasOwnProperty("hlsUrl"))
                if (!$util.isString(message.hlsUrl))
                    return "hlsUrl: string expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                    return "groupId: integer|Long expected";
            if (message.mediaUrl != null && message.hasOwnProperty("mediaUrl"))
                if (!$util.isString(message.mediaUrl))
                    return "mediaUrl: string expected";
            if (message.mediaPic != null && message.hasOwnProperty("mediaPic"))
                if (!$util.isString(message.mediaPic))
                    return "mediaPic: string expected";
            if (message.mediaId != null && message.hasOwnProperty("mediaId"))
                if (!$util.isString(message.mediaId))
                    return "mediaId: string expected";
            if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
                if (!$util.isString(message.mediaSubtitle))
                    return "mediaSubtitle: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                let error = $root.tieba.AlaUserInfo.verify(message.userInfo);
                if (error)
                    return "userInfo." + error;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.audienceCount != null && message.hasOwnProperty("audienceCount"))
                if (!$util.isInteger(message.audienceCount))
                    return "audienceCount: integer expected";
            if (message.liveType != null && message.hasOwnProperty("liveType"))
                if (!$util.isInteger(message.liveType))
                    return "liveType: integer expected";
            if (message.screenDirection != null && message.hasOwnProperty("screenDirection"))
                if (!$util.isInteger(message.screenDirection))
                    return "screenDirection: integer expected";
            if (message.labelName != null && message.hasOwnProperty("labelName"))
                if (!$util.isString(message.labelName))
                    return "labelName: string expected";
            if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
                if (!$util.isInteger(message.liveStatus))
                    return "liveStatus: integer expected";
            if (message.shareInfo != null && message.hasOwnProperty("shareInfo")) {
                let error = $root.tieba.AlaShareInfo.verify(message.shareInfo);
                if (error)
                    return "shareInfo." + error;
            }
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (!$util.isInteger(message.distance) && !(message.distance && $util.isInteger(message.distance.low) && $util.isInteger(message.distance.high)))
                    return "distance: integer|Long expected";
            if (message.thirdAppId != null && message.hasOwnProperty("thirdAppId"))
                if (!$util.isString(message.thirdAppId))
                    return "thirdAppId: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                    return "threadId: integer|Long expected";
            if (message.stageDislikeInfo != null && message.hasOwnProperty("stageDislikeInfo")) {
                if (!Array.isArray(message.stageDislikeInfo))
                    return "stageDislikeInfo: array expected";
                for (let i = 0; i < message.stageDislikeInfo.length; ++i) {
                    let error = $root.tieba.AlaStageDislikeInfo.verify(message.stageDislikeInfo[i]);
                    if (error)
                        return "stageDislikeInfo." + error;
                }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
                let error = $root.tieba.AlaCoverLabel.verify(message.label);
                if (error)
                    return "label." + error;
            }
            if (message.challengeInfo != null && message.hasOwnProperty("challengeInfo")) {
                let error = $root.tieba.AlaChallengeInfo.verify(message.challengeInfo);
                if (error)
                    return "challengeInfo." + error;
            }
            if (message.frsTopliveType != null && message.hasOwnProperty("frsTopliveType"))
                if (!$util.isInteger(message.frsTopliveType))
                    return "frsTopliveType: integer expected";
            if (message.frsToplivePic != null && message.hasOwnProperty("frsToplivePic"))
                if (!$util.isString(message.frsToplivePic))
                    return "frsToplivePic: string expected";
            if (message.frsTopliveForce != null && message.hasOwnProperty("frsTopliveForce"))
                if (!$util.isInteger(message.frsTopliveForce))
                    return "frsTopliveForce: integer expected";
            if (message.liveFrom != null && message.hasOwnProperty("liveFrom"))
                if (!$util.isInteger(message.liveFrom))
                    return "liveFrom: integer expected";
            if (message.thirdRoomId != null && message.hasOwnProperty("thirdRoomId"))
                if (!$util.isString(message.thirdRoomId))
                    return "thirdRoomId: string expected";
            if (message.routerType != null && message.hasOwnProperty("routerType"))
                if (!$util.isString(message.routerType))
                    return "routerType: string expected";
            if (message.thirdLiveType != null && message.hasOwnProperty("thirdLiveType"))
                if (!$util.isString(message.thirdLiveType))
                    return "thirdLiveType: string expected";
            if (message.firstHeadline != null && message.hasOwnProperty("firstHeadline"))
                if (!$util.isString(message.firstHeadline))
                    return "firstHeadline: string expected";
            if (message.secondHeadline != null && message.hasOwnProperty("secondHeadline"))
                if (!$util.isString(message.secondHeadline))
                    return "secondHeadline: string expected";
            if (message.pbDisplayType != null && message.hasOwnProperty("pbDisplayType"))
                if (!$util.isInteger(message.pbDisplayType))
                    return "pbDisplayType: integer expected";
            if (message.recomReason != null && message.hasOwnProperty("recomReason"))
                if (!$util.isString(message.recomReason))
                    return "recomReason: string expected";
            if (message.openRecomReason != null && message.hasOwnProperty("openRecomReason"))
                if (!$util.isInteger(message.openRecomReason))
                    return "openRecomReason: integer expected";
            if (message.openRecomLocation != null && message.hasOwnProperty("openRecomLocation"))
                if (!$util.isInteger(message.openRecomLocation))
                    return "openRecomLocation: integer expected";
            if (message.openRecomFans != null && message.hasOwnProperty("openRecomFans"))
                if (!$util.isInteger(message.openRecomFans))
                    return "openRecomFans: integer expected";
            if (message.openRecomDuration != null && message.hasOwnProperty("openRecomDuration"))
                if (!$util.isInteger(message.openRecomDuration))
                    return "openRecomDuration: integer expected";
            if (message.dislikeInfo != null && message.hasOwnProperty("dislikeInfo")) {
                if (!Array.isArray(message.dislikeInfo))
                    return "dislikeInfo: array expected";
                for (let i = 0; i < message.dislikeInfo.length; ++i) {
                    let error = $root.tieba.DislikeInfo.verify(message.dislikeInfo[i]);
                    if (error)
                        return "dislikeInfo." + error;
                }
            }
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high)))
                    return "roomId: integer|Long expected";
            if (message.roomStatus != null && message.hasOwnProperty("roomStatus"))
                if (!$util.isInteger(message.roomStatus))
                    return "roomStatus: integer expected";
            if (message.roomName != null && message.hasOwnProperty("roomName"))
                if (!$util.isString(message.roomName))
                    return "roomName: string expected";
            if (message.forumUserLiveMsg != null && message.hasOwnProperty("forumUserLiveMsg"))
                if (!$util.isString(message.forumUserLiveMsg))
                    return "forumUserLiveMsg: string expected";
            if (message.coverWide != null && message.hasOwnProperty("coverWide"))
                if (!$util.isString(message.coverWide))
                    return "coverWide: string expected";
            if (message.yyExt != null && message.hasOwnProperty("yyExt")) {
                let error = $root.tieba.YyExt.verify(message.yyExt);
                if (error)
                    return "yyExt." + error;
            }
            return null;
        };

        /**
         * Creates an AlaLiveInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.AlaLiveInfo} AlaLiveInfo
         */
        AlaLiveInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.AlaLiveInfo)
                return object;
            let message = new $root.tieba.AlaLiveInfo();
            if (object.liveId != null)
                if ($util.Long)
                    (message.liveId = $util.Long.fromValue(object.liveId)).unsigned = true;
                else if (typeof object.liveId === "string")
                    message.liveId = parseInt(object.liveId, 10);
                else if (typeof object.liveId === "number")
                    message.liveId = object.liveId;
                else if (typeof object.liveId === "object")
                    message.liveId = new $util.LongBits(object.liveId.low >>> 0, object.liveId.high >>> 0).toNumber(true);
            if (object.cover != null)
                message.cover = String(object.cover);
            if (object.sessionId != null)
                message.sessionId = String(object.sessionId);
            if (object.rtmpUrl != null)
                message.rtmpUrl = String(object.rtmpUrl);
            if (object.hlsUrl != null)
                message.hlsUrl = String(object.hlsUrl);
            if (object.groupId != null)
                if ($util.Long)
                    (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                else if (typeof object.groupId === "string")
                    message.groupId = parseInt(object.groupId, 10);
                else if (typeof object.groupId === "number")
                    message.groupId = object.groupId;
                else if (typeof object.groupId === "object")
                    message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
            if (object.mediaUrl != null)
                message.mediaUrl = String(object.mediaUrl);
            if (object.mediaPic != null)
                message.mediaPic = String(object.mediaPic);
            if (object.mediaId != null)
                message.mediaId = String(object.mediaId);
            if (object.mediaSubtitle != null)
                message.mediaSubtitle = String(object.mediaSubtitle);
            if (object.description != null)
                message.description = String(object.description);
            if (object.userInfo != null) {
                if (typeof object.userInfo !== "object")
                    throw TypeError(".tieba.AlaLiveInfo.userInfo: object expected");
                message.userInfo = $root.tieba.AlaUserInfo.fromObject(object.userInfo);
            }
            if (object.duration != null)
                message.duration = object.duration >>> 0;
            if (object.audienceCount != null)
                message.audienceCount = object.audienceCount >>> 0;
            if (object.liveType != null)
                message.liveType = object.liveType >>> 0;
            if (object.screenDirection != null)
                message.screenDirection = object.screenDirection >>> 0;
            if (object.labelName != null)
                message.labelName = String(object.labelName);
            if (object.liveStatus != null)
                message.liveStatus = object.liveStatus | 0;
            if (object.shareInfo != null) {
                if (typeof object.shareInfo !== "object")
                    throw TypeError(".tieba.AlaLiveInfo.shareInfo: object expected");
                message.shareInfo = $root.tieba.AlaShareInfo.fromObject(object.shareInfo);
            }
            if (object.distance != null)
                if ($util.Long)
                    (message.distance = $util.Long.fromValue(object.distance)).unsigned = true;
                else if (typeof object.distance === "string")
                    message.distance = parseInt(object.distance, 10);
                else if (typeof object.distance === "number")
                    message.distance = object.distance;
                else if (typeof object.distance === "object")
                    message.distance = new $util.LongBits(object.distance.low >>> 0, object.distance.high >>> 0).toNumber(true);
            if (object.thirdAppId != null)
                message.thirdAppId = String(object.thirdAppId);
            if (object.threadId != null)
                if ($util.Long)
                    (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = true;
                else if (typeof object.threadId === "string")
                    message.threadId = parseInt(object.threadId, 10);
                else if (typeof object.threadId === "number")
                    message.threadId = object.threadId;
                else if (typeof object.threadId === "object")
                    message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber(true);
            if (object.stageDislikeInfo) {
                if (!Array.isArray(object.stageDislikeInfo))
                    throw TypeError(".tieba.AlaLiveInfo.stageDislikeInfo: array expected");
                message.stageDislikeInfo = [];
                for (let i = 0; i < object.stageDislikeInfo.length; ++i) {
                    if (typeof object.stageDislikeInfo[i] !== "object")
                        throw TypeError(".tieba.AlaLiveInfo.stageDislikeInfo: object expected");
                    message.stageDislikeInfo[i] = $root.tieba.AlaStageDislikeInfo.fromObject(object.stageDislikeInfo[i]);
                }
            }
            if (object.label != null) {
                if (typeof object.label !== "object")
                    throw TypeError(".tieba.AlaLiveInfo.label: object expected");
                message.label = $root.tieba.AlaCoverLabel.fromObject(object.label);
            }
            if (object.challengeInfo != null) {
                if (typeof object.challengeInfo !== "object")
                    throw TypeError(".tieba.AlaLiveInfo.challengeInfo: object expected");
                message.challengeInfo = $root.tieba.AlaChallengeInfo.fromObject(object.challengeInfo);
            }
            if (object.frsTopliveType != null)
                message.frsTopliveType = object.frsTopliveType | 0;
            if (object.frsToplivePic != null)
                message.frsToplivePic = String(object.frsToplivePic);
            if (object.frsTopliveForce != null)
                message.frsTopliveForce = object.frsTopliveForce | 0;
            if (object.liveFrom != null)
                message.liveFrom = object.liveFrom | 0;
            if (object.thirdRoomId != null)
                message.thirdRoomId = String(object.thirdRoomId);
            if (object.routerType != null)
                message.routerType = String(object.routerType);
            if (object.thirdLiveType != null)
                message.thirdLiveType = String(object.thirdLiveType);
            if (object.firstHeadline != null)
                message.firstHeadline = String(object.firstHeadline);
            if (object.secondHeadline != null)
                message.secondHeadline = String(object.secondHeadline);
            if (object.pbDisplayType != null)
                message.pbDisplayType = object.pbDisplayType >>> 0;
            if (object.recomReason != null)
                message.recomReason = String(object.recomReason);
            if (object.openRecomReason != null)
                message.openRecomReason = object.openRecomReason >>> 0;
            if (object.openRecomLocation != null)
                message.openRecomLocation = object.openRecomLocation >>> 0;
            if (object.openRecomFans != null)
                message.openRecomFans = object.openRecomFans >>> 0;
            if (object.openRecomDuration != null)
                message.openRecomDuration = object.openRecomDuration >>> 0;
            if (object.dislikeInfo) {
                if (!Array.isArray(object.dislikeInfo))
                    throw TypeError(".tieba.AlaLiveInfo.dislikeInfo: array expected");
                message.dislikeInfo = [];
                for (let i = 0; i < object.dislikeInfo.length; ++i) {
                    if (typeof object.dislikeInfo[i] !== "object")
                        throw TypeError(".tieba.AlaLiveInfo.dislikeInfo: object expected");
                    message.dislikeInfo[i] = $root.tieba.DislikeInfo.fromObject(object.dislikeInfo[i]);
                }
            }
            if (object.roomId != null)
                if ($util.Long)
                    (message.roomId = $util.Long.fromValue(object.roomId)).unsigned = true;
                else if (typeof object.roomId === "string")
                    message.roomId = parseInt(object.roomId, 10);
                else if (typeof object.roomId === "number")
                    message.roomId = object.roomId;
                else if (typeof object.roomId === "object")
                    message.roomId = new $util.LongBits(object.roomId.low >>> 0, object.roomId.high >>> 0).toNumber(true);
            if (object.roomStatus != null)
                message.roomStatus = object.roomStatus | 0;
            if (object.roomName != null)
                message.roomName = String(object.roomName);
            if (object.forumUserLiveMsg != null)
                message.forumUserLiveMsg = String(object.forumUserLiveMsg);
            if (object.coverWide != null)
                message.coverWide = String(object.coverWide);
            if (object.yyExt != null) {
                if (typeof object.yyExt !== "object")
                    throw TypeError(".tieba.AlaLiveInfo.yyExt: object expected");
                message.yyExt = $root.tieba.YyExt.fromObject(object.yyExt);
            }
            return message;
        };

        /**
         * Creates a plain object from an AlaLiveInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {tieba.AlaLiveInfo} message AlaLiveInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlaLiveInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.stageDislikeInfo = [];
                object.dislikeInfo = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.liveId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.liveId = options.longs === String ? "0" : 0;
                object.cover = "";
                object.sessionId = "";
                object.rtmpUrl = "";
                object.hlsUrl = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.groupId = options.longs === String ? "0" : 0;
                object.mediaUrl = "";
                object.mediaPic = "";
                object.mediaId = "";
                object.mediaSubtitle = "";
                object.description = "";
                object.userInfo = null;
                object.duration = 0;
                object.audienceCount = 0;
                object.liveType = 0;
                object.screenDirection = 0;
                object.labelName = "";
                object.liveStatus = 0;
                object.shareInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.distance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.distance = options.longs === String ? "0" : 0;
                object.thirdAppId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.threadId = options.longs === String ? "0" : 0;
                object.label = null;
                object.challengeInfo = null;
                object.frsTopliveType = 0;
                object.frsToplivePic = "";
                object.frsTopliveForce = 0;
                object.liveFrom = 0;
                object.thirdRoomId = "";
                object.routerType = "";
                object.thirdLiveType = "";
                object.firstHeadline = "";
                object.secondHeadline = "";
                object.pbDisplayType = 0;
                object.recomReason = "";
                object.openRecomReason = 0;
                object.openRecomLocation = 0;
                object.openRecomFans = 0;
                object.openRecomDuration = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.roomId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roomId = options.longs === String ? "0" : 0;
                object.roomStatus = 0;
                object.roomName = "";
                object.forumUserLiveMsg = "";
                object.coverWide = "";
                object.yyExt = null;
            }
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                if (typeof message.liveId === "number")
                    object.liveId = options.longs === String ? String(message.liveId) : message.liveId;
                else
                    object.liveId = options.longs === String ? $util.Long.prototype.toString.call(message.liveId) : options.longs === Number ? new $util.LongBits(message.liveId.low >>> 0, message.liveId.high >>> 0).toNumber(true) : message.liveId;
            if (message.cover != null && message.hasOwnProperty("cover"))
                object.cover = message.cover;
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                object.sessionId = message.sessionId;
            if (message.rtmpUrl != null && message.hasOwnProperty("rtmpUrl"))
                object.rtmpUrl = message.rtmpUrl;
            if (message.hlsUrl != null && message.hasOwnProperty("hlsUrl"))
                object.hlsUrl = message.hlsUrl;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (typeof message.groupId === "number")
                    object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                else
                    object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
            if (message.mediaUrl != null && message.hasOwnProperty("mediaUrl"))
                object.mediaUrl = message.mediaUrl;
            if (message.mediaPic != null && message.hasOwnProperty("mediaPic"))
                object.mediaPic = message.mediaPic;
            if (message.mediaId != null && message.hasOwnProperty("mediaId"))
                object.mediaId = message.mediaId;
            if (message.mediaSubtitle != null && message.hasOwnProperty("mediaSubtitle"))
                object.mediaSubtitle = message.mediaSubtitle;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.userInfo != null && message.hasOwnProperty("userInfo"))
                object.userInfo = $root.tieba.AlaUserInfo.toObject(message.userInfo, options);
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.audienceCount != null && message.hasOwnProperty("audienceCount"))
                object.audienceCount = message.audienceCount;
            if (message.liveType != null && message.hasOwnProperty("liveType"))
                object.liveType = message.liveType;
            if (message.screenDirection != null && message.hasOwnProperty("screenDirection"))
                object.screenDirection = message.screenDirection;
            if (message.labelName != null && message.hasOwnProperty("labelName"))
                object.labelName = message.labelName;
            if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
                object.liveStatus = message.liveStatus;
            if (message.shareInfo != null && message.hasOwnProperty("shareInfo"))
                object.shareInfo = $root.tieba.AlaShareInfo.toObject(message.shareInfo, options);
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (typeof message.distance === "number")
                    object.distance = options.longs === String ? String(message.distance) : message.distance;
                else
                    object.distance = options.longs === String ? $util.Long.prototype.toString.call(message.distance) : options.longs === Number ? new $util.LongBits(message.distance.low >>> 0, message.distance.high >>> 0).toNumber(true) : message.distance;
            if (message.thirdAppId != null && message.hasOwnProperty("thirdAppId"))
                object.thirdAppId = message.thirdAppId;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (typeof message.threadId === "number")
                    object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                else
                    object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber(true) : message.threadId;
            if (message.stageDislikeInfo && message.stageDislikeInfo.length) {
                object.stageDislikeInfo = [];
                for (let j = 0; j < message.stageDislikeInfo.length; ++j)
                    object.stageDislikeInfo[j] = $root.tieba.AlaStageDislikeInfo.toObject(message.stageDislikeInfo[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = $root.tieba.AlaCoverLabel.toObject(message.label, options);
            if (message.challengeInfo != null && message.hasOwnProperty("challengeInfo"))
                object.challengeInfo = $root.tieba.AlaChallengeInfo.toObject(message.challengeInfo, options);
            if (message.frsTopliveType != null && message.hasOwnProperty("frsTopliveType"))
                object.frsTopliveType = message.frsTopliveType;
            if (message.frsToplivePic != null && message.hasOwnProperty("frsToplivePic"))
                object.frsToplivePic = message.frsToplivePic;
            if (message.frsTopliveForce != null && message.hasOwnProperty("frsTopliveForce"))
                object.frsTopliveForce = message.frsTopliveForce;
            if (message.liveFrom != null && message.hasOwnProperty("liveFrom"))
                object.liveFrom = message.liveFrom;
            if (message.thirdRoomId != null && message.hasOwnProperty("thirdRoomId"))
                object.thirdRoomId = message.thirdRoomId;
            if (message.routerType != null && message.hasOwnProperty("routerType"))
                object.routerType = message.routerType;
            if (message.thirdLiveType != null && message.hasOwnProperty("thirdLiveType"))
                object.thirdLiveType = message.thirdLiveType;
            if (message.firstHeadline != null && message.hasOwnProperty("firstHeadline"))
                object.firstHeadline = message.firstHeadline;
            if (message.secondHeadline != null && message.hasOwnProperty("secondHeadline"))
                object.secondHeadline = message.secondHeadline;
            if (message.pbDisplayType != null && message.hasOwnProperty("pbDisplayType"))
                object.pbDisplayType = message.pbDisplayType;
            if (message.recomReason != null && message.hasOwnProperty("recomReason"))
                object.recomReason = message.recomReason;
            if (message.openRecomReason != null && message.hasOwnProperty("openRecomReason"))
                object.openRecomReason = message.openRecomReason;
            if (message.openRecomLocation != null && message.hasOwnProperty("openRecomLocation"))
                object.openRecomLocation = message.openRecomLocation;
            if (message.openRecomFans != null && message.hasOwnProperty("openRecomFans"))
                object.openRecomFans = message.openRecomFans;
            if (message.openRecomDuration != null && message.hasOwnProperty("openRecomDuration"))
                object.openRecomDuration = message.openRecomDuration;
            if (message.dislikeInfo && message.dislikeInfo.length) {
                object.dislikeInfo = [];
                for (let j = 0; j < message.dislikeInfo.length; ++j)
                    object.dislikeInfo[j] = $root.tieba.DislikeInfo.toObject(message.dislikeInfo[j], options);
            }
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (typeof message.roomId === "number")
                    object.roomId = options.longs === String ? String(message.roomId) : message.roomId;
                else
                    object.roomId = options.longs === String ? $util.Long.prototype.toString.call(message.roomId) : options.longs === Number ? new $util.LongBits(message.roomId.low >>> 0, message.roomId.high >>> 0).toNumber(true) : message.roomId;
            if (message.roomStatus != null && message.hasOwnProperty("roomStatus"))
                object.roomStatus = message.roomStatus;
            if (message.roomName != null && message.hasOwnProperty("roomName"))
                object.roomName = message.roomName;
            if (message.forumUserLiveMsg != null && message.hasOwnProperty("forumUserLiveMsg"))
                object.forumUserLiveMsg = message.forumUserLiveMsg;
            if (message.coverWide != null && message.hasOwnProperty("coverWide"))
                object.coverWide = message.coverWide;
            if (message.yyExt != null && message.hasOwnProperty("yyExt"))
                object.yyExt = $root.tieba.YyExt.toObject(message.yyExt, options);
            return object;
        };

        /**
         * Converts this AlaLiveInfo to JSON.
         * @function toJSON
         * @memberof tieba.AlaLiveInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlaLiveInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AlaLiveInfo
         * @function getTypeUrl
         * @memberof tieba.AlaLiveInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AlaLiveInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.AlaLiveInfo";
        };

        return AlaLiveInfo;
    })();

    tieba.AlaChallengeInfo = (function() {

        /**
         * Properties of an AlaChallengeInfo.
         * @memberof tieba
         * @interface IAlaChallengeInfo
         * @property {number|Long|null} [challengeId] AlaChallengeInfo challengeId
         * @property {number|Long|null} [winningNum] AlaChallengeInfo winningNum
         * @property {string|null} [rivalSession] AlaChallengeInfo rivalSession
         * @property {string|null} [rivalRtmpUrl] AlaChallengeInfo rivalRtmpUrl
         * @property {string|null} [rivalHlsUrl] AlaChallengeInfo rivalHlsUrl
         * @property {string|null} [ext] AlaChallengeInfo ext
         */

        /**
         * Constructs a new AlaChallengeInfo.
         * @memberof tieba
         * @classdesc Represents an AlaChallengeInfo.
         * @implements IAlaChallengeInfo
         * @constructor
         * @param {tieba.IAlaChallengeInfo=} [properties] Properties to set
         */
        function AlaChallengeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AlaChallengeInfo challengeId.
         * @member {number|Long} challengeId
         * @memberof tieba.AlaChallengeInfo
         * @instance
         */
        AlaChallengeInfo.prototype.challengeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AlaChallengeInfo winningNum.
         * @member {number|Long} winningNum
         * @memberof tieba.AlaChallengeInfo
         * @instance
         */
        AlaChallengeInfo.prototype.winningNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AlaChallengeInfo rivalSession.
         * @member {string} rivalSession
         * @memberof tieba.AlaChallengeInfo
         * @instance
         */
        AlaChallengeInfo.prototype.rivalSession = "";

        /**
         * AlaChallengeInfo rivalRtmpUrl.
         * @member {string} rivalRtmpUrl
         * @memberof tieba.AlaChallengeInfo
         * @instance
         */
        AlaChallengeInfo.prototype.rivalRtmpUrl = "";

        /**
         * AlaChallengeInfo rivalHlsUrl.
         * @member {string} rivalHlsUrl
         * @memberof tieba.AlaChallengeInfo
         * @instance
         */
        AlaChallengeInfo.prototype.rivalHlsUrl = "";

        /**
         * AlaChallengeInfo ext.
         * @member {string} ext
         * @memberof tieba.AlaChallengeInfo
         * @instance
         */
        AlaChallengeInfo.prototype.ext = "";

        /**
         * Creates a new AlaChallengeInfo instance using the specified properties.
         * @function create
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {tieba.IAlaChallengeInfo=} [properties] Properties to set
         * @returns {tieba.AlaChallengeInfo} AlaChallengeInfo instance
         */
        AlaChallengeInfo.create = function create(properties) {
            return new AlaChallengeInfo(properties);
        };

        /**
         * Encodes the specified AlaChallengeInfo message. Does not implicitly {@link tieba.AlaChallengeInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {tieba.IAlaChallengeInfo} message AlaChallengeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaChallengeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.challengeId != null && Object.hasOwnProperty.call(message, "challengeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.challengeId);
            if (message.winningNum != null && Object.hasOwnProperty.call(message, "winningNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.winningNum);
            if (message.rivalSession != null && Object.hasOwnProperty.call(message, "rivalSession"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.rivalSession);
            if (message.rivalRtmpUrl != null && Object.hasOwnProperty.call(message, "rivalRtmpUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.rivalRtmpUrl);
            if (message.rivalHlsUrl != null && Object.hasOwnProperty.call(message, "rivalHlsUrl"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.rivalHlsUrl);
            if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.ext);
            return writer;
        };

        /**
         * Encodes the specified AlaChallengeInfo message, length delimited. Does not implicitly {@link tieba.AlaChallengeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {tieba.IAlaChallengeInfo} message AlaChallengeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaChallengeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AlaChallengeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.AlaChallengeInfo} AlaChallengeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaChallengeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.AlaChallengeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.challengeId = reader.int64();
                        break;
                    }
                case 2: {
                        message.winningNum = reader.int64();
                        break;
                    }
                case 3: {
                        message.rivalSession = reader.string();
                        break;
                    }
                case 4: {
                        message.rivalRtmpUrl = reader.string();
                        break;
                    }
                case 5: {
                        message.rivalHlsUrl = reader.string();
                        break;
                    }
                case 6: {
                        message.ext = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AlaChallengeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.AlaChallengeInfo} AlaChallengeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaChallengeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AlaChallengeInfo message.
         * @function verify
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlaChallengeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.challengeId != null && message.hasOwnProperty("challengeId"))
                if (!$util.isInteger(message.challengeId) && !(message.challengeId && $util.isInteger(message.challengeId.low) && $util.isInteger(message.challengeId.high)))
                    return "challengeId: integer|Long expected";
            if (message.winningNum != null && message.hasOwnProperty("winningNum"))
                if (!$util.isInteger(message.winningNum) && !(message.winningNum && $util.isInteger(message.winningNum.low) && $util.isInteger(message.winningNum.high)))
                    return "winningNum: integer|Long expected";
            if (message.rivalSession != null && message.hasOwnProperty("rivalSession"))
                if (!$util.isString(message.rivalSession))
                    return "rivalSession: string expected";
            if (message.rivalRtmpUrl != null && message.hasOwnProperty("rivalRtmpUrl"))
                if (!$util.isString(message.rivalRtmpUrl))
                    return "rivalRtmpUrl: string expected";
            if (message.rivalHlsUrl != null && message.hasOwnProperty("rivalHlsUrl"))
                if (!$util.isString(message.rivalHlsUrl))
                    return "rivalHlsUrl: string expected";
            if (message.ext != null && message.hasOwnProperty("ext"))
                if (!$util.isString(message.ext))
                    return "ext: string expected";
            return null;
        };

        /**
         * Creates an AlaChallengeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.AlaChallengeInfo} AlaChallengeInfo
         */
        AlaChallengeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.AlaChallengeInfo)
                return object;
            let message = new $root.tieba.AlaChallengeInfo();
            if (object.challengeId != null)
                if ($util.Long)
                    (message.challengeId = $util.Long.fromValue(object.challengeId)).unsigned = false;
                else if (typeof object.challengeId === "string")
                    message.challengeId = parseInt(object.challengeId, 10);
                else if (typeof object.challengeId === "number")
                    message.challengeId = object.challengeId;
                else if (typeof object.challengeId === "object")
                    message.challengeId = new $util.LongBits(object.challengeId.low >>> 0, object.challengeId.high >>> 0).toNumber();
            if (object.winningNum != null)
                if ($util.Long)
                    (message.winningNum = $util.Long.fromValue(object.winningNum)).unsigned = false;
                else if (typeof object.winningNum === "string")
                    message.winningNum = parseInt(object.winningNum, 10);
                else if (typeof object.winningNum === "number")
                    message.winningNum = object.winningNum;
                else if (typeof object.winningNum === "object")
                    message.winningNum = new $util.LongBits(object.winningNum.low >>> 0, object.winningNum.high >>> 0).toNumber();
            if (object.rivalSession != null)
                message.rivalSession = String(object.rivalSession);
            if (object.rivalRtmpUrl != null)
                message.rivalRtmpUrl = String(object.rivalRtmpUrl);
            if (object.rivalHlsUrl != null)
                message.rivalHlsUrl = String(object.rivalHlsUrl);
            if (object.ext != null)
                message.ext = String(object.ext);
            return message;
        };

        /**
         * Creates a plain object from an AlaChallengeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {tieba.AlaChallengeInfo} message AlaChallengeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlaChallengeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.challengeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.challengeId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.winningNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.winningNum = options.longs === String ? "0" : 0;
                object.rivalSession = "";
                object.rivalRtmpUrl = "";
                object.rivalHlsUrl = "";
                object.ext = "";
            }
            if (message.challengeId != null && message.hasOwnProperty("challengeId"))
                if (typeof message.challengeId === "number")
                    object.challengeId = options.longs === String ? String(message.challengeId) : message.challengeId;
                else
                    object.challengeId = options.longs === String ? $util.Long.prototype.toString.call(message.challengeId) : options.longs === Number ? new $util.LongBits(message.challengeId.low >>> 0, message.challengeId.high >>> 0).toNumber() : message.challengeId;
            if (message.winningNum != null && message.hasOwnProperty("winningNum"))
                if (typeof message.winningNum === "number")
                    object.winningNum = options.longs === String ? String(message.winningNum) : message.winningNum;
                else
                    object.winningNum = options.longs === String ? $util.Long.prototype.toString.call(message.winningNum) : options.longs === Number ? new $util.LongBits(message.winningNum.low >>> 0, message.winningNum.high >>> 0).toNumber() : message.winningNum;
            if (message.rivalSession != null && message.hasOwnProperty("rivalSession"))
                object.rivalSession = message.rivalSession;
            if (message.rivalRtmpUrl != null && message.hasOwnProperty("rivalRtmpUrl"))
                object.rivalRtmpUrl = message.rivalRtmpUrl;
            if (message.rivalHlsUrl != null && message.hasOwnProperty("rivalHlsUrl"))
                object.rivalHlsUrl = message.rivalHlsUrl;
            if (message.ext != null && message.hasOwnProperty("ext"))
                object.ext = message.ext;
            return object;
        };

        /**
         * Converts this AlaChallengeInfo to JSON.
         * @function toJSON
         * @memberof tieba.AlaChallengeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlaChallengeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AlaChallengeInfo
         * @function getTypeUrl
         * @memberof tieba.AlaChallengeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AlaChallengeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.AlaChallengeInfo";
        };

        return AlaChallengeInfo;
    })();

    tieba.AlaCoverLabel = (function() {

        /**
         * Properties of an AlaCoverLabel.
         * @memberof tieba
         * @interface IAlaCoverLabel
         * @property {number|null} [labelId] AlaCoverLabel labelId
         * @property {string|null} [labelName] AlaCoverLabel labelName
         * @property {string|null} [labelRgb] AlaCoverLabel labelRgb
         */

        /**
         * Constructs a new AlaCoverLabel.
         * @memberof tieba
         * @classdesc Represents an AlaCoverLabel.
         * @implements IAlaCoverLabel
         * @constructor
         * @param {tieba.IAlaCoverLabel=} [properties] Properties to set
         */
        function AlaCoverLabel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AlaCoverLabel labelId.
         * @member {number} labelId
         * @memberof tieba.AlaCoverLabel
         * @instance
         */
        AlaCoverLabel.prototype.labelId = 0;

        /**
         * AlaCoverLabel labelName.
         * @member {string} labelName
         * @memberof tieba.AlaCoverLabel
         * @instance
         */
        AlaCoverLabel.prototype.labelName = "";

        /**
         * AlaCoverLabel labelRgb.
         * @member {string} labelRgb
         * @memberof tieba.AlaCoverLabel
         * @instance
         */
        AlaCoverLabel.prototype.labelRgb = "";

        /**
         * Creates a new AlaCoverLabel instance using the specified properties.
         * @function create
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {tieba.IAlaCoverLabel=} [properties] Properties to set
         * @returns {tieba.AlaCoverLabel} AlaCoverLabel instance
         */
        AlaCoverLabel.create = function create(properties) {
            return new AlaCoverLabel(properties);
        };

        /**
         * Encodes the specified AlaCoverLabel message. Does not implicitly {@link tieba.AlaCoverLabel.verify|verify} messages.
         * @function encode
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {tieba.IAlaCoverLabel} message AlaCoverLabel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaCoverLabel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.labelId != null && Object.hasOwnProperty.call(message, "labelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.labelId);
            if (message.labelName != null && Object.hasOwnProperty.call(message, "labelName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.labelName);
            if (message.labelRgb != null && Object.hasOwnProperty.call(message, "labelRgb"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.labelRgb);
            return writer;
        };

        /**
         * Encodes the specified AlaCoverLabel message, length delimited. Does not implicitly {@link tieba.AlaCoverLabel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {tieba.IAlaCoverLabel} message AlaCoverLabel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaCoverLabel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AlaCoverLabel message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.AlaCoverLabel} AlaCoverLabel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaCoverLabel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.AlaCoverLabel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.labelId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.labelName = reader.string();
                        break;
                    }
                case 3: {
                        message.labelRgb = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AlaCoverLabel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.AlaCoverLabel} AlaCoverLabel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaCoverLabel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AlaCoverLabel message.
         * @function verify
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlaCoverLabel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.labelId != null && message.hasOwnProperty("labelId"))
                if (!$util.isInteger(message.labelId))
                    return "labelId: integer expected";
            if (message.labelName != null && message.hasOwnProperty("labelName"))
                if (!$util.isString(message.labelName))
                    return "labelName: string expected";
            if (message.labelRgb != null && message.hasOwnProperty("labelRgb"))
                if (!$util.isString(message.labelRgb))
                    return "labelRgb: string expected";
            return null;
        };

        /**
         * Creates an AlaCoverLabel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.AlaCoverLabel} AlaCoverLabel
         */
        AlaCoverLabel.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.AlaCoverLabel)
                return object;
            let message = new $root.tieba.AlaCoverLabel();
            if (object.labelId != null)
                message.labelId = object.labelId >>> 0;
            if (object.labelName != null)
                message.labelName = String(object.labelName);
            if (object.labelRgb != null)
                message.labelRgb = String(object.labelRgb);
            return message;
        };

        /**
         * Creates a plain object from an AlaCoverLabel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {tieba.AlaCoverLabel} message AlaCoverLabel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlaCoverLabel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.labelId = 0;
                object.labelName = "";
                object.labelRgb = "";
            }
            if (message.labelId != null && message.hasOwnProperty("labelId"))
                object.labelId = message.labelId;
            if (message.labelName != null && message.hasOwnProperty("labelName"))
                object.labelName = message.labelName;
            if (message.labelRgb != null && message.hasOwnProperty("labelRgb"))
                object.labelRgb = message.labelRgb;
            return object;
        };

        /**
         * Converts this AlaCoverLabel to JSON.
         * @function toJSON
         * @memberof tieba.AlaCoverLabel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlaCoverLabel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AlaCoverLabel
         * @function getTypeUrl
         * @memberof tieba.AlaCoverLabel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AlaCoverLabel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.AlaCoverLabel";
        };

        return AlaCoverLabel;
    })();

    tieba.AlaShareInfo = (function() {

        /**
         * Properties of an AlaShareInfo.
         * @memberof tieba
         * @interface IAlaShareInfo
         * @property {string|null} [content] AlaShareInfo content
         * @property {number|null} [shareUserCount] AlaShareInfo shareUserCount
         * @property {number|null} [shareCount] AlaShareInfo shareCount
         * @property {number|Long|null} [recordTid] AlaShareInfo recordTid
         */

        /**
         * Constructs a new AlaShareInfo.
         * @memberof tieba
         * @classdesc Represents an AlaShareInfo.
         * @implements IAlaShareInfo
         * @constructor
         * @param {tieba.IAlaShareInfo=} [properties] Properties to set
         */
        function AlaShareInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AlaShareInfo content.
         * @member {string} content
         * @memberof tieba.AlaShareInfo
         * @instance
         */
        AlaShareInfo.prototype.content = "";

        /**
         * AlaShareInfo shareUserCount.
         * @member {number} shareUserCount
         * @memberof tieba.AlaShareInfo
         * @instance
         */
        AlaShareInfo.prototype.shareUserCount = 0;

        /**
         * AlaShareInfo shareCount.
         * @member {number} shareCount
         * @memberof tieba.AlaShareInfo
         * @instance
         */
        AlaShareInfo.prototype.shareCount = 0;

        /**
         * AlaShareInfo recordTid.
         * @member {number|Long} recordTid
         * @memberof tieba.AlaShareInfo
         * @instance
         */
        AlaShareInfo.prototype.recordTid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AlaShareInfo instance using the specified properties.
         * @function create
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {tieba.IAlaShareInfo=} [properties] Properties to set
         * @returns {tieba.AlaShareInfo} AlaShareInfo instance
         */
        AlaShareInfo.create = function create(properties) {
            return new AlaShareInfo(properties);
        };

        /**
         * Encodes the specified AlaShareInfo message. Does not implicitly {@link tieba.AlaShareInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {tieba.IAlaShareInfo} message AlaShareInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaShareInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.shareUserCount != null && Object.hasOwnProperty.call(message, "shareUserCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.shareUserCount);
            if (message.shareCount != null && Object.hasOwnProperty.call(message, "shareCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.shareCount);
            if (message.recordTid != null && Object.hasOwnProperty.call(message, "recordTid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.recordTid);
            return writer;
        };

        /**
         * Encodes the specified AlaShareInfo message, length delimited. Does not implicitly {@link tieba.AlaShareInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {tieba.IAlaShareInfo} message AlaShareInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaShareInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AlaShareInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.AlaShareInfo} AlaShareInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaShareInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.AlaShareInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.content = reader.string();
                        break;
                    }
                case 2: {
                        message.shareUserCount = reader.int32();
                        break;
                    }
                case 3: {
                        message.shareCount = reader.int32();
                        break;
                    }
                case 4: {
                        message.recordTid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AlaShareInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.AlaShareInfo} AlaShareInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaShareInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AlaShareInfo message.
         * @function verify
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlaShareInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.shareUserCount != null && message.hasOwnProperty("shareUserCount"))
                if (!$util.isInteger(message.shareUserCount))
                    return "shareUserCount: integer expected";
            if (message.shareCount != null && message.hasOwnProperty("shareCount"))
                if (!$util.isInteger(message.shareCount))
                    return "shareCount: integer expected";
            if (message.recordTid != null && message.hasOwnProperty("recordTid"))
                if (!$util.isInteger(message.recordTid) && !(message.recordTid && $util.isInteger(message.recordTid.low) && $util.isInteger(message.recordTid.high)))
                    return "recordTid: integer|Long expected";
            return null;
        };

        /**
         * Creates an AlaShareInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.AlaShareInfo} AlaShareInfo
         */
        AlaShareInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.AlaShareInfo)
                return object;
            let message = new $root.tieba.AlaShareInfo();
            if (object.content != null)
                message.content = String(object.content);
            if (object.shareUserCount != null)
                message.shareUserCount = object.shareUserCount | 0;
            if (object.shareCount != null)
                message.shareCount = object.shareCount | 0;
            if (object.recordTid != null)
                if ($util.Long)
                    (message.recordTid = $util.Long.fromValue(object.recordTid)).unsigned = false;
                else if (typeof object.recordTid === "string")
                    message.recordTid = parseInt(object.recordTid, 10);
                else if (typeof object.recordTid === "number")
                    message.recordTid = object.recordTid;
                else if (typeof object.recordTid === "object")
                    message.recordTid = new $util.LongBits(object.recordTid.low >>> 0, object.recordTid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AlaShareInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {tieba.AlaShareInfo} message AlaShareInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlaShareInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.content = "";
                object.shareUserCount = 0;
                object.shareCount = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.recordTid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.recordTid = options.longs === String ? "0" : 0;
            }
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.shareUserCount != null && message.hasOwnProperty("shareUserCount"))
                object.shareUserCount = message.shareUserCount;
            if (message.shareCount != null && message.hasOwnProperty("shareCount"))
                object.shareCount = message.shareCount;
            if (message.recordTid != null && message.hasOwnProperty("recordTid"))
                if (typeof message.recordTid === "number")
                    object.recordTid = options.longs === String ? String(message.recordTid) : message.recordTid;
                else
                    object.recordTid = options.longs === String ? $util.Long.prototype.toString.call(message.recordTid) : options.longs === Number ? new $util.LongBits(message.recordTid.low >>> 0, message.recordTid.high >>> 0).toNumber() : message.recordTid;
            return object;
        };

        /**
         * Converts this AlaShareInfo to JSON.
         * @function toJSON
         * @memberof tieba.AlaShareInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlaShareInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AlaShareInfo
         * @function getTypeUrl
         * @memberof tieba.AlaShareInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AlaShareInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.AlaShareInfo";
        };

        return AlaShareInfo;
    })();

    tieba.AlaStageDislikeInfo = (function() {

        /**
         * Properties of an AlaStageDislikeInfo.
         * @memberof tieba
         * @interface IAlaStageDislikeInfo
         * @property {string|null} [dislikeReason] AlaStageDislikeInfo dislikeReason
         * @property {number|null} [dislikeId] AlaStageDislikeInfo dislikeId
         */

        /**
         * Constructs a new AlaStageDislikeInfo.
         * @memberof tieba
         * @classdesc Represents an AlaStageDislikeInfo.
         * @implements IAlaStageDislikeInfo
         * @constructor
         * @param {tieba.IAlaStageDislikeInfo=} [properties] Properties to set
         */
        function AlaStageDislikeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AlaStageDislikeInfo dislikeReason.
         * @member {string} dislikeReason
         * @memberof tieba.AlaStageDislikeInfo
         * @instance
         */
        AlaStageDislikeInfo.prototype.dislikeReason = "";

        /**
         * AlaStageDislikeInfo dislikeId.
         * @member {number} dislikeId
         * @memberof tieba.AlaStageDislikeInfo
         * @instance
         */
        AlaStageDislikeInfo.prototype.dislikeId = 0;

        /**
         * Creates a new AlaStageDislikeInfo instance using the specified properties.
         * @function create
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {tieba.IAlaStageDislikeInfo=} [properties] Properties to set
         * @returns {tieba.AlaStageDislikeInfo} AlaStageDislikeInfo instance
         */
        AlaStageDislikeInfo.create = function create(properties) {
            return new AlaStageDislikeInfo(properties);
        };

        /**
         * Encodes the specified AlaStageDislikeInfo message. Does not implicitly {@link tieba.AlaStageDislikeInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {tieba.IAlaStageDislikeInfo} message AlaStageDislikeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaStageDislikeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dislikeReason != null && Object.hasOwnProperty.call(message, "dislikeReason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dislikeReason);
            if (message.dislikeId != null && Object.hasOwnProperty.call(message, "dislikeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dislikeId);
            return writer;
        };

        /**
         * Encodes the specified AlaStageDislikeInfo message, length delimited. Does not implicitly {@link tieba.AlaStageDislikeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {tieba.IAlaStageDislikeInfo} message AlaStageDislikeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaStageDislikeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AlaStageDislikeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.AlaStageDislikeInfo} AlaStageDislikeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaStageDislikeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.AlaStageDislikeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dislikeReason = reader.string();
                        break;
                    }
                case 2: {
                        message.dislikeId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AlaStageDislikeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.AlaStageDislikeInfo} AlaStageDislikeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaStageDislikeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AlaStageDislikeInfo message.
         * @function verify
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlaStageDislikeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
                if (!$util.isString(message.dislikeReason))
                    return "dislikeReason: string expected";
            if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
                if (!$util.isInteger(message.dislikeId))
                    return "dislikeId: integer expected";
            return null;
        };

        /**
         * Creates an AlaStageDislikeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.AlaStageDislikeInfo} AlaStageDislikeInfo
         */
        AlaStageDislikeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.AlaStageDislikeInfo)
                return object;
            let message = new $root.tieba.AlaStageDislikeInfo();
            if (object.dislikeReason != null)
                message.dislikeReason = String(object.dislikeReason);
            if (object.dislikeId != null)
                message.dislikeId = object.dislikeId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an AlaStageDislikeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {tieba.AlaStageDislikeInfo} message AlaStageDislikeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlaStageDislikeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.dislikeReason = "";
                object.dislikeId = 0;
            }
            if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
                object.dislikeReason = message.dislikeReason;
            if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
                object.dislikeId = message.dislikeId;
            return object;
        };

        /**
         * Converts this AlaStageDislikeInfo to JSON.
         * @function toJSON
         * @memberof tieba.AlaStageDislikeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlaStageDislikeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AlaStageDislikeInfo
         * @function getTypeUrl
         * @memberof tieba.AlaStageDislikeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AlaStageDislikeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.AlaStageDislikeInfo";
        };

        return AlaStageDislikeInfo;
    })();

    tieba.AlaUserInfo = (function() {

        /**
         * Properties of an AlaUserInfo.
         * @memberof tieba
         * @interface IAlaUserInfo
         * @property {number|Long|null} [alaId] AlaUserInfo alaId
         * @property {string|null} [userName] AlaUserInfo userName
         * @property {string|null} [portrait] AlaUserInfo portrait
         * @property {string|null} [description] AlaUserInfo description
         * @property {string|null} [sex] AlaUserInfo sex
         * @property {number|Long|null} [enterLive] AlaUserInfo enterLive
         * @property {number|Long|null} [anchorLive] AlaUserInfo anchorLive
         * @property {number|null} [liveStatus] AlaUserInfo liveStatus
         * @property {number|Long|null} [liveId] AlaUserInfo liveId
         * @property {string|null} [location] AlaUserInfo location
         * @property {number|null} [lng] AlaUserInfo lng
         * @property {number|null} [lat] AlaUserInfo lat
         * @property {number|null} [updateTime] AlaUserInfo updateTime
         * @property {number|Long|null} [charmCount] AlaUserInfo charmCount
         * @property {number|Long|null} [levelExp] AlaUserInfo levelExp
         * @property {number|null} [isOfficial] AlaUserInfo isOfficial
         * @property {string|null} [verifyStatus] AlaUserInfo verifyStatus
         * @property {number|null} [levelId] AlaUserInfo levelId
         * @property {string|null} [greatAnchorIcon] AlaUserInfo greatAnchorIcon
         * @property {string|null} [greatAnchorDescGrade] AlaUserInfo greatAnchorDescGrade
         * @property {string|null} [greatAnchorDescRole] AlaUserInfo greatAnchorDescRole
         * @property {string|null} [levelName] AlaUserInfo levelName
         * @property {number|Long|null} [userId] AlaUserInfo userId
         * @property {number|null} [anchorFans] AlaUserInfo anchorFans
         * @property {tieba.IYyExt|null} [yyExt] AlaUserInfo yyExt
         */

        /**
         * Constructs a new AlaUserInfo.
         * @memberof tieba
         * @classdesc Represents an AlaUserInfo.
         * @implements IAlaUserInfo
         * @constructor
         * @param {tieba.IAlaUserInfo=} [properties] Properties to set
         */
        function AlaUserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AlaUserInfo alaId.
         * @member {number|Long} alaId
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.alaId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaUserInfo userName.
         * @member {string} userName
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.userName = "";

        /**
         * AlaUserInfo portrait.
         * @member {string} portrait
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.portrait = "";

        /**
         * AlaUserInfo description.
         * @member {string} description
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.description = "";

        /**
         * AlaUserInfo sex.
         * @member {string} sex
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.sex = "";

        /**
         * AlaUserInfo enterLive.
         * @member {number|Long} enterLive
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.enterLive = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaUserInfo anchorLive.
         * @member {number|Long} anchorLive
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.anchorLive = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaUserInfo liveStatus.
         * @member {number} liveStatus
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.liveStatus = 0;

        /**
         * AlaUserInfo liveId.
         * @member {number|Long} liveId
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.liveId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaUserInfo location.
         * @member {string} location
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.location = "";

        /**
         * AlaUserInfo lng.
         * @member {number} lng
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.lng = 0;

        /**
         * AlaUserInfo lat.
         * @member {number} lat
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.lat = 0;

        /**
         * AlaUserInfo updateTime.
         * @member {number} updateTime
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.updateTime = 0;

        /**
         * AlaUserInfo charmCount.
         * @member {number|Long} charmCount
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.charmCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaUserInfo levelExp.
         * @member {number|Long} levelExp
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.levelExp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaUserInfo isOfficial.
         * @member {number} isOfficial
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.isOfficial = 0;

        /**
         * AlaUserInfo verifyStatus.
         * @member {string} verifyStatus
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.verifyStatus = "";

        /**
         * AlaUserInfo levelId.
         * @member {number} levelId
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.levelId = 0;

        /**
         * AlaUserInfo greatAnchorIcon.
         * @member {string} greatAnchorIcon
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.greatAnchorIcon = "";

        /**
         * AlaUserInfo greatAnchorDescGrade.
         * @member {string} greatAnchorDescGrade
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.greatAnchorDescGrade = "";

        /**
         * AlaUserInfo greatAnchorDescRole.
         * @member {string} greatAnchorDescRole
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.greatAnchorDescRole = "";

        /**
         * AlaUserInfo levelName.
         * @member {string} levelName
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.levelName = "";

        /**
         * AlaUserInfo userId.
         * @member {number|Long} userId
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AlaUserInfo anchorFans.
         * @member {number} anchorFans
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.anchorFans = 0;

        /**
         * AlaUserInfo yyExt.
         * @member {tieba.IYyExt|null|undefined} yyExt
         * @memberof tieba.AlaUserInfo
         * @instance
         */
        AlaUserInfo.prototype.yyExt = null;

        /**
         * Creates a new AlaUserInfo instance using the specified properties.
         * @function create
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {tieba.IAlaUserInfo=} [properties] Properties to set
         * @returns {tieba.AlaUserInfo} AlaUserInfo instance
         */
        AlaUserInfo.create = function create(properties) {
            return new AlaUserInfo(properties);
        };

        /**
         * Encodes the specified AlaUserInfo message. Does not implicitly {@link tieba.AlaUserInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {tieba.IAlaUserInfo} message AlaUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alaId != null && Object.hasOwnProperty.call(message, "alaId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.alaId);
            if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.userName);
            if (message.portrait != null && Object.hasOwnProperty.call(message, "portrait"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.portrait);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
            if (message.sex != null && Object.hasOwnProperty.call(message, "sex"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.sex);
            if (message.enterLive != null && Object.hasOwnProperty.call(message, "enterLive"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.enterLive);
            if (message.anchorLive != null && Object.hasOwnProperty.call(message, "anchorLive"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.anchorLive);
            if (message.liveStatus != null && Object.hasOwnProperty.call(message, "liveStatus"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.liveStatus);
            if (message.liveId != null && Object.hasOwnProperty.call(message, "liveId"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.liveId);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.location);
            if (message.lng != null && Object.hasOwnProperty.call(message, "lng"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.lng);
            if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.lat);
            if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.updateTime);
            if (message.charmCount != null && Object.hasOwnProperty.call(message, "charmCount"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.charmCount);
            if (message.levelExp != null && Object.hasOwnProperty.call(message, "levelExp"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.levelExp);
            if (message.isOfficial != null && Object.hasOwnProperty.call(message, "isOfficial"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.isOfficial);
            if (message.verifyStatus != null && Object.hasOwnProperty.call(message, "verifyStatus"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.verifyStatus);
            if (message.levelId != null && Object.hasOwnProperty.call(message, "levelId"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.levelId);
            if (message.greatAnchorIcon != null && Object.hasOwnProperty.call(message, "greatAnchorIcon"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.greatAnchorIcon);
            if (message.greatAnchorDescGrade != null && Object.hasOwnProperty.call(message, "greatAnchorDescGrade"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.greatAnchorDescGrade);
            if (message.greatAnchorDescRole != null && Object.hasOwnProperty.call(message, "greatAnchorDescRole"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.greatAnchorDescRole);
            if (message.levelName != null && Object.hasOwnProperty.call(message, "levelName"))
                writer.uint32(/* id 22, wireType 2 =*/178).string(message.levelName);
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint64(message.userId);
            if (message.anchorFans != null && Object.hasOwnProperty.call(message, "anchorFans"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.anchorFans);
            if (message.yyExt != null && Object.hasOwnProperty.call(message, "yyExt"))
                $root.tieba.YyExt.encode(message.yyExt, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AlaUserInfo message, length delimited. Does not implicitly {@link tieba.AlaUserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {tieba.IAlaUserInfo} message AlaUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AlaUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AlaUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.AlaUserInfo} AlaUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.AlaUserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.alaId = reader.uint64();
                        break;
                    }
                case 2: {
                        message.userName = reader.string();
                        break;
                    }
                case 3: {
                        message.portrait = reader.string();
                        break;
                    }
                case 4: {
                        message.description = reader.string();
                        break;
                    }
                case 5: {
                        message.sex = reader.string();
                        break;
                    }
                case 6: {
                        message.enterLive = reader.uint64();
                        break;
                    }
                case 7: {
                        message.anchorLive = reader.uint64();
                        break;
                    }
                case 8: {
                        message.liveStatus = reader.uint32();
                        break;
                    }
                case 9: {
                        message.liveId = reader.uint64();
                        break;
                    }
                case 10: {
                        message.location = reader.string();
                        break;
                    }
                case 11: {
                        message.lng = reader.double();
                        break;
                    }
                case 12: {
                        message.lat = reader.double();
                        break;
                    }
                case 13: {
                        message.updateTime = reader.uint32();
                        break;
                    }
                case 14: {
                        message.charmCount = reader.uint64();
                        break;
                    }
                case 15: {
                        message.levelExp = reader.uint64();
                        break;
                    }
                case 16: {
                        message.isOfficial = reader.uint32();
                        break;
                    }
                case 17: {
                        message.verifyStatus = reader.string();
                        break;
                    }
                case 18: {
                        message.levelId = reader.uint32();
                        break;
                    }
                case 19: {
                        message.greatAnchorIcon = reader.string();
                        break;
                    }
                case 20: {
                        message.greatAnchorDescGrade = reader.string();
                        break;
                    }
                case 21: {
                        message.greatAnchorDescRole = reader.string();
                        break;
                    }
                case 22: {
                        message.levelName = reader.string();
                        break;
                    }
                case 23: {
                        message.userId = reader.uint64();
                        break;
                    }
                case 24: {
                        message.anchorFans = reader.int32();
                        break;
                    }
                case 25: {
                        message.yyExt = $root.tieba.YyExt.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AlaUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.AlaUserInfo} AlaUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AlaUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AlaUserInfo message.
         * @function verify
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AlaUserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alaId != null && message.hasOwnProperty("alaId"))
                if (!$util.isInteger(message.alaId) && !(message.alaId && $util.isInteger(message.alaId.low) && $util.isInteger(message.alaId.high)))
                    return "alaId: integer|Long expected";
            if (message.userName != null && message.hasOwnProperty("userName"))
                if (!$util.isString(message.userName))
                    return "userName: string expected";
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                if (!$util.isString(message.portrait))
                    return "portrait: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.sex != null && message.hasOwnProperty("sex"))
                if (!$util.isString(message.sex))
                    return "sex: string expected";
            if (message.enterLive != null && message.hasOwnProperty("enterLive"))
                if (!$util.isInteger(message.enterLive) && !(message.enterLive && $util.isInteger(message.enterLive.low) && $util.isInteger(message.enterLive.high)))
                    return "enterLive: integer|Long expected";
            if (message.anchorLive != null && message.hasOwnProperty("anchorLive"))
                if (!$util.isInteger(message.anchorLive) && !(message.anchorLive && $util.isInteger(message.anchorLive.low) && $util.isInteger(message.anchorLive.high)))
                    return "anchorLive: integer|Long expected";
            if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
                if (!$util.isInteger(message.liveStatus))
                    return "liveStatus: integer expected";
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                if (!$util.isInteger(message.liveId) && !(message.liveId && $util.isInteger(message.liveId.low) && $util.isInteger(message.liveId.high)))
                    return "liveId: integer|Long expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            if (message.lng != null && message.hasOwnProperty("lng"))
                if (typeof message.lng !== "number")
                    return "lng: number expected";
            if (message.lat != null && message.hasOwnProperty("lat"))
                if (typeof message.lat !== "number")
                    return "lat: number expected";
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                if (!$util.isInteger(message.updateTime))
                    return "updateTime: integer expected";
            if (message.charmCount != null && message.hasOwnProperty("charmCount"))
                if (!$util.isInteger(message.charmCount) && !(message.charmCount && $util.isInteger(message.charmCount.low) && $util.isInteger(message.charmCount.high)))
                    return "charmCount: integer|Long expected";
            if (message.levelExp != null && message.hasOwnProperty("levelExp"))
                if (!$util.isInteger(message.levelExp) && !(message.levelExp && $util.isInteger(message.levelExp.low) && $util.isInteger(message.levelExp.high)))
                    return "levelExp: integer|Long expected";
            if (message.isOfficial != null && message.hasOwnProperty("isOfficial"))
                if (!$util.isInteger(message.isOfficial))
                    return "isOfficial: integer expected";
            if (message.verifyStatus != null && message.hasOwnProperty("verifyStatus"))
                if (!$util.isString(message.verifyStatus))
                    return "verifyStatus: string expected";
            if (message.levelId != null && message.hasOwnProperty("levelId"))
                if (!$util.isInteger(message.levelId))
                    return "levelId: integer expected";
            if (message.greatAnchorIcon != null && message.hasOwnProperty("greatAnchorIcon"))
                if (!$util.isString(message.greatAnchorIcon))
                    return "greatAnchorIcon: string expected";
            if (message.greatAnchorDescGrade != null && message.hasOwnProperty("greatAnchorDescGrade"))
                if (!$util.isString(message.greatAnchorDescGrade))
                    return "greatAnchorDescGrade: string expected";
            if (message.greatAnchorDescRole != null && message.hasOwnProperty("greatAnchorDescRole"))
                if (!$util.isString(message.greatAnchorDescRole))
                    return "greatAnchorDescRole: string expected";
            if (message.levelName != null && message.hasOwnProperty("levelName"))
                if (!$util.isString(message.levelName))
                    return "levelName: string expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            if (message.anchorFans != null && message.hasOwnProperty("anchorFans"))
                if (!$util.isInteger(message.anchorFans))
                    return "anchorFans: integer expected";
            if (message.yyExt != null && message.hasOwnProperty("yyExt")) {
                let error = $root.tieba.YyExt.verify(message.yyExt);
                if (error)
                    return "yyExt." + error;
            }
            return null;
        };

        /**
         * Creates an AlaUserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.AlaUserInfo} AlaUserInfo
         */
        AlaUserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.AlaUserInfo)
                return object;
            let message = new $root.tieba.AlaUserInfo();
            if (object.alaId != null)
                if ($util.Long)
                    (message.alaId = $util.Long.fromValue(object.alaId)).unsigned = true;
                else if (typeof object.alaId === "string")
                    message.alaId = parseInt(object.alaId, 10);
                else if (typeof object.alaId === "number")
                    message.alaId = object.alaId;
                else if (typeof object.alaId === "object")
                    message.alaId = new $util.LongBits(object.alaId.low >>> 0, object.alaId.high >>> 0).toNumber(true);
            if (object.userName != null)
                message.userName = String(object.userName);
            if (object.portrait != null)
                message.portrait = String(object.portrait);
            if (object.description != null)
                message.description = String(object.description);
            if (object.sex != null)
                message.sex = String(object.sex);
            if (object.enterLive != null)
                if ($util.Long)
                    (message.enterLive = $util.Long.fromValue(object.enterLive)).unsigned = true;
                else if (typeof object.enterLive === "string")
                    message.enterLive = parseInt(object.enterLive, 10);
                else if (typeof object.enterLive === "number")
                    message.enterLive = object.enterLive;
                else if (typeof object.enterLive === "object")
                    message.enterLive = new $util.LongBits(object.enterLive.low >>> 0, object.enterLive.high >>> 0).toNumber(true);
            if (object.anchorLive != null)
                if ($util.Long)
                    (message.anchorLive = $util.Long.fromValue(object.anchorLive)).unsigned = true;
                else if (typeof object.anchorLive === "string")
                    message.anchorLive = parseInt(object.anchorLive, 10);
                else if (typeof object.anchorLive === "number")
                    message.anchorLive = object.anchorLive;
                else if (typeof object.anchorLive === "object")
                    message.anchorLive = new $util.LongBits(object.anchorLive.low >>> 0, object.anchorLive.high >>> 0).toNumber(true);
            if (object.liveStatus != null)
                message.liveStatus = object.liveStatus >>> 0;
            if (object.liveId != null)
                if ($util.Long)
                    (message.liveId = $util.Long.fromValue(object.liveId)).unsigned = true;
                else if (typeof object.liveId === "string")
                    message.liveId = parseInt(object.liveId, 10);
                else if (typeof object.liveId === "number")
                    message.liveId = object.liveId;
                else if (typeof object.liveId === "object")
                    message.liveId = new $util.LongBits(object.liveId.low >>> 0, object.liveId.high >>> 0).toNumber(true);
            if (object.location != null)
                message.location = String(object.location);
            if (object.lng != null)
                message.lng = Number(object.lng);
            if (object.lat != null)
                message.lat = Number(object.lat);
            if (object.updateTime != null)
                message.updateTime = object.updateTime >>> 0;
            if (object.charmCount != null)
                if ($util.Long)
                    (message.charmCount = $util.Long.fromValue(object.charmCount)).unsigned = true;
                else if (typeof object.charmCount === "string")
                    message.charmCount = parseInt(object.charmCount, 10);
                else if (typeof object.charmCount === "number")
                    message.charmCount = object.charmCount;
                else if (typeof object.charmCount === "object")
                    message.charmCount = new $util.LongBits(object.charmCount.low >>> 0, object.charmCount.high >>> 0).toNumber(true);
            if (object.levelExp != null)
                if ($util.Long)
                    (message.levelExp = $util.Long.fromValue(object.levelExp)).unsigned = true;
                else if (typeof object.levelExp === "string")
                    message.levelExp = parseInt(object.levelExp, 10);
                else if (typeof object.levelExp === "number")
                    message.levelExp = object.levelExp;
                else if (typeof object.levelExp === "object")
                    message.levelExp = new $util.LongBits(object.levelExp.low >>> 0, object.levelExp.high >>> 0).toNumber(true);
            if (object.isOfficial != null)
                message.isOfficial = object.isOfficial >>> 0;
            if (object.verifyStatus != null)
                message.verifyStatus = String(object.verifyStatus);
            if (object.levelId != null)
                message.levelId = object.levelId >>> 0;
            if (object.greatAnchorIcon != null)
                message.greatAnchorIcon = String(object.greatAnchorIcon);
            if (object.greatAnchorDescGrade != null)
                message.greatAnchorDescGrade = String(object.greatAnchorDescGrade);
            if (object.greatAnchorDescRole != null)
                message.greatAnchorDescRole = String(object.greatAnchorDescRole);
            if (object.levelName != null)
                message.levelName = String(object.levelName);
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = true;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber(true);
            if (object.anchorFans != null)
                message.anchorFans = object.anchorFans | 0;
            if (object.yyExt != null) {
                if (typeof object.yyExt !== "object")
                    throw TypeError(".tieba.AlaUserInfo.yyExt: object expected");
                message.yyExt = $root.tieba.YyExt.fromObject(object.yyExt);
            }
            return message;
        };

        /**
         * Creates a plain object from an AlaUserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {tieba.AlaUserInfo} message AlaUserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AlaUserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.alaId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.alaId = options.longs === String ? "0" : 0;
                object.userName = "";
                object.portrait = "";
                object.description = "";
                object.sex = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.enterLive = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterLive = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.anchorLive = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.anchorLive = options.longs === String ? "0" : 0;
                object.liveStatus = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.liveId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.liveId = options.longs === String ? "0" : 0;
                object.location = "";
                object.lng = 0;
                object.lat = 0;
                object.updateTime = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.charmCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.charmCount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.levelExp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.levelExp = options.longs === String ? "0" : 0;
                object.isOfficial = 0;
                object.verifyStatus = "";
                object.levelId = 0;
                object.greatAnchorIcon = "";
                object.greatAnchorDescGrade = "";
                object.greatAnchorDescRole = "";
                object.levelName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
                object.anchorFans = 0;
                object.yyExt = null;
            }
            if (message.alaId != null && message.hasOwnProperty("alaId"))
                if (typeof message.alaId === "number")
                    object.alaId = options.longs === String ? String(message.alaId) : message.alaId;
                else
                    object.alaId = options.longs === String ? $util.Long.prototype.toString.call(message.alaId) : options.longs === Number ? new $util.LongBits(message.alaId.low >>> 0, message.alaId.high >>> 0).toNumber(true) : message.alaId;
            if (message.userName != null && message.hasOwnProperty("userName"))
                object.userName = message.userName;
            if (message.portrait != null && message.hasOwnProperty("portrait"))
                object.portrait = message.portrait;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.sex != null && message.hasOwnProperty("sex"))
                object.sex = message.sex;
            if (message.enterLive != null && message.hasOwnProperty("enterLive"))
                if (typeof message.enterLive === "number")
                    object.enterLive = options.longs === String ? String(message.enterLive) : message.enterLive;
                else
                    object.enterLive = options.longs === String ? $util.Long.prototype.toString.call(message.enterLive) : options.longs === Number ? new $util.LongBits(message.enterLive.low >>> 0, message.enterLive.high >>> 0).toNumber(true) : message.enterLive;
            if (message.anchorLive != null && message.hasOwnProperty("anchorLive"))
                if (typeof message.anchorLive === "number")
                    object.anchorLive = options.longs === String ? String(message.anchorLive) : message.anchorLive;
                else
                    object.anchorLive = options.longs === String ? $util.Long.prototype.toString.call(message.anchorLive) : options.longs === Number ? new $util.LongBits(message.anchorLive.low >>> 0, message.anchorLive.high >>> 0).toNumber(true) : message.anchorLive;
            if (message.liveStatus != null && message.hasOwnProperty("liveStatus"))
                object.liveStatus = message.liveStatus;
            if (message.liveId != null && message.hasOwnProperty("liveId"))
                if (typeof message.liveId === "number")
                    object.liveId = options.longs === String ? String(message.liveId) : message.liveId;
                else
                    object.liveId = options.longs === String ? $util.Long.prototype.toString.call(message.liveId) : options.longs === Number ? new $util.LongBits(message.liveId.low >>> 0, message.liveId.high >>> 0).toNumber(true) : message.liveId;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            if (message.lng != null && message.hasOwnProperty("lng"))
                object.lng = options.json && !isFinite(message.lng) ? String(message.lng) : message.lng;
            if (message.lat != null && message.hasOwnProperty("lat"))
                object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.charmCount != null && message.hasOwnProperty("charmCount"))
                if (typeof message.charmCount === "number")
                    object.charmCount = options.longs === String ? String(message.charmCount) : message.charmCount;
                else
                    object.charmCount = options.longs === String ? $util.Long.prototype.toString.call(message.charmCount) : options.longs === Number ? new $util.LongBits(message.charmCount.low >>> 0, message.charmCount.high >>> 0).toNumber(true) : message.charmCount;
            if (message.levelExp != null && message.hasOwnProperty("levelExp"))
                if (typeof message.levelExp === "number")
                    object.levelExp = options.longs === String ? String(message.levelExp) : message.levelExp;
                else
                    object.levelExp = options.longs === String ? $util.Long.prototype.toString.call(message.levelExp) : options.longs === Number ? new $util.LongBits(message.levelExp.low >>> 0, message.levelExp.high >>> 0).toNumber(true) : message.levelExp;
            if (message.isOfficial != null && message.hasOwnProperty("isOfficial"))
                object.isOfficial = message.isOfficial;
            if (message.verifyStatus != null && message.hasOwnProperty("verifyStatus"))
                object.verifyStatus = message.verifyStatus;
            if (message.levelId != null && message.hasOwnProperty("levelId"))
                object.levelId = message.levelId;
            if (message.greatAnchorIcon != null && message.hasOwnProperty("greatAnchorIcon"))
                object.greatAnchorIcon = message.greatAnchorIcon;
            if (message.greatAnchorDescGrade != null && message.hasOwnProperty("greatAnchorDescGrade"))
                object.greatAnchorDescGrade = message.greatAnchorDescGrade;
            if (message.greatAnchorDescRole != null && message.hasOwnProperty("greatAnchorDescRole"))
                object.greatAnchorDescRole = message.greatAnchorDescRole;
            if (message.levelName != null && message.hasOwnProperty("levelName"))
                object.levelName = message.levelName;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber(true) : message.userId;
            if (message.anchorFans != null && message.hasOwnProperty("anchorFans"))
                object.anchorFans = message.anchorFans;
            if (message.yyExt != null && message.hasOwnProperty("yyExt"))
                object.yyExt = $root.tieba.YyExt.toObject(message.yyExt, options);
            return object;
        };

        /**
         * Converts this AlaUserInfo to JSON.
         * @function toJSON
         * @memberof tieba.AlaUserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AlaUserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AlaUserInfo
         * @function getTypeUrl
         * @memberof tieba.AlaUserInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AlaUserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.AlaUserInfo";
        };

        return AlaUserInfo;
    })();

    tieba.YyExt = (function() {

        /**
         * Properties of a YyExt.
         * @memberof tieba
         * @interface IYyExt
         * @property {string|null} [sid] YyExt sid
         * @property {string|null} [ssid] YyExt ssid
         * @property {string|null} [templateId] YyExt templateId
         * @property {string|null} [yyUid] YyExt yyUid
         * @property {number|null} [isYyGame] YyExt isYyGame
         * @property {string|null} [streamInfo] YyExt streamInfo
         * @property {string|null} [rankShow] YyExt rankShow
         * @property {string|null} [iconUrl] YyExt iconUrl
         */

        /**
         * Constructs a new YyExt.
         * @memberof tieba
         * @classdesc Represents a YyExt.
         * @implements IYyExt
         * @constructor
         * @param {tieba.IYyExt=} [properties] Properties to set
         */
        function YyExt(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * YyExt sid.
         * @member {string} sid
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.sid = "";

        /**
         * YyExt ssid.
         * @member {string} ssid
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.ssid = "";

        /**
         * YyExt templateId.
         * @member {string} templateId
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.templateId = "";

        /**
         * YyExt yyUid.
         * @member {string} yyUid
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.yyUid = "";

        /**
         * YyExt isYyGame.
         * @member {number} isYyGame
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.isYyGame = 0;

        /**
         * YyExt streamInfo.
         * @member {string} streamInfo
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.streamInfo = "";

        /**
         * YyExt rankShow.
         * @member {string} rankShow
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.rankShow = "";

        /**
         * YyExt iconUrl.
         * @member {string} iconUrl
         * @memberof tieba.YyExt
         * @instance
         */
        YyExt.prototype.iconUrl = "";

        /**
         * Creates a new YyExt instance using the specified properties.
         * @function create
         * @memberof tieba.YyExt
         * @static
         * @param {tieba.IYyExt=} [properties] Properties to set
         * @returns {tieba.YyExt} YyExt instance
         */
        YyExt.create = function create(properties) {
            return new YyExt(properties);
        };

        /**
         * Encodes the specified YyExt message. Does not implicitly {@link tieba.YyExt.verify|verify} messages.
         * @function encode
         * @memberof tieba.YyExt
         * @static
         * @param {tieba.IYyExt} message YyExt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        YyExt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sid);
            if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ssid);
            if (message.templateId != null && Object.hasOwnProperty.call(message, "templateId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.templateId);
            if (message.yyUid != null && Object.hasOwnProperty.call(message, "yyUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.yyUid);
            if (message.isYyGame != null && Object.hasOwnProperty.call(message, "isYyGame"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.isYyGame);
            if (message.streamInfo != null && Object.hasOwnProperty.call(message, "streamInfo"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.streamInfo);
            if (message.rankShow != null && Object.hasOwnProperty.call(message, "rankShow"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.rankShow);
            if (message.iconUrl != null && Object.hasOwnProperty.call(message, "iconUrl"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.iconUrl);
            return writer;
        };

        /**
         * Encodes the specified YyExt message, length delimited. Does not implicitly {@link tieba.YyExt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.YyExt
         * @static
         * @param {tieba.IYyExt} message YyExt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        YyExt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a YyExt message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.YyExt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.YyExt} YyExt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        YyExt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.YyExt();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.sid = reader.string();
                        break;
                    }
                case 2: {
                        message.ssid = reader.string();
                        break;
                    }
                case 3: {
                        message.templateId = reader.string();
                        break;
                    }
                case 4: {
                        message.yyUid = reader.string();
                        break;
                    }
                case 5: {
                        message.isYyGame = reader.int32();
                        break;
                    }
                case 6: {
                        message.streamInfo = reader.string();
                        break;
                    }
                case 7: {
                        message.rankShow = reader.string();
                        break;
                    }
                case 8: {
                        message.iconUrl = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a YyExt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.YyExt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.YyExt} YyExt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        YyExt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a YyExt message.
         * @function verify
         * @memberof tieba.YyExt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        YyExt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sid != null && message.hasOwnProperty("sid"))
                if (!$util.isString(message.sid))
                    return "sid: string expected";
            if (message.ssid != null && message.hasOwnProperty("ssid"))
                if (!$util.isString(message.ssid))
                    return "ssid: string expected";
            if (message.templateId != null && message.hasOwnProperty("templateId"))
                if (!$util.isString(message.templateId))
                    return "templateId: string expected";
            if (message.yyUid != null && message.hasOwnProperty("yyUid"))
                if (!$util.isString(message.yyUid))
                    return "yyUid: string expected";
            if (message.isYyGame != null && message.hasOwnProperty("isYyGame"))
                if (!$util.isInteger(message.isYyGame))
                    return "isYyGame: integer expected";
            if (message.streamInfo != null && message.hasOwnProperty("streamInfo"))
                if (!$util.isString(message.streamInfo))
                    return "streamInfo: string expected";
            if (message.rankShow != null && message.hasOwnProperty("rankShow"))
                if (!$util.isString(message.rankShow))
                    return "rankShow: string expected";
            if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                if (!$util.isString(message.iconUrl))
                    return "iconUrl: string expected";
            return null;
        };

        /**
         * Creates a YyExt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.YyExt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.YyExt} YyExt
         */
        YyExt.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.YyExt)
                return object;
            let message = new $root.tieba.YyExt();
            if (object.sid != null)
                message.sid = String(object.sid);
            if (object.ssid != null)
                message.ssid = String(object.ssid);
            if (object.templateId != null)
                message.templateId = String(object.templateId);
            if (object.yyUid != null)
                message.yyUid = String(object.yyUid);
            if (object.isYyGame != null)
                message.isYyGame = object.isYyGame | 0;
            if (object.streamInfo != null)
                message.streamInfo = String(object.streamInfo);
            if (object.rankShow != null)
                message.rankShow = String(object.rankShow);
            if (object.iconUrl != null)
                message.iconUrl = String(object.iconUrl);
            return message;
        };

        /**
         * Creates a plain object from a YyExt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.YyExt
         * @static
         * @param {tieba.YyExt} message YyExt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        YyExt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.sid = "";
                object.ssid = "";
                object.templateId = "";
                object.yyUid = "";
                object.isYyGame = 0;
                object.streamInfo = "";
                object.rankShow = "";
                object.iconUrl = "";
            }
            if (message.sid != null && message.hasOwnProperty("sid"))
                object.sid = message.sid;
            if (message.ssid != null && message.hasOwnProperty("ssid"))
                object.ssid = message.ssid;
            if (message.templateId != null && message.hasOwnProperty("templateId"))
                object.templateId = message.templateId;
            if (message.yyUid != null && message.hasOwnProperty("yyUid"))
                object.yyUid = message.yyUid;
            if (message.isYyGame != null && message.hasOwnProperty("isYyGame"))
                object.isYyGame = message.isYyGame;
            if (message.streamInfo != null && message.hasOwnProperty("streamInfo"))
                object.streamInfo = message.streamInfo;
            if (message.rankShow != null && message.hasOwnProperty("rankShow"))
                object.rankShow = message.rankShow;
            if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                object.iconUrl = message.iconUrl;
            return object;
        };

        /**
         * Converts this YyExt to JSON.
         * @function toJSON
         * @memberof tieba.YyExt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        YyExt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for YyExt
         * @function getTypeUrl
         * @memberof tieba.YyExt
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        YyExt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.YyExt";
        };

        return YyExt;
    })();

    tieba.DislikeInfo = (function() {

        /**
         * Properties of a DislikeInfo.
         * @memberof tieba
         * @interface IDislikeInfo
         * @property {string|null} [dislikeReason] DislikeInfo dislikeReason
         * @property {number|null} [dislikeId] DislikeInfo dislikeId
         * @property {string|null} [extra] DislikeInfo extra
         */

        /**
         * Constructs a new DislikeInfo.
         * @memberof tieba
         * @classdesc Represents a DislikeInfo.
         * @implements IDislikeInfo
         * @constructor
         * @param {tieba.IDislikeInfo=} [properties] Properties to set
         */
        function DislikeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DislikeInfo dislikeReason.
         * @member {string} dislikeReason
         * @memberof tieba.DislikeInfo
         * @instance
         */
        DislikeInfo.prototype.dislikeReason = "";

        /**
         * DislikeInfo dislikeId.
         * @member {number} dislikeId
         * @memberof tieba.DislikeInfo
         * @instance
         */
        DislikeInfo.prototype.dislikeId = 0;

        /**
         * DislikeInfo extra.
         * @member {string} extra
         * @memberof tieba.DislikeInfo
         * @instance
         */
        DislikeInfo.prototype.extra = "";

        /**
         * Creates a new DislikeInfo instance using the specified properties.
         * @function create
         * @memberof tieba.DislikeInfo
         * @static
         * @param {tieba.IDislikeInfo=} [properties] Properties to set
         * @returns {tieba.DislikeInfo} DislikeInfo instance
         */
        DislikeInfo.create = function create(properties) {
            return new DislikeInfo(properties);
        };

        /**
         * Encodes the specified DislikeInfo message. Does not implicitly {@link tieba.DislikeInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.DislikeInfo
         * @static
         * @param {tieba.IDislikeInfo} message DislikeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DislikeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dislikeReason != null && Object.hasOwnProperty.call(message, "dislikeReason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dislikeReason);
            if (message.dislikeId != null && Object.hasOwnProperty.call(message, "dislikeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dislikeId);
            if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.extra);
            return writer;
        };

        /**
         * Encodes the specified DislikeInfo message, length delimited. Does not implicitly {@link tieba.DislikeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.DislikeInfo
         * @static
         * @param {tieba.IDislikeInfo} message DislikeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DislikeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DislikeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.DislikeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.DislikeInfo} DislikeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DislikeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.DislikeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dislikeReason = reader.string();
                        break;
                    }
                case 2: {
                        message.dislikeId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.extra = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DislikeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.DislikeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.DislikeInfo} DislikeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DislikeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DislikeInfo message.
         * @function verify
         * @memberof tieba.DislikeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DislikeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
                if (!$util.isString(message.dislikeReason))
                    return "dislikeReason: string expected";
            if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
                if (!$util.isInteger(message.dislikeId))
                    return "dislikeId: integer expected";
            if (message.extra != null && message.hasOwnProperty("extra"))
                if (!$util.isString(message.extra))
                    return "extra: string expected";
            return null;
        };

        /**
         * Creates a DislikeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.DislikeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.DislikeInfo} DislikeInfo
         */
        DislikeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.DislikeInfo)
                return object;
            let message = new $root.tieba.DislikeInfo();
            if (object.dislikeReason != null)
                message.dislikeReason = String(object.dislikeReason);
            if (object.dislikeId != null)
                message.dislikeId = object.dislikeId >>> 0;
            if (object.extra != null)
                message.extra = String(object.extra);
            return message;
        };

        /**
         * Creates a plain object from a DislikeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.DislikeInfo
         * @static
         * @param {tieba.DislikeInfo} message DislikeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DislikeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.dislikeReason = "";
                object.dislikeId = 0;
                object.extra = "";
            }
            if (message.dislikeReason != null && message.hasOwnProperty("dislikeReason"))
                object.dislikeReason = message.dislikeReason;
            if (message.dislikeId != null && message.hasOwnProperty("dislikeId"))
                object.dislikeId = message.dislikeId;
            if (message.extra != null && message.hasOwnProperty("extra"))
                object.extra = message.extra;
            return object;
        };

        /**
         * Converts this DislikeInfo to JSON.
         * @function toJSON
         * @memberof tieba.DislikeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DislikeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DislikeInfo
         * @function getTypeUrl
         * @memberof tieba.DislikeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DislikeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.DislikeInfo";
        };

        return DislikeInfo;
    })();

    tieba.Baijiahao = (function() {

        /**
         * Properties of a Baijiahao.
         * @memberof tieba
         * @interface IBaijiahao
         * @property {string|null} [oriUgcNid] Baijiahao oriUgcNid
         * @property {string|null} [oriUgcTid] Baijiahao oriUgcTid
         * @property {number|null} [oriUgcType] Baijiahao oriUgcType
         * @property {string|null} [oriUgcVid] Baijiahao oriUgcVid
         * @property {string|null} [forwardUrl] Baijiahao forwardUrl
         */

        /**
         * Constructs a new Baijiahao.
         * @memberof tieba
         * @classdesc Represents a Baijiahao.
         * @implements IBaijiahao
         * @constructor
         * @param {tieba.IBaijiahao=} [properties] Properties to set
         */
        function Baijiahao(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Baijiahao oriUgcNid.
         * @member {string} oriUgcNid
         * @memberof tieba.Baijiahao
         * @instance
         */
        Baijiahao.prototype.oriUgcNid = "";

        /**
         * Baijiahao oriUgcTid.
         * @member {string} oriUgcTid
         * @memberof tieba.Baijiahao
         * @instance
         */
        Baijiahao.prototype.oriUgcTid = "";

        /**
         * Baijiahao oriUgcType.
         * @member {number} oriUgcType
         * @memberof tieba.Baijiahao
         * @instance
         */
        Baijiahao.prototype.oriUgcType = 0;

        /**
         * Baijiahao oriUgcVid.
         * @member {string} oriUgcVid
         * @memberof tieba.Baijiahao
         * @instance
         */
        Baijiahao.prototype.oriUgcVid = "";

        /**
         * Baijiahao forwardUrl.
         * @member {string} forwardUrl
         * @memberof tieba.Baijiahao
         * @instance
         */
        Baijiahao.prototype.forwardUrl = "";

        /**
         * Creates a new Baijiahao instance using the specified properties.
         * @function create
         * @memberof tieba.Baijiahao
         * @static
         * @param {tieba.IBaijiahao=} [properties] Properties to set
         * @returns {tieba.Baijiahao} Baijiahao instance
         */
        Baijiahao.create = function create(properties) {
            return new Baijiahao(properties);
        };

        /**
         * Encodes the specified Baijiahao message. Does not implicitly {@link tieba.Baijiahao.verify|verify} messages.
         * @function encode
         * @memberof tieba.Baijiahao
         * @static
         * @param {tieba.IBaijiahao} message Baijiahao message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Baijiahao.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.oriUgcNid != null && Object.hasOwnProperty.call(message, "oriUgcNid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.oriUgcNid);
            if (message.oriUgcTid != null && Object.hasOwnProperty.call(message, "oriUgcTid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.oriUgcTid);
            if (message.oriUgcType != null && Object.hasOwnProperty.call(message, "oriUgcType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.oriUgcType);
            if (message.oriUgcVid != null && Object.hasOwnProperty.call(message, "oriUgcVid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.oriUgcVid);
            if (message.forwardUrl != null && Object.hasOwnProperty.call(message, "forwardUrl"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.forwardUrl);
            return writer;
        };

        /**
         * Encodes the specified Baijiahao message, length delimited. Does not implicitly {@link tieba.Baijiahao.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Baijiahao
         * @static
         * @param {tieba.IBaijiahao} message Baijiahao message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Baijiahao.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Baijiahao message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Baijiahao
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Baijiahao} Baijiahao
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Baijiahao.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Baijiahao();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.oriUgcNid = reader.string();
                        break;
                    }
                case 2: {
                        message.oriUgcTid = reader.string();
                        break;
                    }
                case 3: {
                        message.oriUgcType = reader.int32();
                        break;
                    }
                case 4: {
                        message.oriUgcVid = reader.string();
                        break;
                    }
                case 5: {
                        message.forwardUrl = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Baijiahao message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Baijiahao
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Baijiahao} Baijiahao
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Baijiahao.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Baijiahao message.
         * @function verify
         * @memberof tieba.Baijiahao
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Baijiahao.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.oriUgcNid != null && message.hasOwnProperty("oriUgcNid"))
                if (!$util.isString(message.oriUgcNid))
                    return "oriUgcNid: string expected";
            if (message.oriUgcTid != null && message.hasOwnProperty("oriUgcTid"))
                if (!$util.isString(message.oriUgcTid))
                    return "oriUgcTid: string expected";
            if (message.oriUgcType != null && message.hasOwnProperty("oriUgcType"))
                if (!$util.isInteger(message.oriUgcType))
                    return "oriUgcType: integer expected";
            if (message.oriUgcVid != null && message.hasOwnProperty("oriUgcVid"))
                if (!$util.isString(message.oriUgcVid))
                    return "oriUgcVid: string expected";
            if (message.forwardUrl != null && message.hasOwnProperty("forwardUrl"))
                if (!$util.isString(message.forwardUrl))
                    return "forwardUrl: string expected";
            return null;
        };

        /**
         * Creates a Baijiahao message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Baijiahao
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Baijiahao} Baijiahao
         */
        Baijiahao.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Baijiahao)
                return object;
            let message = new $root.tieba.Baijiahao();
            if (object.oriUgcNid != null)
                message.oriUgcNid = String(object.oriUgcNid);
            if (object.oriUgcTid != null)
                message.oriUgcTid = String(object.oriUgcTid);
            if (object.oriUgcType != null)
                message.oriUgcType = object.oriUgcType | 0;
            if (object.oriUgcVid != null)
                message.oriUgcVid = String(object.oriUgcVid);
            if (object.forwardUrl != null)
                message.forwardUrl = String(object.forwardUrl);
            return message;
        };

        /**
         * Creates a plain object from a Baijiahao message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Baijiahao
         * @static
         * @param {tieba.Baijiahao} message Baijiahao
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Baijiahao.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.oriUgcNid = "";
                object.oriUgcTid = "";
                object.oriUgcType = 0;
                object.oriUgcVid = "";
                object.forwardUrl = "";
            }
            if (message.oriUgcNid != null && message.hasOwnProperty("oriUgcNid"))
                object.oriUgcNid = message.oriUgcNid;
            if (message.oriUgcTid != null && message.hasOwnProperty("oriUgcTid"))
                object.oriUgcTid = message.oriUgcTid;
            if (message.oriUgcType != null && message.hasOwnProperty("oriUgcType"))
                object.oriUgcType = message.oriUgcType;
            if (message.oriUgcVid != null && message.hasOwnProperty("oriUgcVid"))
                object.oriUgcVid = message.oriUgcVid;
            if (message.forwardUrl != null && message.hasOwnProperty("forwardUrl"))
                object.forwardUrl = message.forwardUrl;
            return object;
        };

        /**
         * Converts this Baijiahao to JSON.
         * @function toJSON
         * @memberof tieba.Baijiahao
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Baijiahao.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Baijiahao
         * @function getTypeUrl
         * @memberof tieba.Baijiahao
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Baijiahao.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Baijiahao";
        };

        return Baijiahao;
    })();

    tieba.HeadItem = (function() {

        /**
         * Properties of a HeadItem.
         * @memberof tieba
         * @interface IHeadItem
         * @property {string|null} [name] HeadItem name
         * @property {string|null} [content] HeadItem content
         * @property {number|null} [type] HeadItem type
         */

        /**
         * Constructs a new HeadItem.
         * @memberof tieba
         * @classdesc Represents a HeadItem.
         * @implements IHeadItem
         * @constructor
         * @param {tieba.IHeadItem=} [properties] Properties to set
         */
        function HeadItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeadItem name.
         * @member {string} name
         * @memberof tieba.HeadItem
         * @instance
         */
        HeadItem.prototype.name = "";

        /**
         * HeadItem content.
         * @member {string} content
         * @memberof tieba.HeadItem
         * @instance
         */
        HeadItem.prototype.content = "";

        /**
         * HeadItem type.
         * @member {number} type
         * @memberof tieba.HeadItem
         * @instance
         */
        HeadItem.prototype.type = 0;

        /**
         * Creates a new HeadItem instance using the specified properties.
         * @function create
         * @memberof tieba.HeadItem
         * @static
         * @param {tieba.IHeadItem=} [properties] Properties to set
         * @returns {tieba.HeadItem} HeadItem instance
         */
        HeadItem.create = function create(properties) {
            return new HeadItem(properties);
        };

        /**
         * Encodes the specified HeadItem message. Does not implicitly {@link tieba.HeadItem.verify|verify} messages.
         * @function encode
         * @memberof tieba.HeadItem
         * @static
         * @param {tieba.IHeadItem} message HeadItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified HeadItem message, length delimited. Does not implicitly {@link tieba.HeadItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.HeadItem
         * @static
         * @param {tieba.IHeadItem} message HeadItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeadItem message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.HeadItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.HeadItem} HeadItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.HeadItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.content = reader.string();
                        break;
                    }
                case 3: {
                        message.type = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeadItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.HeadItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.HeadItem} HeadItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeadItem message.
         * @function verify
         * @memberof tieba.HeadItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeadItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        /**
         * Creates a HeadItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.HeadItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.HeadItem} HeadItem
         */
        HeadItem.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.HeadItem)
                return object;
            let message = new $root.tieba.HeadItem();
            if (object.name != null)
                message.name = String(object.name);
            if (object.content != null)
                message.content = String(object.content);
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeadItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.HeadItem
         * @static
         * @param {tieba.HeadItem} message HeadItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeadItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.content = "";
                object.type = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this HeadItem to JSON.
         * @function toJSON
         * @memberof tieba.HeadItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeadItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for HeadItem
         * @function getTypeUrl
         * @memberof tieba.HeadItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HeadItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.HeadItem";
        };

        return HeadItem;
    })();

    tieba.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof tieba
         * @interface IItem
         * @property {number|Long|null} [itemId] Item itemId
         * @property {string|null} [itemName] Item itemName
         * @property {number|null} [iconSize] Item iconSize
         * @property {string|null} [iconUrl] Item iconUrl
         * @property {Array.<string>|null} [tags] Item tags
         * @property {number|null} [score] Item score
         * @property {number|null} [star] Item star
         * @property {string|null} [buttonName] Item buttonName
         * @property {string|null} [buttonLink] Item buttonLink
         * @property {string|null} [itemAppid] Item itemAppid
         * @property {number|null} [categoryId] Item categoryId
         * @property {number|null} [buttonLinkType] Item buttonLinkType
         * @property {string|null} [apkName] Item apkName
         * @property {string|null} [forumName] Item forumName
         * @property {tieba.IApkDetail|null} [apkDetail] Item apkDetail
         */

        /**
         * Constructs a new Item.
         * @memberof tieba
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {tieba.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item itemId.
         * @member {number|Long} itemId
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.itemId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Item itemName.
         * @member {string} itemName
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.itemName = "";

        /**
         * Item iconSize.
         * @member {number} iconSize
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.iconSize = 0;

        /**
         * Item iconUrl.
         * @member {string} iconUrl
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.iconUrl = "";

        /**
         * Item tags.
         * @member {Array.<string>} tags
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.tags = $util.emptyArray;

        /**
         * Item score.
         * @member {number} score
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.score = 0;

        /**
         * Item star.
         * @member {number} star
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.star = 0;

        /**
         * Item buttonName.
         * @member {string} buttonName
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.buttonName = "";

        /**
         * Item buttonLink.
         * @member {string} buttonLink
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.buttonLink = "";

        /**
         * Item itemAppid.
         * @member {string} itemAppid
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.itemAppid = "";

        /**
         * Item categoryId.
         * @member {number} categoryId
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.categoryId = 0;

        /**
         * Item buttonLinkType.
         * @member {number} buttonLinkType
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.buttonLinkType = 0;

        /**
         * Item apkName.
         * @member {string} apkName
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.apkName = "";

        /**
         * Item forumName.
         * @member {string} forumName
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.forumName = "";

        /**
         * Item apkDetail.
         * @member {tieba.IApkDetail|null|undefined} apkDetail
         * @memberof tieba.Item
         * @instance
         */
        Item.prototype.apkDetail = null;

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof tieba.Item
         * @static
         * @param {tieba.IItem=} [properties] Properties to set
         * @returns {tieba.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link tieba.Item.verify|verify} messages.
         * @function encode
         * @memberof tieba.Item
         * @static
         * @param {tieba.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.itemId);
            if (message.itemName != null && Object.hasOwnProperty.call(message, "itemName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.itemName);
            if (message.iconSize != null && Object.hasOwnProperty.call(message, "iconSize"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.iconSize);
            if (message.iconUrl != null && Object.hasOwnProperty.call(message, "iconUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.iconUrl);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.score);
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.star);
            if (message.buttonName != null && Object.hasOwnProperty.call(message, "buttonName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.buttonName);
            if (message.buttonLink != null && Object.hasOwnProperty.call(message, "buttonLink"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.buttonLink);
            if (message.itemAppid != null && Object.hasOwnProperty.call(message, "itemAppid"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.itemAppid);
            if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.categoryId);
            if (message.buttonLinkType != null && Object.hasOwnProperty.call(message, "buttonLinkType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.buttonLinkType);
            if (message.apkName != null && Object.hasOwnProperty.call(message, "apkName"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.apkName);
            if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.forumName);
            if (message.apkDetail != null && Object.hasOwnProperty.call(message, "apkDetail"))
                $root.tieba.ApkDetail.encode(message.apkDetail, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link tieba.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Item
         * @static
         * @param {tieba.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Item();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemId = reader.int64();
                        break;
                    }
                case 2: {
                        message.itemName = reader.string();
                        break;
                    }
                case 3: {
                        message.iconSize = reader.double();
                        break;
                    }
                case 4: {
                        message.iconUrl = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 6: {
                        message.score = reader.double();
                        break;
                    }
                case 7: {
                        message.star = reader.int32();
                        break;
                    }
                case 8: {
                        message.buttonName = reader.string();
                        break;
                    }
                case 9: {
                        message.buttonLink = reader.string();
                        break;
                    }
                case 10: {
                        message.itemAppid = reader.string();
                        break;
                    }
                case 11: {
                        message.categoryId = reader.int32();
                        break;
                    }
                case 12: {
                        message.buttonLinkType = reader.int32();
                        break;
                    }
                case 13: {
                        message.apkName = reader.string();
                        break;
                    }
                case 14: {
                        message.forumName = reader.string();
                        break;
                    }
                case 15: {
                        message.apkDetail = $root.tieba.ApkDetail.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof tieba.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId) && !(message.itemId && $util.isInteger(message.itemId.low) && $util.isInteger(message.itemId.high)))
                    return "itemId: integer|Long expected";
            if (message.itemName != null && message.hasOwnProperty("itemName"))
                if (!$util.isString(message.itemName))
                    return "itemName: string expected";
            if (message.iconSize != null && message.hasOwnProperty("iconSize"))
                if (typeof message.iconSize !== "number")
                    return "iconSize: number expected";
            if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                if (!$util.isString(message.iconUrl))
                    return "iconUrl: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            if (message.buttonName != null && message.hasOwnProperty("buttonName"))
                if (!$util.isString(message.buttonName))
                    return "buttonName: string expected";
            if (message.buttonLink != null && message.hasOwnProperty("buttonLink"))
                if (!$util.isString(message.buttonLink))
                    return "buttonLink: string expected";
            if (message.itemAppid != null && message.hasOwnProperty("itemAppid"))
                if (!$util.isString(message.itemAppid))
                    return "itemAppid: string expected";
            if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                if (!$util.isInteger(message.categoryId))
                    return "categoryId: integer expected";
            if (message.buttonLinkType != null && message.hasOwnProperty("buttonLinkType"))
                if (!$util.isInteger(message.buttonLinkType))
                    return "buttonLinkType: integer expected";
            if (message.apkName != null && message.hasOwnProperty("apkName"))
                if (!$util.isString(message.apkName))
                    return "apkName: string expected";
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                if (!$util.isString(message.forumName))
                    return "forumName: string expected";
            if (message.apkDetail != null && message.hasOwnProperty("apkDetail")) {
                let error = $root.tieba.ApkDetail.verify(message.apkDetail);
                if (error)
                    return "apkDetail." + error;
            }
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Item)
                return object;
            let message = new $root.tieba.Item();
            if (object.itemId != null)
                if ($util.Long)
                    (message.itemId = $util.Long.fromValue(object.itemId)).unsigned = false;
                else if (typeof object.itemId === "string")
                    message.itemId = parseInt(object.itemId, 10);
                else if (typeof object.itemId === "number")
                    message.itemId = object.itemId;
                else if (typeof object.itemId === "object")
                    message.itemId = new $util.LongBits(object.itemId.low >>> 0, object.itemId.high >>> 0).toNumber();
            if (object.itemName != null)
                message.itemName = String(object.itemName);
            if (object.iconSize != null)
                message.iconSize = Number(object.iconSize);
            if (object.iconUrl != null)
                message.iconUrl = String(object.iconUrl);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".tieba.Item.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.score != null)
                message.score = Number(object.score);
            if (object.star != null)
                message.star = object.star | 0;
            if (object.buttonName != null)
                message.buttonName = String(object.buttonName);
            if (object.buttonLink != null)
                message.buttonLink = String(object.buttonLink);
            if (object.itemAppid != null)
                message.itemAppid = String(object.itemAppid);
            if (object.categoryId != null)
                message.categoryId = object.categoryId | 0;
            if (object.buttonLinkType != null)
                message.buttonLinkType = object.buttonLinkType | 0;
            if (object.apkName != null)
                message.apkName = String(object.apkName);
            if (object.forumName != null)
                message.forumName = String(object.forumName);
            if (object.apkDetail != null) {
                if (typeof object.apkDetail !== "object")
                    throw TypeError(".tieba.Item.apkDetail: object expected");
                message.apkDetail = $root.tieba.ApkDetail.fromObject(object.apkDetail);
            }
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Item
         * @static
         * @param {tieba.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tags = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.itemId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.itemId = options.longs === String ? "0" : 0;
                object.itemName = "";
                object.iconSize = 0;
                object.iconUrl = "";
                object.score = 0;
                object.star = 0;
                object.buttonName = "";
                object.buttonLink = "";
                object.itemAppid = "";
                object.categoryId = 0;
                object.buttonLinkType = 0;
                object.apkName = "";
                object.forumName = "";
                object.apkDetail = null;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (typeof message.itemId === "number")
                    object.itemId = options.longs === String ? String(message.itemId) : message.itemId;
                else
                    object.itemId = options.longs === String ? $util.Long.prototype.toString.call(message.itemId) : options.longs === Number ? new $util.LongBits(message.itemId.low >>> 0, message.itemId.high >>> 0).toNumber() : message.itemId;
            if (message.itemName != null && message.hasOwnProperty("itemName"))
                object.itemName = message.itemName;
            if (message.iconSize != null && message.hasOwnProperty("iconSize"))
                object.iconSize = options.json && !isFinite(message.iconSize) ? String(message.iconSize) : message.iconSize;
            if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                object.iconUrl = message.iconUrl;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.buttonName != null && message.hasOwnProperty("buttonName"))
                object.buttonName = message.buttonName;
            if (message.buttonLink != null && message.hasOwnProperty("buttonLink"))
                object.buttonLink = message.buttonLink;
            if (message.itemAppid != null && message.hasOwnProperty("itemAppid"))
                object.itemAppid = message.itemAppid;
            if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                object.categoryId = message.categoryId;
            if (message.buttonLinkType != null && message.hasOwnProperty("buttonLinkType"))
                object.buttonLinkType = message.buttonLinkType;
            if (message.apkName != null && message.hasOwnProperty("apkName"))
                object.apkName = message.apkName;
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                object.forumName = message.forumName;
            if (message.apkDetail != null && message.hasOwnProperty("apkDetail"))
                object.apkDetail = $root.tieba.ApkDetail.toObject(message.apkDetail, options);
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof tieba.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Item
         * @function getTypeUrl
         * @memberof tieba.Item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Item";
        };

        return Item;
    })();

    tieba.ApkDetail = (function() {

        /**
         * Properties of an ApkDetail.
         * @memberof tieba
         * @interface IApkDetail
         * @property {string|null} [developer] ApkDetail developer
         * @property {string|null} [publisher] ApkDetail publisher
         * @property {string|null} [version] ApkDetail version
         * @property {number|null} [versionCode] ApkDetail versionCode
         * @property {string|null} [updateTime] ApkDetail updateTime
         * @property {string|null} [size] ApkDetail size
         * @property {number|null} [needNetwork] ApkDetail needNetwork
         * @property {number|null} [needInnerBuy] ApkDetail needInnerBuy
         * @property {string|null} [authorityUrl] ApkDetail authorityUrl
         * @property {string|null} [privacyUrl] ApkDetail privacyUrl
         * @property {number|null} [pkgSource] ApkDetail pkgSource
         */

        /**
         * Constructs a new ApkDetail.
         * @memberof tieba
         * @classdesc Represents an ApkDetail.
         * @implements IApkDetail
         * @constructor
         * @param {tieba.IApkDetail=} [properties] Properties to set
         */
        function ApkDetail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApkDetail developer.
         * @member {string} developer
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.developer = "";

        /**
         * ApkDetail publisher.
         * @member {string} publisher
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.publisher = "";

        /**
         * ApkDetail version.
         * @member {string} version
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.version = "";

        /**
         * ApkDetail versionCode.
         * @member {number} versionCode
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.versionCode = 0;

        /**
         * ApkDetail updateTime.
         * @member {string} updateTime
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.updateTime = "";

        /**
         * ApkDetail size.
         * @member {string} size
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.size = "";

        /**
         * ApkDetail needNetwork.
         * @member {number} needNetwork
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.needNetwork = 0;

        /**
         * ApkDetail needInnerBuy.
         * @member {number} needInnerBuy
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.needInnerBuy = 0;

        /**
         * ApkDetail authorityUrl.
         * @member {string} authorityUrl
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.authorityUrl = "";

        /**
         * ApkDetail privacyUrl.
         * @member {string} privacyUrl
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.privacyUrl = "";

        /**
         * ApkDetail pkgSource.
         * @member {number} pkgSource
         * @memberof tieba.ApkDetail
         * @instance
         */
        ApkDetail.prototype.pkgSource = 0;

        /**
         * Creates a new ApkDetail instance using the specified properties.
         * @function create
         * @memberof tieba.ApkDetail
         * @static
         * @param {tieba.IApkDetail=} [properties] Properties to set
         * @returns {tieba.ApkDetail} ApkDetail instance
         */
        ApkDetail.create = function create(properties) {
            return new ApkDetail(properties);
        };

        /**
         * Encodes the specified ApkDetail message. Does not implicitly {@link tieba.ApkDetail.verify|verify} messages.
         * @function encode
         * @memberof tieba.ApkDetail
         * @static
         * @param {tieba.IApkDetail} message ApkDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApkDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.developer != null && Object.hasOwnProperty.call(message, "developer"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.developer);
            if (message.publisher != null && Object.hasOwnProperty.call(message, "publisher"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.publisher);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
            if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.versionCode);
            if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.updateTime);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.size);
            if (message.needNetwork != null && Object.hasOwnProperty.call(message, "needNetwork"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.needNetwork);
            if (message.needInnerBuy != null && Object.hasOwnProperty.call(message, "needInnerBuy"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.needInnerBuy);
            if (message.authorityUrl != null && Object.hasOwnProperty.call(message, "authorityUrl"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.authorityUrl);
            if (message.privacyUrl != null && Object.hasOwnProperty.call(message, "privacyUrl"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.privacyUrl);
            if (message.pkgSource != null && Object.hasOwnProperty.call(message, "pkgSource"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.pkgSource);
            return writer;
        };

        /**
         * Encodes the specified ApkDetail message, length delimited. Does not implicitly {@link tieba.ApkDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.ApkDetail
         * @static
         * @param {tieba.IApkDetail} message ApkDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApkDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApkDetail message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.ApkDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.ApkDetail} ApkDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApkDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.ApkDetail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.developer = reader.string();
                        break;
                    }
                case 2: {
                        message.publisher = reader.string();
                        break;
                    }
                case 3: {
                        message.version = reader.string();
                        break;
                    }
                case 6: {
                        message.versionCode = reader.int32();
                        break;
                    }
                case 7: {
                        message.updateTime = reader.string();
                        break;
                    }
                case 8: {
                        message.size = reader.string();
                        break;
                    }
                case 9: {
                        message.needNetwork = reader.int32();
                        break;
                    }
                case 10: {
                        message.needInnerBuy = reader.int32();
                        break;
                    }
                case 11: {
                        message.authorityUrl = reader.string();
                        break;
                    }
                case 12: {
                        message.privacyUrl = reader.string();
                        break;
                    }
                case 13: {
                        message.pkgSource = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApkDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.ApkDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.ApkDetail} ApkDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApkDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApkDetail message.
         * @function verify
         * @memberof tieba.ApkDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApkDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.developer != null && message.hasOwnProperty("developer"))
                if (!$util.isString(message.developer))
                    return "developer: string expected";
            if (message.publisher != null && message.hasOwnProperty("publisher"))
                if (!$util.isString(message.publisher))
                    return "publisher: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.versionCode != null && message.hasOwnProperty("versionCode"))
                if (!$util.isInteger(message.versionCode))
                    return "versionCode: integer expected";
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                if (!$util.isString(message.updateTime))
                    return "updateTime: string expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isString(message.size))
                    return "size: string expected";
            if (message.needNetwork != null && message.hasOwnProperty("needNetwork"))
                if (!$util.isInteger(message.needNetwork))
                    return "needNetwork: integer expected";
            if (message.needInnerBuy != null && message.hasOwnProperty("needInnerBuy"))
                if (!$util.isInteger(message.needInnerBuy))
                    return "needInnerBuy: integer expected";
            if (message.authorityUrl != null && message.hasOwnProperty("authorityUrl"))
                if (!$util.isString(message.authorityUrl))
                    return "authorityUrl: string expected";
            if (message.privacyUrl != null && message.hasOwnProperty("privacyUrl"))
                if (!$util.isString(message.privacyUrl))
                    return "privacyUrl: string expected";
            if (message.pkgSource != null && message.hasOwnProperty("pkgSource"))
                if (!$util.isInteger(message.pkgSource))
                    return "pkgSource: integer expected";
            return null;
        };

        /**
         * Creates an ApkDetail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.ApkDetail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.ApkDetail} ApkDetail
         */
        ApkDetail.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.ApkDetail)
                return object;
            let message = new $root.tieba.ApkDetail();
            if (object.developer != null)
                message.developer = String(object.developer);
            if (object.publisher != null)
                message.publisher = String(object.publisher);
            if (object.version != null)
                message.version = String(object.version);
            if (object.versionCode != null)
                message.versionCode = object.versionCode | 0;
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.size != null)
                message.size = String(object.size);
            if (object.needNetwork != null)
                message.needNetwork = object.needNetwork | 0;
            if (object.needInnerBuy != null)
                message.needInnerBuy = object.needInnerBuy | 0;
            if (object.authorityUrl != null)
                message.authorityUrl = String(object.authorityUrl);
            if (object.privacyUrl != null)
                message.privacyUrl = String(object.privacyUrl);
            if (object.pkgSource != null)
                message.pkgSource = object.pkgSource | 0;
            return message;
        };

        /**
         * Creates a plain object from an ApkDetail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.ApkDetail
         * @static
         * @param {tieba.ApkDetail} message ApkDetail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApkDetail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.developer = "";
                object.publisher = "";
                object.version = "";
                object.versionCode = 0;
                object.updateTime = "";
                object.size = "";
                object.needNetwork = 0;
                object.needInnerBuy = 0;
                object.authorityUrl = "";
                object.privacyUrl = "";
                object.pkgSource = 0;
            }
            if (message.developer != null && message.hasOwnProperty("developer"))
                object.developer = message.developer;
            if (message.publisher != null && message.hasOwnProperty("publisher"))
                object.publisher = message.publisher;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.versionCode != null && message.hasOwnProperty("versionCode"))
                object.versionCode = message.versionCode;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.needNetwork != null && message.hasOwnProperty("needNetwork"))
                object.needNetwork = message.needNetwork;
            if (message.needInnerBuy != null && message.hasOwnProperty("needInnerBuy"))
                object.needInnerBuy = message.needInnerBuy;
            if (message.authorityUrl != null && message.hasOwnProperty("authorityUrl"))
                object.authorityUrl = message.authorityUrl;
            if (message.privacyUrl != null && message.hasOwnProperty("privacyUrl"))
                object.privacyUrl = message.privacyUrl;
            if (message.pkgSource != null && message.hasOwnProperty("pkgSource"))
                object.pkgSource = message.pkgSource;
            return object;
        };

        /**
         * Converts this ApkDetail to JSON.
         * @function toJSON
         * @memberof tieba.ApkDetail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApkDetail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ApkDetail
         * @function getTypeUrl
         * @memberof tieba.ApkDetail
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ApkDetail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.ApkDetail";
        };

        return ApkDetail;
    })();

    tieba.PbLinkInfo = (function() {

        /**
         * Properties of a PbLinkInfo.
         * @memberof tieba
         * @interface IPbLinkInfo
         * @property {string|null} [title] PbLinkInfo title
         * @property {string|null} [toUrl] PbLinkInfo toUrl
         * @property {string|null} [picUrl] PbLinkInfo picUrl
         * @property {string|null} [linkFrom] PbLinkInfo linkFrom
         * @property {string|null} [extTxt] PbLinkInfo extTxt
         * @property {number|null} [sort] PbLinkInfo sort
         * @property {number|null} [urlType] PbLinkInfo urlType
         */

        /**
         * Constructs a new PbLinkInfo.
         * @memberof tieba
         * @classdesc Represents a PbLinkInfo.
         * @implements IPbLinkInfo
         * @constructor
         * @param {tieba.IPbLinkInfo=} [properties] Properties to set
         */
        function PbLinkInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbLinkInfo title.
         * @member {string} title
         * @memberof tieba.PbLinkInfo
         * @instance
         */
        PbLinkInfo.prototype.title = "";

        /**
         * PbLinkInfo toUrl.
         * @member {string} toUrl
         * @memberof tieba.PbLinkInfo
         * @instance
         */
        PbLinkInfo.prototype.toUrl = "";

        /**
         * PbLinkInfo picUrl.
         * @member {string} picUrl
         * @memberof tieba.PbLinkInfo
         * @instance
         */
        PbLinkInfo.prototype.picUrl = "";

        /**
         * PbLinkInfo linkFrom.
         * @member {string} linkFrom
         * @memberof tieba.PbLinkInfo
         * @instance
         */
        PbLinkInfo.prototype.linkFrom = "";

        /**
         * PbLinkInfo extTxt.
         * @member {string} extTxt
         * @memberof tieba.PbLinkInfo
         * @instance
         */
        PbLinkInfo.prototype.extTxt = "";

        /**
         * PbLinkInfo sort.
         * @member {number} sort
         * @memberof tieba.PbLinkInfo
         * @instance
         */
        PbLinkInfo.prototype.sort = 0;

        /**
         * PbLinkInfo urlType.
         * @member {number} urlType
         * @memberof tieba.PbLinkInfo
         * @instance
         */
        PbLinkInfo.prototype.urlType = 0;

        /**
         * Creates a new PbLinkInfo instance using the specified properties.
         * @function create
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {tieba.IPbLinkInfo=} [properties] Properties to set
         * @returns {tieba.PbLinkInfo} PbLinkInfo instance
         */
        PbLinkInfo.create = function create(properties) {
            return new PbLinkInfo(properties);
        };

        /**
         * Encodes the specified PbLinkInfo message. Does not implicitly {@link tieba.PbLinkInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {tieba.IPbLinkInfo} message PbLinkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbLinkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.toUrl != null && Object.hasOwnProperty.call(message, "toUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.toUrl);
            if (message.picUrl != null && Object.hasOwnProperty.call(message, "picUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.picUrl);
            if (message.linkFrom != null && Object.hasOwnProperty.call(message, "linkFrom"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.linkFrom);
            if (message.extTxt != null && Object.hasOwnProperty.call(message, "extTxt"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.extTxt);
            if (message.sort != null && Object.hasOwnProperty.call(message, "sort"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.sort);
            if (message.urlType != null && Object.hasOwnProperty.call(message, "urlType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.urlType);
            return writer;
        };

        /**
         * Encodes the specified PbLinkInfo message, length delimited. Does not implicitly {@link tieba.PbLinkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {tieba.IPbLinkInfo} message PbLinkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbLinkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbLinkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.PbLinkInfo} PbLinkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbLinkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.PbLinkInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.title = reader.string();
                        break;
                    }
                case 2: {
                        message.toUrl = reader.string();
                        break;
                    }
                case 3: {
                        message.picUrl = reader.string();
                        break;
                    }
                case 4: {
                        message.linkFrom = reader.string();
                        break;
                    }
                case 5: {
                        message.extTxt = reader.string();
                        break;
                    }
                case 6: {
                        message.sort = reader.uint32();
                        break;
                    }
                case 7: {
                        message.urlType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbLinkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.PbLinkInfo} PbLinkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbLinkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbLinkInfo message.
         * @function verify
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbLinkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.toUrl != null && message.hasOwnProperty("toUrl"))
                if (!$util.isString(message.toUrl))
                    return "toUrl: string expected";
            if (message.picUrl != null && message.hasOwnProperty("picUrl"))
                if (!$util.isString(message.picUrl))
                    return "picUrl: string expected";
            if (message.linkFrom != null && message.hasOwnProperty("linkFrom"))
                if (!$util.isString(message.linkFrom))
                    return "linkFrom: string expected";
            if (message.extTxt != null && message.hasOwnProperty("extTxt"))
                if (!$util.isString(message.extTxt))
                    return "extTxt: string expected";
            if (message.sort != null && message.hasOwnProperty("sort"))
                if (!$util.isInteger(message.sort))
                    return "sort: integer expected";
            if (message.urlType != null && message.hasOwnProperty("urlType"))
                if (!$util.isInteger(message.urlType))
                    return "urlType: integer expected";
            return null;
        };

        /**
         * Creates a PbLinkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.PbLinkInfo} PbLinkInfo
         */
        PbLinkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.PbLinkInfo)
                return object;
            let message = new $root.tieba.PbLinkInfo();
            if (object.title != null)
                message.title = String(object.title);
            if (object.toUrl != null)
                message.toUrl = String(object.toUrl);
            if (object.picUrl != null)
                message.picUrl = String(object.picUrl);
            if (object.linkFrom != null)
                message.linkFrom = String(object.linkFrom);
            if (object.extTxt != null)
                message.extTxt = String(object.extTxt);
            if (object.sort != null)
                message.sort = object.sort >>> 0;
            if (object.urlType != null)
                message.urlType = object.urlType | 0;
            return message;
        };

        /**
         * Creates a plain object from a PbLinkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {tieba.PbLinkInfo} message PbLinkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbLinkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.title = "";
                object.toUrl = "";
                object.picUrl = "";
                object.linkFrom = "";
                object.extTxt = "";
                object.sort = 0;
                object.urlType = 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.toUrl != null && message.hasOwnProperty("toUrl"))
                object.toUrl = message.toUrl;
            if (message.picUrl != null && message.hasOwnProperty("picUrl"))
                object.picUrl = message.picUrl;
            if (message.linkFrom != null && message.hasOwnProperty("linkFrom"))
                object.linkFrom = message.linkFrom;
            if (message.extTxt != null && message.hasOwnProperty("extTxt"))
                object.extTxt = message.extTxt;
            if (message.sort != null && message.hasOwnProperty("sort"))
                object.sort = message.sort;
            if (message.urlType != null && message.hasOwnProperty("urlType"))
                object.urlType = message.urlType;
            return object;
        };

        /**
         * Converts this PbLinkInfo to JSON.
         * @function toJSON
         * @memberof tieba.PbLinkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbLinkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PbLinkInfo
         * @function getTypeUrl
         * @memberof tieba.PbLinkInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PbLinkInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.PbLinkInfo";
        };

        return PbLinkInfo;
    })();

    tieba.Voice = (function() {

        /**
         * Properties of a Voice.
         * @memberof tieba
         * @interface IVoice
         * @property {number|null} [type] Voice type
         * @property {number|null} [duringTime] Voice duringTime
         * @property {string|null} [voiceMd5] Voice voiceMd5
         */

        /**
         * Constructs a new Voice.
         * @memberof tieba
         * @classdesc Represents a Voice.
         * @implements IVoice
         * @constructor
         * @param {tieba.IVoice=} [properties] Properties to set
         */
        function Voice(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Voice type.
         * @member {number} type
         * @memberof tieba.Voice
         * @instance
         */
        Voice.prototype.type = 0;

        /**
         * Voice duringTime.
         * @member {number} duringTime
         * @memberof tieba.Voice
         * @instance
         */
        Voice.prototype.duringTime = 0;

        /**
         * Voice voiceMd5.
         * @member {string} voiceMd5
         * @memberof tieba.Voice
         * @instance
         */
        Voice.prototype.voiceMd5 = "";

        /**
         * Creates a new Voice instance using the specified properties.
         * @function create
         * @memberof tieba.Voice
         * @static
         * @param {tieba.IVoice=} [properties] Properties to set
         * @returns {tieba.Voice} Voice instance
         */
        Voice.create = function create(properties) {
            return new Voice(properties);
        };

        /**
         * Encodes the specified Voice message. Does not implicitly {@link tieba.Voice.verify|verify} messages.
         * @function encode
         * @memberof tieba.Voice
         * @static
         * @param {tieba.IVoice} message Voice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Voice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.duringTime != null && Object.hasOwnProperty.call(message, "duringTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.duringTime);
            if (message.voiceMd5 != null && Object.hasOwnProperty.call(message, "voiceMd5"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.voiceMd5);
            return writer;
        };

        /**
         * Encodes the specified Voice message, length delimited. Does not implicitly {@link tieba.Voice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Voice
         * @static
         * @param {tieba.IVoice} message Voice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Voice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Voice message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Voice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Voice} Voice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Voice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Voice();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.duringTime = reader.int32();
                        break;
                    }
                case 3: {
                        message.voiceMd5 = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Voice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Voice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Voice} Voice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Voice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Voice message.
         * @function verify
         * @memberof tieba.Voice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Voice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.duringTime != null && message.hasOwnProperty("duringTime"))
                if (!$util.isInteger(message.duringTime))
                    return "duringTime: integer expected";
            if (message.voiceMd5 != null && message.hasOwnProperty("voiceMd5"))
                if (!$util.isString(message.voiceMd5))
                    return "voiceMd5: string expected";
            return null;
        };

        /**
         * Creates a Voice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Voice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Voice} Voice
         */
        Voice.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Voice)
                return object;
            let message = new $root.tieba.Voice();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.duringTime != null)
                message.duringTime = object.duringTime | 0;
            if (object.voiceMd5 != null)
                message.voiceMd5 = String(object.voiceMd5);
            return message;
        };

        /**
         * Creates a plain object from a Voice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Voice
         * @static
         * @param {tieba.Voice} message Voice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Voice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = 0;
                object.duringTime = 0;
                object.voiceMd5 = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.duringTime != null && message.hasOwnProperty("duringTime"))
                object.duringTime = message.duringTime;
            if (message.voiceMd5 != null && message.hasOwnProperty("voiceMd5"))
                object.voiceMd5 = message.voiceMd5;
            return object;
        };

        /**
         * Converts this Voice to JSON.
         * @function toJSON
         * @memberof tieba.Voice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Voice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Voice
         * @function getTypeUrl
         * @memberof tieba.Voice
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Voice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Voice";
        };

        return Voice;
    })();

    tieba.Quote = (function() {

        /**
         * Properties of a Quote.
         * @memberof tieba
         * @interface IQuote
         * @property {number|Long|null} [postId] Quote postId
         * @property {string|null} [userName] Quote userName
         * @property {number|Long|null} [userId] Quote userId
         * @property {string|null} [ip] Quote ip
         * @property {string|null} [content] Quote content
         */

        /**
         * Constructs a new Quote.
         * @memberof tieba
         * @classdesc Represents a Quote.
         * @implements IQuote
         * @constructor
         * @param {tieba.IQuote=} [properties] Properties to set
         */
        function Quote(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Quote postId.
         * @member {number|Long} postId
         * @memberof tieba.Quote
         * @instance
         */
        Quote.prototype.postId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Quote userName.
         * @member {string} userName
         * @memberof tieba.Quote
         * @instance
         */
        Quote.prototype.userName = "";

        /**
         * Quote userId.
         * @member {number|Long} userId
         * @memberof tieba.Quote
         * @instance
         */
        Quote.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Quote ip.
         * @member {string} ip
         * @memberof tieba.Quote
         * @instance
         */
        Quote.prototype.ip = "";

        /**
         * Quote content.
         * @member {string} content
         * @memberof tieba.Quote
         * @instance
         */
        Quote.prototype.content = "";

        /**
         * Creates a new Quote instance using the specified properties.
         * @function create
         * @memberof tieba.Quote
         * @static
         * @param {tieba.IQuote=} [properties] Properties to set
         * @returns {tieba.Quote} Quote instance
         */
        Quote.create = function create(properties) {
            return new Quote(properties);
        };

        /**
         * Encodes the specified Quote message. Does not implicitly {@link tieba.Quote.verify|verify} messages.
         * @function encode
         * @memberof tieba.Quote
         * @static
         * @param {tieba.IQuote} message Quote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Quote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.postId);
            if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.userName);
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.userId);
            if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ip);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified Quote message, length delimited. Does not implicitly {@link tieba.Quote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.Quote
         * @static
         * @param {tieba.IQuote} message Quote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Quote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Quote message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.Quote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.Quote} Quote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Quote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.Quote();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.postId = reader.int64();
                        break;
                    }
                case 2: {
                        message.userName = reader.string();
                        break;
                    }
                case 3: {
                        message.userId = reader.int64();
                        break;
                    }
                case 4: {
                        message.ip = reader.string();
                        break;
                    }
                case 5: {
                        message.content = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Quote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.Quote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.Quote} Quote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Quote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Quote message.
         * @function verify
         * @memberof tieba.Quote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Quote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isInteger(message.postId) && !(message.postId && $util.isInteger(message.postId.low) && $util.isInteger(message.postId.high)))
                    return "postId: integer|Long expected";
            if (message.userName != null && message.hasOwnProperty("userName"))
                if (!$util.isString(message.userName))
                    return "userName: string expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a Quote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.Quote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.Quote} Quote
         */
        Quote.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.Quote)
                return object;
            let message = new $root.tieba.Quote();
            if (object.postId != null)
                if ($util.Long)
                    (message.postId = $util.Long.fromValue(object.postId)).unsigned = false;
                else if (typeof object.postId === "string")
                    message.postId = parseInt(object.postId, 10);
                else if (typeof object.postId === "number")
                    message.postId = object.postId;
                else if (typeof object.postId === "object")
                    message.postId = new $util.LongBits(object.postId.low >>> 0, object.postId.high >>> 0).toNumber();
            if (object.userName != null)
                message.userName = String(object.userName);
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
            if (object.ip != null)
                message.ip = String(object.ip);
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a Quote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.Quote
         * @static
         * @param {tieba.Quote} message Quote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Quote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.postId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.postId = options.longs === String ? "0" : 0;
                object.userName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
                object.ip = "";
                object.content = "";
            }
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (typeof message.postId === "number")
                    object.postId = options.longs === String ? String(message.postId) : message.postId;
                else
                    object.postId = options.longs === String ? $util.Long.prototype.toString.call(message.postId) : options.longs === Number ? new $util.LongBits(message.postId.low >>> 0, message.postId.high >>> 0).toNumber() : message.postId;
            if (message.userName != null && message.hasOwnProperty("userName"))
                object.userName = message.userName;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this Quote to JSON.
         * @function toJSON
         * @memberof tieba.Quote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Quote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Quote
         * @function getTypeUrl
         * @memberof tieba.Quote
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Quote.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.Quote";
        };

        return Quote;
    })();

    tieba.DealInfo = (function() {

        /**
         * Properties of a DealInfo.
         * @memberof tieba
         * @interface IDealInfo
         * @property {string|null} [title] DealInfo title
         * @property {string|null} [des] DealInfo des
         * @property {number|Long|null} [stock] DealInfo stock
         * @property {number|Long|null} [sales] DealInfo sales
         * @property {number|null} [expireTime] DealInfo expireTime
         * @property {number|Long|null} [unitPrice] DealInfo unitPrice
         * @property {number|Long|null} [productId] DealInfo productId
         * @property {string|null} [sellerAddress] DealInfo sellerAddress
         * @property {number|Long|null} [recommendations] DealInfo recommendations
         * @property {boolean|null} [hasRecommend] DealInfo hasRecommend
         * @property {number|null} [status] DealInfo status
         * @property {Array.<tieba.IDealMedia>|null} [media] DealInfo media
         * @property {Array.<tieba.IDealAuthInfo>|null} [authInfo] DealInfo authInfo
         * @property {number|Long|null} [shipFee] DealInfo shipFee
         */

        /**
         * Constructs a new DealInfo.
         * @memberof tieba
         * @classdesc Represents a DealInfo.
         * @implements IDealInfo
         * @constructor
         * @param {tieba.IDealInfo=} [properties] Properties to set
         */
        function DealInfo(properties) {
            this.media = [];
            this.authInfo = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DealInfo title.
         * @member {string} title
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.title = "";

        /**
         * DealInfo des.
         * @member {string} des
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.des = "";

        /**
         * DealInfo stock.
         * @member {number|Long} stock
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.stock = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DealInfo sales.
         * @member {number|Long} sales
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.sales = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DealInfo expireTime.
         * @member {number} expireTime
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.expireTime = 0;

        /**
         * DealInfo unitPrice.
         * @member {number|Long} unitPrice
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.unitPrice = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DealInfo productId.
         * @member {number|Long} productId
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.productId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DealInfo sellerAddress.
         * @member {string} sellerAddress
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.sellerAddress = "";

        /**
         * DealInfo recommendations.
         * @member {number|Long} recommendations
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.recommendations = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DealInfo hasRecommend.
         * @member {boolean} hasRecommend
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.hasRecommend = false;

        /**
         * DealInfo status.
         * @member {number} status
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.status = 0;

        /**
         * DealInfo media.
         * @member {Array.<tieba.IDealMedia>} media
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.media = $util.emptyArray;

        /**
         * DealInfo authInfo.
         * @member {Array.<tieba.IDealAuthInfo>} authInfo
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.authInfo = $util.emptyArray;

        /**
         * DealInfo shipFee.
         * @member {number|Long} shipFee
         * @memberof tieba.DealInfo
         * @instance
         */
        DealInfo.prototype.shipFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DealInfo instance using the specified properties.
         * @function create
         * @memberof tieba.DealInfo
         * @static
         * @param {tieba.IDealInfo=} [properties] Properties to set
         * @returns {tieba.DealInfo} DealInfo instance
         */
        DealInfo.create = function create(properties) {
            return new DealInfo(properties);
        };

        /**
         * Encodes the specified DealInfo message. Does not implicitly {@link tieba.DealInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.DealInfo
         * @static
         * @param {tieba.IDealInfo} message DealInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DealInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.des != null && Object.hasOwnProperty.call(message, "des"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.des);
            if (message.stock != null && Object.hasOwnProperty.call(message, "stock"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.stock);
            if (message.sales != null && Object.hasOwnProperty.call(message, "sales"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.sales);
            if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.expireTime);
            if (message.unitPrice != null && Object.hasOwnProperty.call(message, "unitPrice"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.unitPrice);
            if (message.productId != null && Object.hasOwnProperty.call(message, "productId"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.productId);
            if (message.sellerAddress != null && Object.hasOwnProperty.call(message, "sellerAddress"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.sellerAddress);
            if (message.recommendations != null && Object.hasOwnProperty.call(message, "recommendations"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.recommendations);
            if (message.hasRecommend != null && Object.hasOwnProperty.call(message, "hasRecommend"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasRecommend);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.status);
            if (message.media != null && message.media.length)
                for (let i = 0; i < message.media.length; ++i)
                    $root.tieba.DealMedia.encode(message.media[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.authInfo != null && message.authInfo.length)
                for (let i = 0; i < message.authInfo.length; ++i)
                    $root.tieba.DealAuthInfo.encode(message.authInfo[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.shipFee != null && Object.hasOwnProperty.call(message, "shipFee"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.shipFee);
            return writer;
        };

        /**
         * Encodes the specified DealInfo message, length delimited. Does not implicitly {@link tieba.DealInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.DealInfo
         * @static
         * @param {tieba.IDealInfo} message DealInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DealInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DealInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.DealInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.DealInfo} DealInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.DealInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.title = reader.string();
                        break;
                    }
                case 2: {
                        message.des = reader.string();
                        break;
                    }
                case 3: {
                        message.stock = reader.uint64();
                        break;
                    }
                case 4: {
                        message.sales = reader.uint64();
                        break;
                    }
                case 5: {
                        message.expireTime = reader.uint32();
                        break;
                    }
                case 6: {
                        message.unitPrice = reader.uint64();
                        break;
                    }
                case 7: {
                        message.productId = reader.uint64();
                        break;
                    }
                case 8: {
                        message.sellerAddress = reader.string();
                        break;
                    }
                case 9: {
                        message.recommendations = reader.int64();
                        break;
                    }
                case 10: {
                        message.hasRecommend = reader.bool();
                        break;
                    }
                case 11: {
                        message.status = reader.int32();
                        break;
                    }
                case 12: {
                        if (!(message.media && message.media.length))
                            message.media = [];
                        message.media.push($root.tieba.DealMedia.decode(reader, reader.uint32()));
                        break;
                    }
                case 13: {
                        if (!(message.authInfo && message.authInfo.length))
                            message.authInfo = [];
                        message.authInfo.push($root.tieba.DealAuthInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 14: {
                        message.shipFee = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DealInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.DealInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.DealInfo} DealInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DealInfo message.
         * @function verify
         * @memberof tieba.DealInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DealInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.des != null && message.hasOwnProperty("des"))
                if (!$util.isString(message.des))
                    return "des: string expected";
            if (message.stock != null && message.hasOwnProperty("stock"))
                if (!$util.isInteger(message.stock) && !(message.stock && $util.isInteger(message.stock.low) && $util.isInteger(message.stock.high)))
                    return "stock: integer|Long expected";
            if (message.sales != null && message.hasOwnProperty("sales"))
                if (!$util.isInteger(message.sales) && !(message.sales && $util.isInteger(message.sales.low) && $util.isInteger(message.sales.high)))
                    return "sales: integer|Long expected";
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                if (!$util.isInteger(message.expireTime))
                    return "expireTime: integer expected";
            if (message.unitPrice != null && message.hasOwnProperty("unitPrice"))
                if (!$util.isInteger(message.unitPrice) && !(message.unitPrice && $util.isInteger(message.unitPrice.low) && $util.isInteger(message.unitPrice.high)))
                    return "unitPrice: integer|Long expected";
            if (message.productId != null && message.hasOwnProperty("productId"))
                if (!$util.isInteger(message.productId) && !(message.productId && $util.isInteger(message.productId.low) && $util.isInteger(message.productId.high)))
                    return "productId: integer|Long expected";
            if (message.sellerAddress != null && message.hasOwnProperty("sellerAddress"))
                if (!$util.isString(message.sellerAddress))
                    return "sellerAddress: string expected";
            if (message.recommendations != null && message.hasOwnProperty("recommendations"))
                if (!$util.isInteger(message.recommendations) && !(message.recommendations && $util.isInteger(message.recommendations.low) && $util.isInteger(message.recommendations.high)))
                    return "recommendations: integer|Long expected";
            if (message.hasRecommend != null && message.hasOwnProperty("hasRecommend"))
                if (typeof message.hasRecommend !== "boolean")
                    return "hasRecommend: boolean expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.media != null && message.hasOwnProperty("media")) {
                if (!Array.isArray(message.media))
                    return "media: array expected";
                for (let i = 0; i < message.media.length; ++i) {
                    let error = $root.tieba.DealMedia.verify(message.media[i]);
                    if (error)
                        return "media." + error;
                }
            }
            if (message.authInfo != null && message.hasOwnProperty("authInfo")) {
                if (!Array.isArray(message.authInfo))
                    return "authInfo: array expected";
                for (let i = 0; i < message.authInfo.length; ++i) {
                    let error = $root.tieba.DealAuthInfo.verify(message.authInfo[i]);
                    if (error)
                        return "authInfo." + error;
                }
            }
            if (message.shipFee != null && message.hasOwnProperty("shipFee"))
                if (!$util.isInteger(message.shipFee) && !(message.shipFee && $util.isInteger(message.shipFee.low) && $util.isInteger(message.shipFee.high)))
                    return "shipFee: integer|Long expected";
            return null;
        };

        /**
         * Creates a DealInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.DealInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.DealInfo} DealInfo
         */
        DealInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.DealInfo)
                return object;
            let message = new $root.tieba.DealInfo();
            if (object.title != null)
                message.title = String(object.title);
            if (object.des != null)
                message.des = String(object.des);
            if (object.stock != null)
                if ($util.Long)
                    (message.stock = $util.Long.fromValue(object.stock)).unsigned = true;
                else if (typeof object.stock === "string")
                    message.stock = parseInt(object.stock, 10);
                else if (typeof object.stock === "number")
                    message.stock = object.stock;
                else if (typeof object.stock === "object")
                    message.stock = new $util.LongBits(object.stock.low >>> 0, object.stock.high >>> 0).toNumber(true);
            if (object.sales != null)
                if ($util.Long)
                    (message.sales = $util.Long.fromValue(object.sales)).unsigned = true;
                else if (typeof object.sales === "string")
                    message.sales = parseInt(object.sales, 10);
                else if (typeof object.sales === "number")
                    message.sales = object.sales;
                else if (typeof object.sales === "object")
                    message.sales = new $util.LongBits(object.sales.low >>> 0, object.sales.high >>> 0).toNumber(true);
            if (object.expireTime != null)
                message.expireTime = object.expireTime >>> 0;
            if (object.unitPrice != null)
                if ($util.Long)
                    (message.unitPrice = $util.Long.fromValue(object.unitPrice)).unsigned = true;
                else if (typeof object.unitPrice === "string")
                    message.unitPrice = parseInt(object.unitPrice, 10);
                else if (typeof object.unitPrice === "number")
                    message.unitPrice = object.unitPrice;
                else if (typeof object.unitPrice === "object")
                    message.unitPrice = new $util.LongBits(object.unitPrice.low >>> 0, object.unitPrice.high >>> 0).toNumber(true);
            if (object.productId != null)
                if ($util.Long)
                    (message.productId = $util.Long.fromValue(object.productId)).unsigned = true;
                else if (typeof object.productId === "string")
                    message.productId = parseInt(object.productId, 10);
                else if (typeof object.productId === "number")
                    message.productId = object.productId;
                else if (typeof object.productId === "object")
                    message.productId = new $util.LongBits(object.productId.low >>> 0, object.productId.high >>> 0).toNumber(true);
            if (object.sellerAddress != null)
                message.sellerAddress = String(object.sellerAddress);
            if (object.recommendations != null)
                if ($util.Long)
                    (message.recommendations = $util.Long.fromValue(object.recommendations)).unsigned = false;
                else if (typeof object.recommendations === "string")
                    message.recommendations = parseInt(object.recommendations, 10);
                else if (typeof object.recommendations === "number")
                    message.recommendations = object.recommendations;
                else if (typeof object.recommendations === "object")
                    message.recommendations = new $util.LongBits(object.recommendations.low >>> 0, object.recommendations.high >>> 0).toNumber();
            if (object.hasRecommend != null)
                message.hasRecommend = Boolean(object.hasRecommend);
            if (object.status != null)
                message.status = object.status | 0;
            if (object.media) {
                if (!Array.isArray(object.media))
                    throw TypeError(".tieba.DealInfo.media: array expected");
                message.media = [];
                for (let i = 0; i < object.media.length; ++i) {
                    if (typeof object.media[i] !== "object")
                        throw TypeError(".tieba.DealInfo.media: object expected");
                    message.media[i] = $root.tieba.DealMedia.fromObject(object.media[i]);
                }
            }
            if (object.authInfo) {
                if (!Array.isArray(object.authInfo))
                    throw TypeError(".tieba.DealInfo.authInfo: array expected");
                message.authInfo = [];
                for (let i = 0; i < object.authInfo.length; ++i) {
                    if (typeof object.authInfo[i] !== "object")
                        throw TypeError(".tieba.DealInfo.authInfo: object expected");
                    message.authInfo[i] = $root.tieba.DealAuthInfo.fromObject(object.authInfo[i]);
                }
            }
            if (object.shipFee != null)
                if ($util.Long)
                    (message.shipFee = $util.Long.fromValue(object.shipFee)).unsigned = true;
                else if (typeof object.shipFee === "string")
                    message.shipFee = parseInt(object.shipFee, 10);
                else if (typeof object.shipFee === "number")
                    message.shipFee = object.shipFee;
                else if (typeof object.shipFee === "object")
                    message.shipFee = new $util.LongBits(object.shipFee.low >>> 0, object.shipFee.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DealInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.DealInfo
         * @static
         * @param {tieba.DealInfo} message DealInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DealInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.media = [];
                object.authInfo = [];
            }
            if (options.defaults) {
                object.title = "";
                object.des = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.stock = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.stock = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.sales = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sales = options.longs === String ? "0" : 0;
                object.expireTime = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.unitPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unitPrice = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.productId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.productId = options.longs === String ? "0" : 0;
                object.sellerAddress = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.recommendations = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.recommendations = options.longs === String ? "0" : 0;
                object.hasRecommend = false;
                object.status = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.shipFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shipFee = options.longs === String ? "0" : 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.des != null && message.hasOwnProperty("des"))
                object.des = message.des;
            if (message.stock != null && message.hasOwnProperty("stock"))
                if (typeof message.stock === "number")
                    object.stock = options.longs === String ? String(message.stock) : message.stock;
                else
                    object.stock = options.longs === String ? $util.Long.prototype.toString.call(message.stock) : options.longs === Number ? new $util.LongBits(message.stock.low >>> 0, message.stock.high >>> 0).toNumber(true) : message.stock;
            if (message.sales != null && message.hasOwnProperty("sales"))
                if (typeof message.sales === "number")
                    object.sales = options.longs === String ? String(message.sales) : message.sales;
                else
                    object.sales = options.longs === String ? $util.Long.prototype.toString.call(message.sales) : options.longs === Number ? new $util.LongBits(message.sales.low >>> 0, message.sales.high >>> 0).toNumber(true) : message.sales;
            if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                object.expireTime = message.expireTime;
            if (message.unitPrice != null && message.hasOwnProperty("unitPrice"))
                if (typeof message.unitPrice === "number")
                    object.unitPrice = options.longs === String ? String(message.unitPrice) : message.unitPrice;
                else
                    object.unitPrice = options.longs === String ? $util.Long.prototype.toString.call(message.unitPrice) : options.longs === Number ? new $util.LongBits(message.unitPrice.low >>> 0, message.unitPrice.high >>> 0).toNumber(true) : message.unitPrice;
            if (message.productId != null && message.hasOwnProperty("productId"))
                if (typeof message.productId === "number")
                    object.productId = options.longs === String ? String(message.productId) : message.productId;
                else
                    object.productId = options.longs === String ? $util.Long.prototype.toString.call(message.productId) : options.longs === Number ? new $util.LongBits(message.productId.low >>> 0, message.productId.high >>> 0).toNumber(true) : message.productId;
            if (message.sellerAddress != null && message.hasOwnProperty("sellerAddress"))
                object.sellerAddress = message.sellerAddress;
            if (message.recommendations != null && message.hasOwnProperty("recommendations"))
                if (typeof message.recommendations === "number")
                    object.recommendations = options.longs === String ? String(message.recommendations) : message.recommendations;
                else
                    object.recommendations = options.longs === String ? $util.Long.prototype.toString.call(message.recommendations) : options.longs === Number ? new $util.LongBits(message.recommendations.low >>> 0, message.recommendations.high >>> 0).toNumber() : message.recommendations;
            if (message.hasRecommend != null && message.hasOwnProperty("hasRecommend"))
                object.hasRecommend = message.hasRecommend;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.media && message.media.length) {
                object.media = [];
                for (let j = 0; j < message.media.length; ++j)
                    object.media[j] = $root.tieba.DealMedia.toObject(message.media[j], options);
            }
            if (message.authInfo && message.authInfo.length) {
                object.authInfo = [];
                for (let j = 0; j < message.authInfo.length; ++j)
                    object.authInfo[j] = $root.tieba.DealAuthInfo.toObject(message.authInfo[j], options);
            }
            if (message.shipFee != null && message.hasOwnProperty("shipFee"))
                if (typeof message.shipFee === "number")
                    object.shipFee = options.longs === String ? String(message.shipFee) : message.shipFee;
                else
                    object.shipFee = options.longs === String ? $util.Long.prototype.toString.call(message.shipFee) : options.longs === Number ? new $util.LongBits(message.shipFee.low >>> 0, message.shipFee.high >>> 0).toNumber(true) : message.shipFee;
            return object;
        };

        /**
         * Converts this DealInfo to JSON.
         * @function toJSON
         * @memberof tieba.DealInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DealInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DealInfo
         * @function getTypeUrl
         * @memberof tieba.DealInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DealInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.DealInfo";
        };

        return DealInfo;
    })();

    tieba.DealAuthInfo = (function() {

        /**
         * Properties of a DealAuthInfo.
         * @memberof tieba
         * @interface IDealAuthInfo
         * @property {string|null} [itemName] DealAuthInfo itemName
         * @property {string|null} [itemContent] DealAuthInfo itemContent
         * @property {string|null} [itemUrl] DealAuthInfo itemUrl
         */

        /**
         * Constructs a new DealAuthInfo.
         * @memberof tieba
         * @classdesc Represents a DealAuthInfo.
         * @implements IDealAuthInfo
         * @constructor
         * @param {tieba.IDealAuthInfo=} [properties] Properties to set
         */
        function DealAuthInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DealAuthInfo itemName.
         * @member {string} itemName
         * @memberof tieba.DealAuthInfo
         * @instance
         */
        DealAuthInfo.prototype.itemName = "";

        /**
         * DealAuthInfo itemContent.
         * @member {string} itemContent
         * @memberof tieba.DealAuthInfo
         * @instance
         */
        DealAuthInfo.prototype.itemContent = "";

        /**
         * DealAuthInfo itemUrl.
         * @member {string} itemUrl
         * @memberof tieba.DealAuthInfo
         * @instance
         */
        DealAuthInfo.prototype.itemUrl = "";

        /**
         * Creates a new DealAuthInfo instance using the specified properties.
         * @function create
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {tieba.IDealAuthInfo=} [properties] Properties to set
         * @returns {tieba.DealAuthInfo} DealAuthInfo instance
         */
        DealAuthInfo.create = function create(properties) {
            return new DealAuthInfo(properties);
        };

        /**
         * Encodes the specified DealAuthInfo message. Does not implicitly {@link tieba.DealAuthInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {tieba.IDealAuthInfo} message DealAuthInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DealAuthInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemName != null && Object.hasOwnProperty.call(message, "itemName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.itemName);
            if (message.itemContent != null && Object.hasOwnProperty.call(message, "itemContent"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.itemContent);
            if (message.itemUrl != null && Object.hasOwnProperty.call(message, "itemUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.itemUrl);
            return writer;
        };

        /**
         * Encodes the specified DealAuthInfo message, length delimited. Does not implicitly {@link tieba.DealAuthInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {tieba.IDealAuthInfo} message DealAuthInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DealAuthInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DealAuthInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.DealAuthInfo} DealAuthInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealAuthInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.DealAuthInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemName = reader.string();
                        break;
                    }
                case 2: {
                        message.itemContent = reader.string();
                        break;
                    }
                case 3: {
                        message.itemUrl = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DealAuthInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.DealAuthInfo} DealAuthInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealAuthInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DealAuthInfo message.
         * @function verify
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DealAuthInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemName != null && message.hasOwnProperty("itemName"))
                if (!$util.isString(message.itemName))
                    return "itemName: string expected";
            if (message.itemContent != null && message.hasOwnProperty("itemContent"))
                if (!$util.isString(message.itemContent))
                    return "itemContent: string expected";
            if (message.itemUrl != null && message.hasOwnProperty("itemUrl"))
                if (!$util.isString(message.itemUrl))
                    return "itemUrl: string expected";
            return null;
        };

        /**
         * Creates a DealAuthInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.DealAuthInfo} DealAuthInfo
         */
        DealAuthInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.DealAuthInfo)
                return object;
            let message = new $root.tieba.DealAuthInfo();
            if (object.itemName != null)
                message.itemName = String(object.itemName);
            if (object.itemContent != null)
                message.itemContent = String(object.itemContent);
            if (object.itemUrl != null)
                message.itemUrl = String(object.itemUrl);
            return message;
        };

        /**
         * Creates a plain object from a DealAuthInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {tieba.DealAuthInfo} message DealAuthInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DealAuthInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.itemName = "";
                object.itemContent = "";
                object.itemUrl = "";
            }
            if (message.itemName != null && message.hasOwnProperty("itemName"))
                object.itemName = message.itemName;
            if (message.itemContent != null && message.hasOwnProperty("itemContent"))
                object.itemContent = message.itemContent;
            if (message.itemUrl != null && message.hasOwnProperty("itemUrl"))
                object.itemUrl = message.itemUrl;
            return object;
        };

        /**
         * Converts this DealAuthInfo to JSON.
         * @function toJSON
         * @memberof tieba.DealAuthInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DealAuthInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DealAuthInfo
         * @function getTypeUrl
         * @memberof tieba.DealAuthInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DealAuthInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.DealAuthInfo";
        };

        return DealAuthInfo;
    })();

    tieba.DealMedia = (function() {

        /**
         * Properties of a DealMedia.
         * @memberof tieba
         * @interface IDealMedia
         * @property {number|null} [type] DealMedia type
         * @property {string|null} [smallPic] DealMedia smallPic
         * @property {string|null} [bigPic] DealMedia bigPic
         * @property {string|null} [waterPic] DealMedia waterPic
         */

        /**
         * Constructs a new DealMedia.
         * @memberof tieba
         * @classdesc Represents a DealMedia.
         * @implements IDealMedia
         * @constructor
         * @param {tieba.IDealMedia=} [properties] Properties to set
         */
        function DealMedia(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DealMedia type.
         * @member {number} type
         * @memberof tieba.DealMedia
         * @instance
         */
        DealMedia.prototype.type = 0;

        /**
         * DealMedia smallPic.
         * @member {string} smallPic
         * @memberof tieba.DealMedia
         * @instance
         */
        DealMedia.prototype.smallPic = "";

        /**
         * DealMedia bigPic.
         * @member {string} bigPic
         * @memberof tieba.DealMedia
         * @instance
         */
        DealMedia.prototype.bigPic = "";

        /**
         * DealMedia waterPic.
         * @member {string} waterPic
         * @memberof tieba.DealMedia
         * @instance
         */
        DealMedia.prototype.waterPic = "";

        /**
         * Creates a new DealMedia instance using the specified properties.
         * @function create
         * @memberof tieba.DealMedia
         * @static
         * @param {tieba.IDealMedia=} [properties] Properties to set
         * @returns {tieba.DealMedia} DealMedia instance
         */
        DealMedia.create = function create(properties) {
            return new DealMedia(properties);
        };

        /**
         * Encodes the specified DealMedia message. Does not implicitly {@link tieba.DealMedia.verify|verify} messages.
         * @function encode
         * @memberof tieba.DealMedia
         * @static
         * @param {tieba.IDealMedia} message DealMedia message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DealMedia.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.smallPic != null && Object.hasOwnProperty.call(message, "smallPic"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.smallPic);
            if (message.bigPic != null && Object.hasOwnProperty.call(message, "bigPic"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.bigPic);
            if (message.waterPic != null && Object.hasOwnProperty.call(message, "waterPic"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.waterPic);
            return writer;
        };

        /**
         * Encodes the specified DealMedia message, length delimited. Does not implicitly {@link tieba.DealMedia.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.DealMedia
         * @static
         * @param {tieba.IDealMedia} message DealMedia message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DealMedia.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DealMedia message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.DealMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.DealMedia} DealMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealMedia.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.DealMedia();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.smallPic = reader.string();
                        break;
                    }
                case 3: {
                        message.bigPic = reader.string();
                        break;
                    }
                case 4: {
                        message.waterPic = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DealMedia message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.DealMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.DealMedia} DealMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DealMedia.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DealMedia message.
         * @function verify
         * @memberof tieba.DealMedia
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DealMedia.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.smallPic != null && message.hasOwnProperty("smallPic"))
                if (!$util.isString(message.smallPic))
                    return "smallPic: string expected";
            if (message.bigPic != null && message.hasOwnProperty("bigPic"))
                if (!$util.isString(message.bigPic))
                    return "bigPic: string expected";
            if (message.waterPic != null && message.hasOwnProperty("waterPic"))
                if (!$util.isString(message.waterPic))
                    return "waterPic: string expected";
            return null;
        };

        /**
         * Creates a DealMedia message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.DealMedia
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.DealMedia} DealMedia
         */
        DealMedia.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.DealMedia)
                return object;
            let message = new $root.tieba.DealMedia();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.smallPic != null)
                message.smallPic = String(object.smallPic);
            if (object.bigPic != null)
                message.bigPic = String(object.bigPic);
            if (object.waterPic != null)
                message.waterPic = String(object.waterPic);
            return message;
        };

        /**
         * Creates a plain object from a DealMedia message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.DealMedia
         * @static
         * @param {tieba.DealMedia} message DealMedia
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DealMedia.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = 0;
                object.smallPic = "";
                object.bigPic = "";
                object.waterPic = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.smallPic != null && message.hasOwnProperty("smallPic"))
                object.smallPic = message.smallPic;
            if (message.bigPic != null && message.hasOwnProperty("bigPic"))
                object.bigPic = message.bigPic;
            if (message.waterPic != null && message.hasOwnProperty("waterPic"))
                object.waterPic = message.waterPic;
            return object;
        };

        /**
         * Converts this DealMedia to JSON.
         * @function toJSON
         * @memberof tieba.DealMedia
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DealMedia.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DealMedia
         * @function getTypeUrl
         * @memberof tieba.DealMedia
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DealMedia.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.DealMedia";
        };

        return DealMedia;
    })();

    tieba.BaijiahaoInfo = (function() {

        /**
         * Properties of a BaijiahaoInfo.
         * @memberof tieba
         * @interface IBaijiahaoInfo
         * @property {string|null} [name] BaijiahaoInfo name
         * @property {string|null} [avatar] BaijiahaoInfo avatar
         * @property {string|null} [avatarH] BaijiahaoInfo avatarH
         * @property {string|null} [brief] BaijiahaoInfo brief
         * @property {number|null} [authId] BaijiahaoInfo authId
         * @property {string|null} [authDesc] BaijiahaoInfo authDesc
         * @property {number|null} [canModifyAvatar] BaijiahaoInfo canModifyAvatar
         */

        /**
         * Constructs a new BaijiahaoInfo.
         * @memberof tieba
         * @classdesc Represents a BaijiahaoInfo.
         * @implements IBaijiahaoInfo
         * @constructor
         * @param {tieba.IBaijiahaoInfo=} [properties] Properties to set
         */
        function BaijiahaoInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaijiahaoInfo name.
         * @member {string} name
         * @memberof tieba.BaijiahaoInfo
         * @instance
         */
        BaijiahaoInfo.prototype.name = "";

        /**
         * BaijiahaoInfo avatar.
         * @member {string} avatar
         * @memberof tieba.BaijiahaoInfo
         * @instance
         */
        BaijiahaoInfo.prototype.avatar = "";

        /**
         * BaijiahaoInfo avatarH.
         * @member {string} avatarH
         * @memberof tieba.BaijiahaoInfo
         * @instance
         */
        BaijiahaoInfo.prototype.avatarH = "";

        /**
         * BaijiahaoInfo brief.
         * @member {string} brief
         * @memberof tieba.BaijiahaoInfo
         * @instance
         */
        BaijiahaoInfo.prototype.brief = "";

        /**
         * BaijiahaoInfo authId.
         * @member {number} authId
         * @memberof tieba.BaijiahaoInfo
         * @instance
         */
        BaijiahaoInfo.prototype.authId = 0;

        /**
         * BaijiahaoInfo authDesc.
         * @member {string} authDesc
         * @memberof tieba.BaijiahaoInfo
         * @instance
         */
        BaijiahaoInfo.prototype.authDesc = "";

        /**
         * BaijiahaoInfo canModifyAvatar.
         * @member {number} canModifyAvatar
         * @memberof tieba.BaijiahaoInfo
         * @instance
         */
        BaijiahaoInfo.prototype.canModifyAvatar = 0;

        /**
         * Creates a new BaijiahaoInfo instance using the specified properties.
         * @function create
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {tieba.IBaijiahaoInfo=} [properties] Properties to set
         * @returns {tieba.BaijiahaoInfo} BaijiahaoInfo instance
         */
        BaijiahaoInfo.create = function create(properties) {
            return new BaijiahaoInfo(properties);
        };

        /**
         * Encodes the specified BaijiahaoInfo message. Does not implicitly {@link tieba.BaijiahaoInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {tieba.IBaijiahaoInfo} message BaijiahaoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaijiahaoInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.avatar);
            if (message.avatarH != null && Object.hasOwnProperty.call(message, "avatarH"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarH);
            if (message.brief != null && Object.hasOwnProperty.call(message, "brief"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.brief);
            if (message.authId != null && Object.hasOwnProperty.call(message, "authId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.authId);
            if (message.authDesc != null && Object.hasOwnProperty.call(message, "authDesc"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.authDesc);
            if (message.canModifyAvatar != null && Object.hasOwnProperty.call(message, "canModifyAvatar"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.canModifyAvatar);
            return writer;
        };

        /**
         * Encodes the specified BaijiahaoInfo message, length delimited. Does not implicitly {@link tieba.BaijiahaoInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {tieba.IBaijiahaoInfo} message BaijiahaoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaijiahaoInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaijiahaoInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.BaijiahaoInfo} BaijiahaoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaijiahaoInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.BaijiahaoInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.avatar = reader.string();
                        break;
                    }
                case 3: {
                        message.avatarH = reader.string();
                        break;
                    }
                case 4: {
                        message.brief = reader.string();
                        break;
                    }
                case 5: {
                        message.authId = reader.int32();
                        break;
                    }
                case 6: {
                        message.authDesc = reader.string();
                        break;
                    }
                case 7: {
                        message.canModifyAvatar = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BaijiahaoInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.BaijiahaoInfo} BaijiahaoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaijiahaoInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaijiahaoInfo message.
         * @function verify
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaijiahaoInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                if (!$util.isString(message.avatar))
                    return "avatar: string expected";
            if (message.avatarH != null && message.hasOwnProperty("avatarH"))
                if (!$util.isString(message.avatarH))
                    return "avatarH: string expected";
            if (message.brief != null && message.hasOwnProperty("brief"))
                if (!$util.isString(message.brief))
                    return "brief: string expected";
            if (message.authId != null && message.hasOwnProperty("authId"))
                if (!$util.isInteger(message.authId))
                    return "authId: integer expected";
            if (message.authDesc != null && message.hasOwnProperty("authDesc"))
                if (!$util.isString(message.authDesc))
                    return "authDesc: string expected";
            if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
                if (!$util.isInteger(message.canModifyAvatar))
                    return "canModifyAvatar: integer expected";
            return null;
        };

        /**
         * Creates a BaijiahaoInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.BaijiahaoInfo} BaijiahaoInfo
         */
        BaijiahaoInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.BaijiahaoInfo)
                return object;
            let message = new $root.tieba.BaijiahaoInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatar != null)
                message.avatar = String(object.avatar);
            if (object.avatarH != null)
                message.avatarH = String(object.avatarH);
            if (object.brief != null)
                message.brief = String(object.brief);
            if (object.authId != null)
                message.authId = object.authId | 0;
            if (object.authDesc != null)
                message.authDesc = String(object.authDesc);
            if (object.canModifyAvatar != null)
                message.canModifyAvatar = object.canModifyAvatar | 0;
            return message;
        };

        /**
         * Creates a plain object from a BaijiahaoInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {tieba.BaijiahaoInfo} message BaijiahaoInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaijiahaoInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.avatar = "";
                object.avatarH = "";
                object.brief = "";
                object.authId = 0;
                object.authDesc = "";
                object.canModifyAvatar = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatar != null && message.hasOwnProperty("avatar"))
                object.avatar = message.avatar;
            if (message.avatarH != null && message.hasOwnProperty("avatarH"))
                object.avatarH = message.avatarH;
            if (message.brief != null && message.hasOwnProperty("brief"))
                object.brief = message.brief;
            if (message.authId != null && message.hasOwnProperty("authId"))
                object.authId = message.authId;
            if (message.authDesc != null && message.hasOwnProperty("authDesc"))
                object.authDesc = message.authDesc;
            if (message.canModifyAvatar != null && message.hasOwnProperty("canModifyAvatar"))
                object.canModifyAvatar = message.canModifyAvatar;
            return object;
        };

        /**
         * Converts this BaijiahaoInfo to JSON.
         * @function toJSON
         * @memberof tieba.BaijiahaoInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaijiahaoInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BaijiahaoInfo
         * @function getTypeUrl
         * @memberof tieba.BaijiahaoInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BaijiahaoInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.BaijiahaoInfo";
        };

        return BaijiahaoInfo;
    })();

    tieba.MultipleForum = (function() {

        /**
         * Properties of a MultipleForum.
         * @memberof tieba
         * @interface IMultipleForum
         * @property {number|Long|null} [forumId] MultipleForum forumId
         * @property {string|null} [forumName] MultipleForum forumName
         * @property {number|null} [isBawu] MultipleForum isBawu
         * @property {string|null} [bawuType] MultipleForum bawuType
         * @property {number|null} [isDeleted] MultipleForum isDeleted
         */

        /**
         * Constructs a new MultipleForum.
         * @memberof tieba
         * @classdesc Represents a MultipleForum.
         * @implements IMultipleForum
         * @constructor
         * @param {tieba.IMultipleForum=} [properties] Properties to set
         */
        function MultipleForum(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MultipleForum forumId.
         * @member {number|Long} forumId
         * @memberof tieba.MultipleForum
         * @instance
         */
        MultipleForum.prototype.forumId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MultipleForum forumName.
         * @member {string} forumName
         * @memberof tieba.MultipleForum
         * @instance
         */
        MultipleForum.prototype.forumName = "";

        /**
         * MultipleForum isBawu.
         * @member {number} isBawu
         * @memberof tieba.MultipleForum
         * @instance
         */
        MultipleForum.prototype.isBawu = 0;

        /**
         * MultipleForum bawuType.
         * @member {string} bawuType
         * @memberof tieba.MultipleForum
         * @instance
         */
        MultipleForum.prototype.bawuType = "";

        /**
         * MultipleForum isDeleted.
         * @member {number} isDeleted
         * @memberof tieba.MultipleForum
         * @instance
         */
        MultipleForum.prototype.isDeleted = 0;

        /**
         * Creates a new MultipleForum instance using the specified properties.
         * @function create
         * @memberof tieba.MultipleForum
         * @static
         * @param {tieba.IMultipleForum=} [properties] Properties to set
         * @returns {tieba.MultipleForum} MultipleForum instance
         */
        MultipleForum.create = function create(properties) {
            return new MultipleForum(properties);
        };

        /**
         * Encodes the specified MultipleForum message. Does not implicitly {@link tieba.MultipleForum.verify|verify} messages.
         * @function encode
         * @memberof tieba.MultipleForum
         * @static
         * @param {tieba.IMultipleForum} message MultipleForum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultipleForum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forumId != null && Object.hasOwnProperty.call(message, "forumId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.forumId);
            if (message.forumName != null && Object.hasOwnProperty.call(message, "forumName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.forumName);
            if (message.isBawu != null && Object.hasOwnProperty.call(message, "isBawu"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isBawu);
            if (message.bawuType != null && Object.hasOwnProperty.call(message, "bawuType"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.bawuType);
            if (message.isDeleted != null && Object.hasOwnProperty.call(message, "isDeleted"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.isDeleted);
            return writer;
        };

        /**
         * Encodes the specified MultipleForum message, length delimited. Does not implicitly {@link tieba.MultipleForum.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.MultipleForum
         * @static
         * @param {tieba.IMultipleForum} message MultipleForum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultipleForum.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MultipleForum message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.MultipleForum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.MultipleForum} MultipleForum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultipleForum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.MultipleForum();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.forumId = reader.int64();
                        break;
                    }
                case 2: {
                        message.forumName = reader.string();
                        break;
                    }
                case 3: {
                        message.isBawu = reader.int32();
                        break;
                    }
                case 4: {
                        message.bawuType = reader.string();
                        break;
                    }
                case 5: {
                        message.isDeleted = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MultipleForum message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.MultipleForum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.MultipleForum} MultipleForum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultipleForum.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MultipleForum message.
         * @function verify
         * @memberof tieba.MultipleForum
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MultipleForum.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (!$util.isInteger(message.forumId) && !(message.forumId && $util.isInteger(message.forumId.low) && $util.isInteger(message.forumId.high)))
                    return "forumId: integer|Long expected";
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                if (!$util.isString(message.forumName))
                    return "forumName: string expected";
            if (message.isBawu != null && message.hasOwnProperty("isBawu"))
                if (!$util.isInteger(message.isBawu))
                    return "isBawu: integer expected";
            if (message.bawuType != null && message.hasOwnProperty("bawuType"))
                if (!$util.isString(message.bawuType))
                    return "bawuType: string expected";
            if (message.isDeleted != null && message.hasOwnProperty("isDeleted"))
                if (!$util.isInteger(message.isDeleted))
                    return "isDeleted: integer expected";
            return null;
        };

        /**
         * Creates a MultipleForum message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.MultipleForum
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.MultipleForum} MultipleForum
         */
        MultipleForum.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.MultipleForum)
                return object;
            let message = new $root.tieba.MultipleForum();
            if (object.forumId != null)
                if ($util.Long)
                    (message.forumId = $util.Long.fromValue(object.forumId)).unsigned = false;
                else if (typeof object.forumId === "string")
                    message.forumId = parseInt(object.forumId, 10);
                else if (typeof object.forumId === "number")
                    message.forumId = object.forumId;
                else if (typeof object.forumId === "object")
                    message.forumId = new $util.LongBits(object.forumId.low >>> 0, object.forumId.high >>> 0).toNumber();
            if (object.forumName != null)
                message.forumName = String(object.forumName);
            if (object.isBawu != null)
                message.isBawu = object.isBawu | 0;
            if (object.bawuType != null)
                message.bawuType = String(object.bawuType);
            if (object.isDeleted != null)
                message.isDeleted = object.isDeleted | 0;
            return message;
        };

        /**
         * Creates a plain object from a MultipleForum message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.MultipleForum
         * @static
         * @param {tieba.MultipleForum} message MultipleForum
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MultipleForum.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.forumId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.forumId = options.longs === String ? "0" : 0;
                object.forumName = "";
                object.isBawu = 0;
                object.bawuType = "";
                object.isDeleted = 0;
            }
            if (message.forumId != null && message.hasOwnProperty("forumId"))
                if (typeof message.forumId === "number")
                    object.forumId = options.longs === String ? String(message.forumId) : message.forumId;
                else
                    object.forumId = options.longs === String ? $util.Long.prototype.toString.call(message.forumId) : options.longs === Number ? new $util.LongBits(message.forumId.low >>> 0, message.forumId.high >>> 0).toNumber() : message.forumId;
            if (message.forumName != null && message.hasOwnProperty("forumName"))
                object.forumName = message.forumName;
            if (message.isBawu != null && message.hasOwnProperty("isBawu"))
                object.isBawu = message.isBawu;
            if (message.bawuType != null && message.hasOwnProperty("bawuType"))
                object.bawuType = message.bawuType;
            if (message.isDeleted != null && message.hasOwnProperty("isDeleted"))
                object.isDeleted = message.isDeleted;
            return object;
        };

        /**
         * Converts this MultipleForum to JSON.
         * @function toJSON
         * @memberof tieba.MultipleForum
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MultipleForum.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MultipleForum
         * @function getTypeUrl
         * @memberof tieba.MultipleForum
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MultipleForum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.MultipleForum";
        };

        return MultipleForum;
    })();

    tieba.LbsInfo = (function() {

        /**
         * Properties of a LbsInfo.
         * @memberof tieba
         * @interface ILbsInfo
         * @property {string|null} [lat] LbsInfo lat
         * @property {string|null} [lon] LbsInfo lon
         * @property {string|null} [town] LbsInfo town
         */

        /**
         * Constructs a new LbsInfo.
         * @memberof tieba
         * @classdesc Represents a LbsInfo.
         * @implements ILbsInfo
         * @constructor
         * @param {tieba.ILbsInfo=} [properties] Properties to set
         */
        function LbsInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LbsInfo lat.
         * @member {string} lat
         * @memberof tieba.LbsInfo
         * @instance
         */
        LbsInfo.prototype.lat = "";

        /**
         * LbsInfo lon.
         * @member {string} lon
         * @memberof tieba.LbsInfo
         * @instance
         */
        LbsInfo.prototype.lon = "";

        /**
         * LbsInfo town.
         * @member {string} town
         * @memberof tieba.LbsInfo
         * @instance
         */
        LbsInfo.prototype.town = "";

        /**
         * Creates a new LbsInfo instance using the specified properties.
         * @function create
         * @memberof tieba.LbsInfo
         * @static
         * @param {tieba.ILbsInfo=} [properties] Properties to set
         * @returns {tieba.LbsInfo} LbsInfo instance
         */
        LbsInfo.create = function create(properties) {
            return new LbsInfo(properties);
        };

        /**
         * Encodes the specified LbsInfo message. Does not implicitly {@link tieba.LbsInfo.verify|verify} messages.
         * @function encode
         * @memberof tieba.LbsInfo
         * @static
         * @param {tieba.ILbsInfo} message LbsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LbsInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.lat);
            if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.lon);
            if (message.town != null && Object.hasOwnProperty.call(message, "town"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.town);
            return writer;
        };

        /**
         * Encodes the specified LbsInfo message, length delimited. Does not implicitly {@link tieba.LbsInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.LbsInfo
         * @static
         * @param {tieba.ILbsInfo} message LbsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LbsInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LbsInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.LbsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.LbsInfo} LbsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LbsInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.LbsInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lat = reader.string();
                        break;
                    }
                case 2: {
                        message.lon = reader.string();
                        break;
                    }
                case 3: {
                        message.town = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LbsInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.LbsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.LbsInfo} LbsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LbsInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LbsInfo message.
         * @function verify
         * @memberof tieba.LbsInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LbsInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lat != null && message.hasOwnProperty("lat"))
                if (!$util.isString(message.lat))
                    return "lat: string expected";
            if (message.lon != null && message.hasOwnProperty("lon"))
                if (!$util.isString(message.lon))
                    return "lon: string expected";
            if (message.town != null && message.hasOwnProperty("town"))
                if (!$util.isString(message.town))
                    return "town: string expected";
            return null;
        };

        /**
         * Creates a LbsInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.LbsInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.LbsInfo} LbsInfo
         */
        LbsInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.LbsInfo)
                return object;
            let message = new $root.tieba.LbsInfo();
            if (object.lat != null)
                message.lat = String(object.lat);
            if (object.lon != null)
                message.lon = String(object.lon);
            if (object.town != null)
                message.town = String(object.town);
            return message;
        };

        /**
         * Creates a plain object from a LbsInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.LbsInfo
         * @static
         * @param {tieba.LbsInfo} message LbsInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LbsInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.lat = "";
                object.lon = "";
                object.town = "";
            }
            if (message.lat != null && message.hasOwnProperty("lat"))
                object.lat = message.lat;
            if (message.lon != null && message.hasOwnProperty("lon"))
                object.lon = message.lon;
            if (message.town != null && message.hasOwnProperty("town"))
                object.town = message.town;
            return object;
        };

        /**
         * Converts this LbsInfo to JSON.
         * @function toJSON
         * @memberof tieba.LbsInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LbsInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LbsInfo
         * @function getTypeUrl
         * @memberof tieba.LbsInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LbsInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.LbsInfo";
        };

        return LbsInfo;
    })();

    tieba.UserPostPerm = (function() {

        /**
         * Properties of a UserPostPerm.
         * @memberof tieba
         * @interface IUserPostPerm
         * @property {number|null} [notShowHideThread] UserPostPerm notShowHideThread
         */

        /**
         * Constructs a new UserPostPerm.
         * @memberof tieba
         * @classdesc Represents a UserPostPerm.
         * @implements IUserPostPerm
         * @constructor
         * @param {tieba.IUserPostPerm=} [properties] Properties to set
         */
        function UserPostPerm(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserPostPerm notShowHideThread.
         * @member {number} notShowHideThread
         * @memberof tieba.UserPostPerm
         * @instance
         */
        UserPostPerm.prototype.notShowHideThread = 0;

        /**
         * Creates a new UserPostPerm instance using the specified properties.
         * @function create
         * @memberof tieba.UserPostPerm
         * @static
         * @param {tieba.IUserPostPerm=} [properties] Properties to set
         * @returns {tieba.UserPostPerm} UserPostPerm instance
         */
        UserPostPerm.create = function create(properties) {
            return new UserPostPerm(properties);
        };

        /**
         * Encodes the specified UserPostPerm message. Does not implicitly {@link tieba.UserPostPerm.verify|verify} messages.
         * @function encode
         * @memberof tieba.UserPostPerm
         * @static
         * @param {tieba.IUserPostPerm} message UserPostPerm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPostPerm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.notShowHideThread != null && Object.hasOwnProperty.call(message, "notShowHideThread"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.notShowHideThread);
            return writer;
        };

        /**
         * Encodes the specified UserPostPerm message, length delimited. Does not implicitly {@link tieba.UserPostPerm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tieba.UserPostPerm
         * @static
         * @param {tieba.IUserPostPerm} message UserPostPerm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPostPerm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserPostPerm message from the specified reader or buffer.
         * @function decode
         * @memberof tieba.UserPostPerm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tieba.UserPostPerm} UserPostPerm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPostPerm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tieba.UserPostPerm();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.notShowHideThread = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserPostPerm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tieba.UserPostPerm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tieba.UserPostPerm} UserPostPerm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPostPerm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserPostPerm message.
         * @function verify
         * @memberof tieba.UserPostPerm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserPostPerm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.notShowHideThread != null && message.hasOwnProperty("notShowHideThread"))
                if (!$util.isInteger(message.notShowHideThread))
                    return "notShowHideThread: integer expected";
            return null;
        };

        /**
         * Creates a UserPostPerm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tieba.UserPostPerm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tieba.UserPostPerm} UserPostPerm
         */
        UserPostPerm.fromObject = function fromObject(object) {
            if (object instanceof $root.tieba.UserPostPerm)
                return object;
            let message = new $root.tieba.UserPostPerm();
            if (object.notShowHideThread != null)
                message.notShowHideThread = object.notShowHideThread >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a UserPostPerm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tieba.UserPostPerm
         * @static
         * @param {tieba.UserPostPerm} message UserPostPerm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserPostPerm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.notShowHideThread = 0;
            if (message.notShowHideThread != null && message.hasOwnProperty("notShowHideThread"))
                object.notShowHideThread = message.notShowHideThread;
            return object;
        };

        /**
         * Converts this UserPostPerm to JSON.
         * @function toJSON
         * @memberof tieba.UserPostPerm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserPostPerm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserPostPerm
         * @function getTypeUrl
         * @memberof tieba.UserPostPerm
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserPostPerm.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/tieba.UserPostPerm";
        };

        return UserPostPerm;
    })();

    return tieba;
})();

export { $root as default };
